<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>cdev - Development Environment</title>
  <style>
    :root {
      --bg: #1a1a2e;
      --card-bg: #16213e;
      --accent: #0f3460;
      --primary: #e94560;
      --text: #eaeaea;
      --text-muted: #a0a0a0;
      --success: #4ade80;
      --warning: #fbbf24;
      --error: #f87171;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 2rem;
    }
    .container { max-width: 900px; margin: 0 auto; }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
    }
    h1 { font-size: 1.5rem; display: flex; align-items: center; gap: 0.5rem; }
    .status-dot {
      width: 10px; height: 10px;
      border-radius: 50%;
      background: var(--success);
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .refresh-info { color: var(--text-muted); font-size: 0.875rem; }
    .services { display: flex; flex-direction: column; gap: 1rem; }
    .service {
      background: var(--card-bg);
      border-radius: 8px;
      padding: 1rem 1.25rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      transition: transform 0.1s, box-shadow 0.1s;
    }
    .service:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .service-emoji { font-size: 1.5rem; }
    .service-info { flex: 1; }
    .service-name { font-weight: 600; font-size: 1.1rem; }
    .service-deps { color: var(--text-muted); font-size: 0.8rem; margin-top: 0.25rem; }
    .service-step { color: var(--primary); font-size: 0.8rem; margin-top: 0.25rem; font-style: italic; }
    .service-unmet { color: var(--warning); font-size: 0.8rem; margin-top: 0.25rem; }
    .service-status {
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 500;
      text-transform: uppercase;
    }
    .status-completed { background: rgba(74, 222, 128, 0.2); color: var(--success); }
    .status-started { background: rgba(251, 191, 36, 0.2); color: var(--warning); }
    .status-pending { background: rgba(160, 160, 160, 0.2); color: var(--text-muted); }
    .status-not-registered { background: rgba(248, 113, 113, 0.2); color: var(--error); }
    .service-actions { display: flex; gap: 0.5rem; }
    button {
      background: var(--accent);
      border: none;
      color: var(--text);
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.875rem;
      transition: background 0.2s;
    }
    button:hover { background: var(--primary); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .error {
      background: rgba(248, 113, 113, 0.1);
      border: 1px solid var(--error);
      color: var(--error);
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1rem;
    }
    .loading {
      text-align: center;
      padding: 3rem;
      color: var(--text-muted);
    }
    .section-title {
      font-size: 1.25rem;
      margin: 2rem 0 1rem;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .section-title:first-of-type { margin-top: 0; }
    .images { display: flex; flex-direction: column; gap: 0.5rem; }
    .image {
      background: var(--card-bg);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      font-size: 0.9rem;
    }
    .image-info { flex: 1; min-width: 0; }
    .image-tags { 
      font-family: monospace; 
      font-size: 0.85rem;
      word-break: break-all;
    }
    .image-meta { 
      color: var(--text-muted); 
      font-size: 0.75rem; 
      margin-top: 0.25rem;
    }
    .image-id { 
      font-family: monospace; 
      font-size: 0.75rem; 
      color: var(--text-muted);
      width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    button.danger { background: rgba(248, 113, 113, 0.3); }
    button.danger:hover { background: var(--error); }
    /* Modal styles */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      padding: 2rem;
    }
    .modal-overlay.active { display: flex; }
    .modal {
      background: var(--card-bg);
      border-radius: 12px;
      width: 100%;
      max-width: 1000px;
      height: 80vh;
      margin: auto;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--accent);
    }
    .modal-title { font-size: 1.1rem; font-weight: 600; }
    .modal-close {
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
    }
    .modal-close:hover { color: var(--text); background: transparent; }
    .modal-body {
      flex: 1;
      overflow: auto;
      padding: 1rem;
      background: #0d1117;
    }
    .log-content {
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 0.8rem;
      line-height: 1.5;
      white-space: pre-wrap;
      word-break: break-all;
      color: #c9d1d9;
    }
    .log-error { color: var(--error); padding: 1rem; }
    .volumes { display: flex; flex-direction: column; gap: 0.5rem; }
    .volume {
      background: var(--card-bg);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      font-size: 0.9rem;
    }
    .volume-info { flex: 1; min-width: 0; }
    .volume-name { 
      font-family: monospace; 
      font-size: 0.85rem;
      word-break: break-all;
    }
    .volume-meta { 
      color: var(--text-muted); 
      font-size: 0.75rem; 
      margin-top: 0.25rem;
    }
  </style>
</head>
<body>
  <!-- Logs Modal -->
  <div id="logs-modal" class="modal-overlay" onclick="if(event.target===this)closeLogs()">
    <div class="modal">
      <div class="modal-header">
        <span class="modal-title" id="logs-title">Logs</span>
        <button class="modal-close" onclick="closeLogs()">&times;</button>
      </div>
      <div class="modal-body">
        <div id="logs-content" class="log-content"></div>
      </div>
    </div>
  </div>

  <div class="container">
    <header>
      <h1><span class="status-dot"></span> cdev</h1>
      <span class="refresh-info">Live (SSE)</span>
    </header>
    <div id="error" class="error" style="display: none;"></div>
    
    <h2 class="section-title">üì¶ Services</h2>
    <div id="services" class="services">
      <div class="loading">Loading services...</div>
    </div>

    <h2 class="section-title">üê≥ Docker Images</h2>
    <div id="images" class="images">
      <div class="loading">Loading images...</div>
    </div>

    <h2 class="section-title">üíæ Docker Volumes</h2>
    <div id="volumes" class="volumes">
      <div class="loading">Loading volumes...</div>
    </div>
  </div>

  <script>
    const API_BASE = '';
    let services = [];
    let images = [];
    let volumes = [];

    async function fetchServices() {
      try {
        const res = await fetch(`${API_BASE}/api/services`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        services = data.services || [];
        hideError();
        renderServices();
      } catch (err) {
        showError(`Failed to fetch services: ${err.message}`);
      }
    }

    async function startService(name) {
      setLoading(name, true);
      try {
        const res = await fetch(`${API_BASE}/api/services/${name}/start`, { method: 'POST' });
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || `HTTP ${res.status}`);
        }
      } catch (err) {
        showError(`Failed to start ${name}: ${err.message}`);
      } finally {
        setLoading(name, false);
      }
    }

    async function fetchImages() {
      try {
        const res = await fetch(`${API_BASE}/api/images`);
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || `HTTP ${res.status}`);
        }
        const data = await res.json();
        images = data.images || [];
        renderImages();
      } catch (err) {
        images = [];
        renderImages(err.message);
      }
    }

    async function fetchVolumes() {
      try {
        const res = await fetch(`${API_BASE}/api/volumes`);
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || `HTTP ${res.status}`);
        }
        const data = await res.json();
        volumes = data.volumes || [];
        renderVolumes();
      } catch (err) {
        volumes = [];
        renderVolumes(err.message);
      }
    }


    async function restartService(name) {
      setLoading(name, true);
      try {
        const res = await fetch(`${API_BASE}/api/services/${name}/restart`, { method: 'POST' });
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || `HTTP ${res.status}`);
        }
      } catch (err) {
        showError(`Failed to restart ${name}: ${err.message}`);
      } finally {
        setLoading(name, false);
      }
    }

    async function stopService(name) {
      setLoading(name, true);
      try {
        const res = await fetch(`${API_BASE}/api/services/${name}/stop`, { method: 'POST' });
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || `HTTP ${res.status}`);
        }
      } catch (err) {
        showError(`Failed to stop ${name}: ${err.message}`);
      } finally {
        setLoading(name, false);
      }
    }

    async function deleteImage(id) {
      if (!confirm('Delete this image?')) return;
      try {
        const res = await fetch(`${API_BASE}/api/images/${encodeURIComponent(id)}`, { method: 'DELETE' });
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || `HTTP ${res.status}`);
        }
        fetchImages();
      } catch (err) {
        showError(`Failed to delete image: ${err.message}`);
      }
    }

    async function deleteVolume(name) {
      if (!confirm(`Delete volume "${name}"?`)) return;
      try {
        const res = await fetch(`${API_BASE}/api/volumes/${encodeURIComponent(name)}`, { method: 'DELETE' });
        if (!res.ok) {
          const data = await res.json();
          throw new Error(data.error || `HTTP ${res.status}`);
        }
        fetchVolumes();
      } catch (err) {
        showError(`Failed to delete volume: ${err.message}`);
      }
    }

    function setLoading(name, loading) {
      const btns = document.querySelectorAll(`[data-service="${name}"] button`);
      btns.forEach(btn => btn.disabled = loading);
    }

    async function copyURL(url) {
      try {
        await navigator.clipboard.writeText(url);
        // Brief visual feedback - find the button and flash it.
        const btn = document.querySelector(`button[title="${url}"]`);
        if (btn) {
          const orig = btn.textContent;
          btn.textContent = '‚úì Copied';
          setTimeout(() => btn.textContent = orig, 1500);
        }
      } catch (err) {
        showError(`Failed to copy URL: ${err.message}`);
      }
    }

    // Logs modal
    let logsAbortController = null;

    function showLogs(serviceName) {
      const modal = document.getElementById('logs-modal');
      const title = document.getElementById('logs-title');
      const content = document.getElementById('logs-content');
      
      title.textContent = `Logs: ${serviceName}`;
      content.textContent = 'Loading...';
      modal.classList.add('active');
      
      // Abort any existing stream.
      if (logsAbortController) {
        logsAbortController.abort();
      }
      logsAbortController = new AbortController();
      
      // Fetch streaming logs.
      fetch(`${API_BASE}/api/services/${serviceName}/logs`, {
        signal: logsAbortController.signal
      }).then(async response => {
        if (!response.ok) {
          const data = await response.json();
          content.innerHTML = `<div class="log-error">Error: ${data.error || response.statusText}</div>`;
          return;
        }
        
        content.textContent = '';
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        const modalBody = content.parentElement;
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          content.textContent += decoder.decode(value, { stream: true });
          // Auto-scroll to bottom.
          modalBody.scrollTop = modalBody.scrollHeight;
        }
      }).catch(err => {
        if (err.name !== 'AbortError') {
          content.innerHTML = `<div class="log-error">Error: ${err.message}</div>`;
        }
      });
    }

    function closeLogs() {
      const modal = document.getElementById('logs-modal');
      modal.classList.remove('active');
      if (logsAbortController) {
        logsAbortController.abort();
        logsAbortController = null;
      }
    }

    // Close modal on Escape key.
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') closeLogs();
    });

    let errorTimeout = null;

    function showError(msg) {
      const el = document.getElementById('error');
      el.textContent = msg;
      el.style.display = 'block';
      // Clear any existing timeout and set a new one to auto-hide after 15s.
      if (errorTimeout) clearTimeout(errorTimeout);
      errorTimeout = setTimeout(hideError, 15000);
    }

    function hideError() {
      document.getElementById('error').style.display = 'none';
      if (errorTimeout) {
        clearTimeout(errorTimeout);
        errorTimeout = null;
      }
    }

    function renderServices() {
      const container = document.getElementById('services');
      if (services.length === 0) {
        container.innerHTML = '<div class="loading">No services found</div>';
        return;
      }

      const sorted = [...services].sort((a, b) => a.name.localeCompare(b.name));
      container.innerHTML = sorted.map(svc => {
        // Handle empty status (not registered) and format for CSS class.
        const status = svc.status || 'not-registered';
        const statusClass = 'status-' + status.replace('_', '-');
        const statusLabel = status === 'not-registered' ? 'not registered' : status;
        const stepHtml = svc.current_step
          ? `<div class="service-step">‚ñ∂ ${svc.current_step}</div>`
          : '';
        const unmetHtml = svc.unmet_dependencies?.length
          ? `<div class="service-unmet">‚è≥ waiting for: ${svc.unmet_dependencies.join(', ')}</div>`
          : '';
        return `
          <div class="service" data-service="${svc.name}">
            <span class="service-emoji">${svc.emoji}</span>
            <div class="service-info">
              <div class="service-name">${svc.name}</div>
              <div class="service-deps">${svc.depends_on?.length ? `depends on: ${svc.depends_on.join(', ')}` : 'no dependencies'}</div>
              ${stepHtml}
              ${unmetHtml}
            </div>
            <span class="service-status ${statusClass}">${statusLabel}</span>
            <div class="service-actions">
              ${svc.url ? `<button onclick="copyURL('${svc.url}')" title="${svc.url}">üìã URL</button>` : ''}
              <button onclick="showLogs('${svc.name}')">Logs</button>
              ${svc.status === 'pending' ? `<button onclick="startService('${svc.name}')">Start</button>` : ''}
              ${svc.status !== 'pending' ? `<button onclick="restartService('${svc.name}')">Restart</button>` : ''}
              ${svc.status !== 'pending' ? `<button onclick="stopService('${svc.name}')">Stop</button>` : ''}
            </div>
          </div>
        `;
      }).join('');
    }

    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }

    function formatDate(timestamp) {
      return new Date(timestamp * 1000).toLocaleDateString();
    }

    function renderImages(error) {
      const container = document.getElementById('images');
      if (error) {
        const hint = error.includes('docker not connected') 
          ? ' Start the <strong>docker</strong> service first.' 
          : '';
        container.innerHTML = `<div class="loading" style="color: var(--error)">‚ö†Ô∏è ${error}.${hint}</div>`;
        return;
      }
      if (images.length === 0) {
        container.innerHTML = '<div class="loading">No images found</div>';
        return;
      }

      // Sort by creation date, newest first.
      const sorted = [...images].sort((a, b) => b.created - a.created);
      container.innerHTML = sorted.map(img => {
        const shortId = img.id.replace('sha256:', '').substring(0, 12);
        const tags = img.tags?.length ? img.tags.join(', ') : '<none>';
        return `
          <div class="image">
            <span class="image-id" title="${img.id}">${shortId}</span>
            <div class="image-info">
              <div class="image-tags">${tags}</div>
              <div class="image-meta">${formatBytes(img.size)} ‚Ä¢ ${formatDate(img.created)}</div>
            </div>
            <button class="danger" onclick="deleteImage('${img.id}')">Delete</button>
          </div>
        `;
      }).join('');
    }

    function renderVolumes(error) {
      const container = document.getElementById('volumes');
      if (error) {
        const hint = error.includes('docker not connected') 
          ? ' Start the <strong>docker</strong> service first.' 
          : '';
        container.innerHTML = `<div class="loading" style="color: var(--error)">‚ö†Ô∏è ${error}.${hint}</div>`;
        return;
      }
      if (volumes.length === 0) {
        container.innerHTML = '<div class="loading">No volumes found</div>';
        return;
      }

      // Sort by name.
      const sorted = [...volumes].sort((a, b) => a.name.localeCompare(b.name));
      container.innerHTML = sorted.map(vol => {
        return `
          <div class="volume">
            <div class="volume-info">
              <div class="volume-name">${vol.name}</div>
              <div class="volume-meta">${vol.driver}</div>
            </div>
            <button class="danger" onclick="deleteVolume('${vol.name}')">Delete</button>
          </div>
        `;
      }).join('');
    }

    // Use Server-Sent Events for live updates.
    const evtSource = new EventSource('/api/events');
    evtSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      services = data.services || [];
      // Don't hide errors here - let them timeout naturally.
      renderServices();
    };
    evtSource.onerror = () => {
      showError('SSE connection lost, retrying...');
    };

    // Fetch images and volumes on load and periodically refresh.
    fetchImages();
    fetchVolumes();
    setInterval(fetchImages, 10000);
    setInterval(fetchVolumes, 10000);
  </script>
</body>
</html>
