package main

import (
	"bytes"
	"database/sql"
	"fmt"
	"go/format"
	"os"
	"strings"

	"golang.org/x/xerrors"

	"github.com/coder/coder/v2/coderd/database/dbtestutil"
	"github.com/coder/coder/v2/coderd/database/migrations"
)

type mockTB struct {
	cleanup []func()
}

func (*mockTB) Name() string {
	return "mockTB"
}

func (t *mockTB) Cleanup(f func()) {
	t.cleanup = append(t.cleanup, f)
}

func (*mockTB) Helper() {
	// noop
}

func (*mockTB) Logf(format string, args ...any) {
	_, _ = fmt.Printf(format, args...)
}

func (*mockTB) TempDir() string {
	panic("not implemented")
}

// templateRow holds a row from the notification_templates table.
type templateRow struct {
	id    string
	name  string
	group string
}

func main() {
	out, err := generate()
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "generate notification events: %v\n", err)
		os.Exit(1)
	}
	if _, err := fmt.Print(string(out)); err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "write output: %v\n", err)
		os.Exit(1)
	}
}

func generate() ([]byte, error) {
	t := &mockTB{}
	defer func() {
		for _, f := range t.cleanup {
			f()
		}
	}()

	connection := os.Getenv("DB_GEN_CONNECTION_URL")
	if connection == "" {
		var cleanup func()
		var err error
		connection, cleanup, err = dbtestutil.OpenContainerized(t, dbtestutil.DBContainerOptions{})
		if err != nil {
			return nil, xerrors.Errorf("open containerized database failed: %w", err)
		}
		defer cleanup()
	}

	db, err := sql.Open("postgres", connection)
	if err != nil {
		return nil, xerrors.Errorf("open database failed: %w", err)
	}
	defer db.Close()

	err = migrations.Up(db)
	if err != nil {
		return nil, xerrors.Errorf("run migrations failed: %w", err)
	}

	rows, err := db.Query(`SELECT id, name, "group" FROM notification_templates ORDER BY "group", name`)
	if err != nil {
		return nil, xerrors.Errorf("query notification_templates failed: %w", err)
	}
	defer rows.Close()

	var templates []templateRow
	for rows.Next() {
		var tmpl templateRow
		if err := rows.Scan(&tmpl.id, &tmpl.name, &tmpl.group); err != nil {
			return nil, xerrors.Errorf("scan row failed: %w", err)
		}
		templates = append(templates, tmpl)
	}
	if err := rows.Err(); err != nil {
		return nil, xerrors.Errorf("rows iteration failed: %w", err)
	}

	var b bytes.Buffer
	_, _ = b.WriteString("// Code generated by scripts/notificationtemplatesgen. DO NOT EDIT.\n")
	_, _ = b.WriteString("package notifications\n\n")
	_, _ = b.WriteString("import \"github.com/google/uuid\"\n\n")

	// Group templates by their group column.
	currentGroup := ""
	for i, tmpl := range templates {
		if tmpl.group != currentGroup {
			// Close previous group if open.
			if currentGroup != "" {
				_, _ = b.WriteString(")\n\n")
			}
			currentGroup = tmpl.group
			_, _ = fmt.Fprintf(&b, "// %s.\nvar (\n", pascal(currentGroup))
		}
		constName := "Template" + pascal(tmpl.name)
		_, _ = fmt.Fprintf(&b, "\t%s = uuid.MustParse(%q)\n", constName, tmpl.id)
		// Close the last group.
		if i == len(templates)-1 {
			_, _ = b.WriteString(")\n")
		}
	}

	return format.Source(b.Bytes())
}

func pascal(s string) string {
	// Replace non-identifier separators with spaces, then
	// Title-case each word and join.
	s = strings.ReplaceAll(s, "_", " ")
	s = strings.ReplaceAll(s, "-", " ")
	s = strings.ReplaceAll(s, ":", " ")
	s = strings.ReplaceAll(s, ".", " ")
	words := strings.Fields(s)
	for i := range words {
		words[i] = strings.ToUpper(words[i][:1]) + words[i][1:]
	}
	return strings.Join(words, "")
}
