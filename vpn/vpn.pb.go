// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v4.23.4
// source: vpn/vpn.proto

package vpn

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// StartProgress is sent from the manager to the client to indicate the
// download/startup progress of the tunnel. This will be sent during the
// processing of a StartRequest before the StartResponse is sent.
//
// Note: this is currently a broadcasted message to all clients due to the
//
//	inability to easily send messages to a specific client in the Speaker
//	implementation. If clients are not expecting these messages, they
//	should ignore them.
type StartProgressStage int32

const (
	StartProgressStage_Initializing StartProgressStage = 0
	StartProgressStage_Downloading  StartProgressStage = 1
	StartProgressStage_Finalizing   StartProgressStage = 2
)

// Enum value maps for StartProgressStage.
var (
	StartProgressStage_name = map[int32]string{
		0: "Initializing",
		1: "Downloading",
		2: "Finalizing",
	}
	StartProgressStage_value = map[string]int32{
		"Initializing": 0,
		"Downloading":  1,
		"Finalizing":   2,
	}
)

func (x StartProgressStage) Enum() *StartProgressStage {
	p := new(StartProgressStage)
	*p = x
	return p
}

func (x StartProgressStage) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StartProgressStage) Descriptor() protoreflect.EnumDescriptor {
	return file_vpn_vpn_proto_enumTypes[0].Descriptor()
}

func (StartProgressStage) Type() protoreflect.EnumType {
	return &file_vpn_vpn_proto_enumTypes[0]
}

func (x StartProgressStage) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StartProgressStage.Descriptor instead.
func (StartProgressStage) EnumDescriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{0}
}

type Log_Level int32

const (
	// these are designed to match slog levels
	Log_DEBUG    Log_Level = 0
	Log_INFO     Log_Level = 1
	Log_WARN     Log_Level = 2
	Log_ERROR    Log_Level = 3
	Log_CRITICAL Log_Level = 4
	Log_FATAL    Log_Level = 5
)

// Enum value maps for Log_Level.
var (
	Log_Level_name = map[int32]string{
		0: "DEBUG",
		1: "INFO",
		2: "WARN",
		3: "ERROR",
		4: "CRITICAL",
		5: "FATAL",
	}
	Log_Level_value = map[string]int32{
		"DEBUG":    0,
		"INFO":     1,
		"WARN":     2,
		"ERROR":    3,
		"CRITICAL": 4,
		"FATAL":    5,
	}
)

func (x Log_Level) Enum() *Log_Level {
	p := new(Log_Level)
	*p = x
	return p
}

func (x Log_Level) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Log_Level) Descriptor() protoreflect.EnumDescriptor {
	return file_vpn_vpn_proto_enumTypes[1].Descriptor()
}

func (Log_Level) Type() protoreflect.EnumType {
	return &file_vpn_vpn_proto_enumTypes[1]
}

func (x Log_Level) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Log_Level.Descriptor instead.
func (Log_Level) EnumDescriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{5, 0}
}

type Workspace_Status int32

const (
	Workspace_UNKNOWN   Workspace_Status = 0
	Workspace_PENDING   Workspace_Status = 1
	Workspace_STARTING  Workspace_Status = 2
	Workspace_RUNNING   Workspace_Status = 3
	Workspace_STOPPING  Workspace_Status = 4
	Workspace_STOPPED   Workspace_Status = 5
	Workspace_FAILED    Workspace_Status = 6
	Workspace_CANCELING Workspace_Status = 7
	Workspace_CANCELED  Workspace_Status = 8
	Workspace_DELETING  Workspace_Status = 9
	Workspace_DELETED   Workspace_Status = 10
)

// Enum value maps for Workspace_Status.
var (
	Workspace_Status_name = map[int32]string{
		0:  "UNKNOWN",
		1:  "PENDING",
		2:  "STARTING",
		3:  "RUNNING",
		4:  "STOPPING",
		5:  "STOPPED",
		6:  "FAILED",
		7:  "CANCELING",
		8:  "CANCELED",
		9:  "DELETING",
		10: "DELETED",
	}
	Workspace_Status_value = map[string]int32{
		"UNKNOWN":   0,
		"PENDING":   1,
		"STARTING":  2,
		"RUNNING":   3,
		"STOPPING":  4,
		"STOPPED":   5,
		"FAILED":    6,
		"CANCELING": 7,
		"CANCELED":  8,
		"DELETING":  9,
		"DELETED":   10,
	}
)

func (x Workspace_Status) Enum() *Workspace_Status {
	p := new(Workspace_Status)
	*p = x
	return p
}

func (x Workspace_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Workspace_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_vpn_vpn_proto_enumTypes[2].Descriptor()
}

func (Workspace_Status) Type() protoreflect.EnumType {
	return &file_vpn_vpn_proto_enumTypes[2]
}

func (x Workspace_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Workspace_Status.Descriptor instead.
func (Workspace_Status) EnumDescriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{8, 0}
}

type Status_Lifecycle int32

const (
	Status_UNKNOWN  Status_Lifecycle = 0
	Status_STARTING Status_Lifecycle = 1
	Status_STARTED  Status_Lifecycle = 2
	Status_STOPPING Status_Lifecycle = 3
	Status_STOPPED  Status_Lifecycle = 4
)

// Enum value maps for Status_Lifecycle.
var (
	Status_Lifecycle_name = map[int32]string{
		0: "UNKNOWN",
		1: "STARTING",
		2: "STARTED",
		3: "STOPPING",
		4: "STOPPED",
	}
	Status_Lifecycle_value = map[string]int32{
		"UNKNOWN":  0,
		"STARTING": 1,
		"STARTED":  2,
		"STOPPING": 3,
		"STOPPED":  4,
	}
)

func (x Status_Lifecycle) Enum() *Status_Lifecycle {
	p := new(Status_Lifecycle)
	*p = x
	return p
}

func (x Status_Lifecycle) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Status_Lifecycle) Descriptor() protoreflect.EnumDescriptor {
	return file_vpn_vpn_proto_enumTypes[3].Descriptor()
}

func (Status_Lifecycle) Type() protoreflect.EnumType {
	return &file_vpn_vpn_proto_enumTypes[3]
}

func (x Status_Lifecycle) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Status_Lifecycle.Descriptor instead.
func (Status_Lifecycle) EnumDescriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{20, 0}
}

// RPC allows a very simple unary request/response RPC mechanism.  The requester generates a unique
// msg_id which it sets on the request, the responder sets response_to that msg_id on the response
// message
type RPC struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MsgId         uint64                 `protobuf:"varint,1,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	ResponseTo    uint64                 `protobuf:"varint,2,opt,name=response_to,json=responseTo,proto3" json:"response_to,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RPC) Reset() {
	*x = RPC{}
	mi := &file_vpn_vpn_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RPC) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RPC) ProtoMessage() {}

func (x *RPC) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RPC.ProtoReflect.Descriptor instead.
func (*RPC) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{0}
}

func (x *RPC) GetMsgId() uint64 {
	if x != nil {
		return x.MsgId
	}
	return 0
}

func (x *RPC) GetResponseTo() uint64 {
	if x != nil {
		return x.ResponseTo
	}
	return 0
}

// ManagerMessage is a message from the manager (to the tunnel).
type ManagerMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Rpc   *RPC                   `protobuf:"bytes,1,opt,name=rpc,proto3" json:"rpc,omitempty"`
	// Types that are valid to be assigned to Msg:
	//
	//	*ManagerMessage_GetPeerUpdate
	//	*ManagerMessage_NetworkSettings
	//	*ManagerMessage_Start
	//	*ManagerMessage_Stop
	Msg           isManagerMessage_Msg `protobuf_oneof:"msg"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ManagerMessage) Reset() {
	*x = ManagerMessage{}
	mi := &file_vpn_vpn_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ManagerMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ManagerMessage) ProtoMessage() {}

func (x *ManagerMessage) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ManagerMessage.ProtoReflect.Descriptor instead.
func (*ManagerMessage) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{1}
}

func (x *ManagerMessage) GetRpc() *RPC {
	if x != nil {
		return x.Rpc
	}
	return nil
}

func (x *ManagerMessage) GetMsg() isManagerMessage_Msg {
	if x != nil {
		return x.Msg
	}
	return nil
}

func (x *ManagerMessage) GetGetPeerUpdate() *GetPeerUpdate {
	if x != nil {
		if x, ok := x.Msg.(*ManagerMessage_GetPeerUpdate); ok {
			return x.GetPeerUpdate
		}
	}
	return nil
}

func (x *ManagerMessage) GetNetworkSettings() *NetworkSettingsResponse {
	if x != nil {
		if x, ok := x.Msg.(*ManagerMessage_NetworkSettings); ok {
			return x.NetworkSettings
		}
	}
	return nil
}

func (x *ManagerMessage) GetStart() *StartRequest {
	if x != nil {
		if x, ok := x.Msg.(*ManagerMessage_Start); ok {
			return x.Start
		}
	}
	return nil
}

func (x *ManagerMessage) GetStop() *StopRequest {
	if x != nil {
		if x, ok := x.Msg.(*ManagerMessage_Stop); ok {
			return x.Stop
		}
	}
	return nil
}

type isManagerMessage_Msg interface {
	isManagerMessage_Msg()
}

type ManagerMessage_GetPeerUpdate struct {
	GetPeerUpdate *GetPeerUpdate `protobuf:"bytes,2,opt,name=get_peer_update,json=getPeerUpdate,proto3,oneof"`
}

type ManagerMessage_NetworkSettings struct {
	NetworkSettings *NetworkSettingsResponse `protobuf:"bytes,3,opt,name=network_settings,json=networkSettings,proto3,oneof"`
}

type ManagerMessage_Start struct {
	Start *StartRequest `protobuf:"bytes,4,opt,name=start,proto3,oneof"`
}

type ManagerMessage_Stop struct {
	Stop *StopRequest `protobuf:"bytes,5,opt,name=stop,proto3,oneof"`
}

func (*ManagerMessage_GetPeerUpdate) isManagerMessage_Msg() {}

func (*ManagerMessage_NetworkSettings) isManagerMessage_Msg() {}

func (*ManagerMessage_Start) isManagerMessage_Msg() {}

func (*ManagerMessage_Stop) isManagerMessage_Msg() {}

// TunnelMessage is a message from the tunnel (to the manager).
type TunnelMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Rpc   *RPC                   `protobuf:"bytes,1,opt,name=rpc,proto3" json:"rpc,omitempty"`
	// Types that are valid to be assigned to Msg:
	//
	//	*TunnelMessage_Log
	//	*TunnelMessage_PeerUpdate
	//	*TunnelMessage_NetworkSettings
	//	*TunnelMessage_Start
	//	*TunnelMessage_Stop
	Msg           isTunnelMessage_Msg `protobuf_oneof:"msg"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TunnelMessage) Reset() {
	*x = TunnelMessage{}
	mi := &file_vpn_vpn_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TunnelMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TunnelMessage) ProtoMessage() {}

func (x *TunnelMessage) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TunnelMessage.ProtoReflect.Descriptor instead.
func (*TunnelMessage) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{2}
}

func (x *TunnelMessage) GetRpc() *RPC {
	if x != nil {
		return x.Rpc
	}
	return nil
}

func (x *TunnelMessage) GetMsg() isTunnelMessage_Msg {
	if x != nil {
		return x.Msg
	}
	return nil
}

func (x *TunnelMessage) GetLog() *Log {
	if x != nil {
		if x, ok := x.Msg.(*TunnelMessage_Log); ok {
			return x.Log
		}
	}
	return nil
}

func (x *TunnelMessage) GetPeerUpdate() *PeerUpdate {
	if x != nil {
		if x, ok := x.Msg.(*TunnelMessage_PeerUpdate); ok {
			return x.PeerUpdate
		}
	}
	return nil
}

func (x *TunnelMessage) GetNetworkSettings() *NetworkSettingsRequest {
	if x != nil {
		if x, ok := x.Msg.(*TunnelMessage_NetworkSettings); ok {
			return x.NetworkSettings
		}
	}
	return nil
}

func (x *TunnelMessage) GetStart() *StartResponse {
	if x != nil {
		if x, ok := x.Msg.(*TunnelMessage_Start); ok {
			return x.Start
		}
	}
	return nil
}

func (x *TunnelMessage) GetStop() *StopResponse {
	if x != nil {
		if x, ok := x.Msg.(*TunnelMessage_Stop); ok {
			return x.Stop
		}
	}
	return nil
}

type isTunnelMessage_Msg interface {
	isTunnelMessage_Msg()
}

type TunnelMessage_Log struct {
	Log *Log `protobuf:"bytes,2,opt,name=log,proto3,oneof"`
}

type TunnelMessage_PeerUpdate struct {
	PeerUpdate *PeerUpdate `protobuf:"bytes,3,opt,name=peer_update,json=peerUpdate,proto3,oneof"`
}

type TunnelMessage_NetworkSettings struct {
	NetworkSettings *NetworkSettingsRequest `protobuf:"bytes,4,opt,name=network_settings,json=networkSettings,proto3,oneof"`
}

type TunnelMessage_Start struct {
	Start *StartResponse `protobuf:"bytes,5,opt,name=start,proto3,oneof"`
}

type TunnelMessage_Stop struct {
	Stop *StopResponse `protobuf:"bytes,6,opt,name=stop,proto3,oneof"`
}

func (*TunnelMessage_Log) isTunnelMessage_Msg() {}

func (*TunnelMessage_PeerUpdate) isTunnelMessage_Msg() {}

func (*TunnelMessage_NetworkSettings) isTunnelMessage_Msg() {}

func (*TunnelMessage_Start) isTunnelMessage_Msg() {}

func (*TunnelMessage_Stop) isTunnelMessage_Msg() {}

// ClientMessage is a message from the client (to the service). Windows only.
type ClientMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Rpc   *RPC                   `protobuf:"bytes,1,opt,name=rpc,proto3" json:"rpc,omitempty"`
	// Types that are valid to be assigned to Msg:
	//
	//	*ClientMessage_Start
	//	*ClientMessage_Stop
	//	*ClientMessage_Status
	Msg           isClientMessage_Msg `protobuf_oneof:"msg"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClientMessage) Reset() {
	*x = ClientMessage{}
	mi := &file_vpn_vpn_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientMessage) ProtoMessage() {}

func (x *ClientMessage) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientMessage.ProtoReflect.Descriptor instead.
func (*ClientMessage) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{3}
}

func (x *ClientMessage) GetRpc() *RPC {
	if x != nil {
		return x.Rpc
	}
	return nil
}

func (x *ClientMessage) GetMsg() isClientMessage_Msg {
	if x != nil {
		return x.Msg
	}
	return nil
}

func (x *ClientMessage) GetStart() *StartRequest {
	if x != nil {
		if x, ok := x.Msg.(*ClientMessage_Start); ok {
			return x.Start
		}
	}
	return nil
}

func (x *ClientMessage) GetStop() *StopRequest {
	if x != nil {
		if x, ok := x.Msg.(*ClientMessage_Stop); ok {
			return x.Stop
		}
	}
	return nil
}

func (x *ClientMessage) GetStatus() *StatusRequest {
	if x != nil {
		if x, ok := x.Msg.(*ClientMessage_Status); ok {
			return x.Status
		}
	}
	return nil
}

type isClientMessage_Msg interface {
	isClientMessage_Msg()
}

type ClientMessage_Start struct {
	Start *StartRequest `protobuf:"bytes,2,opt,name=start,proto3,oneof"`
}

type ClientMessage_Stop struct {
	Stop *StopRequest `protobuf:"bytes,3,opt,name=stop,proto3,oneof"`
}

type ClientMessage_Status struct {
	Status *StatusRequest `protobuf:"bytes,4,opt,name=status,proto3,oneof"`
}

func (*ClientMessage_Start) isClientMessage_Msg() {}

func (*ClientMessage_Stop) isClientMessage_Msg() {}

func (*ClientMessage_Status) isClientMessage_Msg() {}

// ServiceMessage is a message from the service (to the client). Windows only.
type ServiceMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Rpc   *RPC                   `protobuf:"bytes,1,opt,name=rpc,proto3" json:"rpc,omitempty"`
	// Types that are valid to be assigned to Msg:
	//
	//	*ServiceMessage_Start
	//	*ServiceMessage_Stop
	//	*ServiceMessage_Status
	//	*ServiceMessage_StartProgress
	Msg           isServiceMessage_Msg `protobuf_oneof:"msg"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServiceMessage) Reset() {
	*x = ServiceMessage{}
	mi := &file_vpn_vpn_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServiceMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServiceMessage) ProtoMessage() {}

func (x *ServiceMessage) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServiceMessage.ProtoReflect.Descriptor instead.
func (*ServiceMessage) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{4}
}

func (x *ServiceMessage) GetRpc() *RPC {
	if x != nil {
		return x.Rpc
	}
	return nil
}

func (x *ServiceMessage) GetMsg() isServiceMessage_Msg {
	if x != nil {
		return x.Msg
	}
	return nil
}

func (x *ServiceMessage) GetStart() *StartResponse {
	if x != nil {
		if x, ok := x.Msg.(*ServiceMessage_Start); ok {
			return x.Start
		}
	}
	return nil
}

func (x *ServiceMessage) GetStop() *StopResponse {
	if x != nil {
		if x, ok := x.Msg.(*ServiceMessage_Stop); ok {
			return x.Stop
		}
	}
	return nil
}

func (x *ServiceMessage) GetStatus() *Status {
	if x != nil {
		if x, ok := x.Msg.(*ServiceMessage_Status); ok {
			return x.Status
		}
	}
	return nil
}

func (x *ServiceMessage) GetStartProgress() *StartProgress {
	if x != nil {
		if x, ok := x.Msg.(*ServiceMessage_StartProgress); ok {
			return x.StartProgress
		}
	}
	return nil
}

type isServiceMessage_Msg interface {
	isServiceMessage_Msg()
}

type ServiceMessage_Start struct {
	Start *StartResponse `protobuf:"bytes,2,opt,name=start,proto3,oneof"`
}

type ServiceMessage_Stop struct {
	Stop *StopResponse `protobuf:"bytes,3,opt,name=stop,proto3,oneof"`
}

type ServiceMessage_Status struct {
	Status *Status `protobuf:"bytes,4,opt,name=status,proto3,oneof"` // either in reply to a StatusRequest or broadcasted
}

type ServiceMessage_StartProgress struct {
	StartProgress *StartProgress `protobuf:"bytes,5,opt,name=start_progress,json=startProgress,proto3,oneof"` // broadcasted during startup (used exclusively by Windows)
}

func (*ServiceMessage_Start) isServiceMessage_Msg() {}

func (*ServiceMessage_Stop) isServiceMessage_Msg() {}

func (*ServiceMessage_Status) isServiceMessage_Msg() {}

func (*ServiceMessage_StartProgress) isServiceMessage_Msg() {}

// Log is a log message generated by the tunnel.  The manager should log it to the system log. It is
// one-way tunnel -> manager with no response.
type Log struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Level         Log_Level              `protobuf:"varint,1,opt,name=level,proto3,enum=vpn.Log_Level" json:"level,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	LoggerNames   []string               `protobuf:"bytes,3,rep,name=logger_names,json=loggerNames,proto3" json:"logger_names,omitempty"`
	Fields        []*Log_Field           `protobuf:"bytes,4,rep,name=fields,proto3" json:"fields,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Log) Reset() {
	*x = Log{}
	mi := &file_vpn_vpn_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Log) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Log) ProtoMessage() {}

func (x *Log) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Log.ProtoReflect.Descriptor instead.
func (*Log) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{5}
}

func (x *Log) GetLevel() Log_Level {
	if x != nil {
		return x.Level
	}
	return Log_DEBUG
}

func (x *Log) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *Log) GetLoggerNames() []string {
	if x != nil {
		return x.LoggerNames
	}
	return nil
}

func (x *Log) GetFields() []*Log_Field {
	if x != nil {
		return x.Fields
	}
	return nil
}

// GetPeerUpdate asks for a PeerUpdate with a full set of data.
type GetPeerUpdate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPeerUpdate) Reset() {
	*x = GetPeerUpdate{}
	mi := &file_vpn_vpn_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPeerUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPeerUpdate) ProtoMessage() {}

func (x *GetPeerUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPeerUpdate.ProtoReflect.Descriptor instead.
func (*GetPeerUpdate) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{6}
}

// PeerUpdate is an update about workspaces and agents connected via the tunnel. It is generated in
// response to GetPeerUpdate (which dumps the full set). It is also generated on any changes (not in
// response to any request).
type PeerUpdate struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	UpsertedWorkspaces []*Workspace           `protobuf:"bytes,1,rep,name=upserted_workspaces,json=upsertedWorkspaces,proto3" json:"upserted_workspaces,omitempty"`
	UpsertedAgents     []*Agent               `protobuf:"bytes,2,rep,name=upserted_agents,json=upsertedAgents,proto3" json:"upserted_agents,omitempty"`
	DeletedWorkspaces  []*Workspace           `protobuf:"bytes,3,rep,name=deleted_workspaces,json=deletedWorkspaces,proto3" json:"deleted_workspaces,omitempty"`
	DeletedAgents      []*Agent               `protobuf:"bytes,4,rep,name=deleted_agents,json=deletedAgents,proto3" json:"deleted_agents,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *PeerUpdate) Reset() {
	*x = PeerUpdate{}
	mi := &file_vpn_vpn_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PeerUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PeerUpdate) ProtoMessage() {}

func (x *PeerUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PeerUpdate.ProtoReflect.Descriptor instead.
func (*PeerUpdate) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{7}
}

func (x *PeerUpdate) GetUpsertedWorkspaces() []*Workspace {
	if x != nil {
		return x.UpsertedWorkspaces
	}
	return nil
}

func (x *PeerUpdate) GetUpsertedAgents() []*Agent {
	if x != nil {
		return x.UpsertedAgents
	}
	return nil
}

func (x *PeerUpdate) GetDeletedWorkspaces() []*Workspace {
	if x != nil {
		return x.DeletedWorkspaces
	}
	return nil
}

func (x *PeerUpdate) GetDeletedAgents() []*Agent {
	if x != nil {
		return x.DeletedAgents
	}
	return nil
}

type Workspace struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            []byte                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"` // UUID
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Status        Workspace_Status       `protobuf:"varint,3,opt,name=status,proto3,enum=vpn.Workspace_Status" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Workspace) Reset() {
	*x = Workspace{}
	mi := &file_vpn_vpn_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Workspace) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Workspace) ProtoMessage() {}

func (x *Workspace) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Workspace.ProtoReflect.Descriptor instead.
func (*Workspace) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{8}
}

func (x *Workspace) GetId() []byte {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *Workspace) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Workspace) GetStatus() Workspace_Status {
	if x != nil {
		return x.Status
	}
	return Workspace_UNKNOWN
}

type Agent struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Id          []byte                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"` // UUID
	Name        string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	WorkspaceId []byte                 `protobuf:"bytes,3,opt,name=workspace_id,json=workspaceId,proto3" json:"workspace_id,omitempty"` // UUID
	Fqdn        []string               `protobuf:"bytes,4,rep,name=fqdn,proto3" json:"fqdn,omitempty"`
	IpAddrs     []string               `protobuf:"bytes,5,rep,name=ip_addrs,json=ipAddrs,proto3" json:"ip_addrs,omitempty"`
	// last_handshake is the primary indicator of whether we are connected to a peer. Zero value or
	// anything longer than 5 minutes ago means there is a problem.
	LastHandshake *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=last_handshake,json=lastHandshake,proto3" json:"last_handshake,omitempty"`
	// If unset, a successful ping has not yet been made.
	LastPing      *LastPing `protobuf:"bytes,7,opt,name=last_ping,json=lastPing,proto3,oneof" json:"last_ping,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Agent) Reset() {
	*x = Agent{}
	mi := &file_vpn_vpn_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Agent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Agent) ProtoMessage() {}

func (x *Agent) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Agent.ProtoReflect.Descriptor instead.
func (*Agent) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{9}
}

func (x *Agent) GetId() []byte {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *Agent) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Agent) GetWorkspaceId() []byte {
	if x != nil {
		return x.WorkspaceId
	}
	return nil
}

func (x *Agent) GetFqdn() []string {
	if x != nil {
		return x.Fqdn
	}
	return nil
}

func (x *Agent) GetIpAddrs() []string {
	if x != nil {
		return x.IpAddrs
	}
	return nil
}

func (x *Agent) GetLastHandshake() *timestamppb.Timestamp {
	if x != nil {
		return x.LastHandshake
	}
	return nil
}

func (x *Agent) GetLastPing() *LastPing {
	if x != nil {
		return x.LastPing
	}
	return nil
}

type LastPing struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// latency is the RTT of the ping to the agent.
	Latency *durationpb.Duration `protobuf:"bytes,1,opt,name=latency,proto3" json:"latency,omitempty"`
	// did_p2p indicates whether the ping was sent P2P, or over DERP.
	DidP2P bool `protobuf:"varint,2,opt,name=did_p2p,json=didP2p,proto3" json:"did_p2p,omitempty"`
	// preferred_derp is the human readable name of the preferred DERP region,
	// or the region used for the last ping, if it was sent over DERP.
	PreferredDerp string `protobuf:"bytes,3,opt,name=preferred_derp,json=preferredDerp,proto3" json:"preferred_derp,omitempty"`
	// preferred_derp_latency is the last known latency to the preferred DERP
	// region. Unset if the region does not appear in the DERP map.
	PreferredDerpLatency *durationpb.Duration `protobuf:"bytes,4,opt,name=preferred_derp_latency,json=preferredDerpLatency,proto3,oneof" json:"preferred_derp_latency,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *LastPing) Reset() {
	*x = LastPing{}
	mi := &file_vpn_vpn_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LastPing) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LastPing) ProtoMessage() {}

func (x *LastPing) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LastPing.ProtoReflect.Descriptor instead.
func (*LastPing) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{10}
}

func (x *LastPing) GetLatency() *durationpb.Duration {
	if x != nil {
		return x.Latency
	}
	return nil
}

func (x *LastPing) GetDidP2P() bool {
	if x != nil {
		return x.DidP2P
	}
	return false
}

func (x *LastPing) GetPreferredDerp() string {
	if x != nil {
		return x.PreferredDerp
	}
	return ""
}

func (x *LastPing) GetPreferredDerpLatency() *durationpb.Duration {
	if x != nil {
		return x.PreferredDerpLatency
	}
	return nil
}

// NetworkSettingsRequest is based on
// https://developer.apple.com/documentation/networkextension/nepackettunnelnetworksettings for
// macOS.  It is a request/response message with response NetworkSettingsResponse
type NetworkSettingsRequest struct {
	state               protoimpl.MessageState               `protogen:"open.v1"`
	TunnelOverheadBytes uint32                               `protobuf:"varint,1,opt,name=tunnel_overhead_bytes,json=tunnelOverheadBytes,proto3" json:"tunnel_overhead_bytes,omitempty"`
	Mtu                 uint32                               `protobuf:"varint,2,opt,name=mtu,proto3" json:"mtu,omitempty"`
	DnsSettings         *NetworkSettingsRequest_DNSSettings  `protobuf:"bytes,3,opt,name=dns_settings,json=dnsSettings,proto3" json:"dns_settings,omitempty"`
	TunnelRemoteAddress string                               `protobuf:"bytes,4,opt,name=tunnel_remote_address,json=tunnelRemoteAddress,proto3" json:"tunnel_remote_address,omitempty"`
	Ipv4Settings        *NetworkSettingsRequest_IPv4Settings `protobuf:"bytes,5,opt,name=ipv4_settings,json=ipv4Settings,proto3" json:"ipv4_settings,omitempty"`
	Ipv6Settings        *NetworkSettingsRequest_IPv6Settings `protobuf:"bytes,6,opt,name=ipv6_settings,json=ipv6Settings,proto3" json:"ipv6_settings,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *NetworkSettingsRequest) Reset() {
	*x = NetworkSettingsRequest{}
	mi := &file_vpn_vpn_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkSettingsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkSettingsRequest) ProtoMessage() {}

func (x *NetworkSettingsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkSettingsRequest.ProtoReflect.Descriptor instead.
func (*NetworkSettingsRequest) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{11}
}

func (x *NetworkSettingsRequest) GetTunnelOverheadBytes() uint32 {
	if x != nil {
		return x.TunnelOverheadBytes
	}
	return 0
}

func (x *NetworkSettingsRequest) GetMtu() uint32 {
	if x != nil {
		return x.Mtu
	}
	return 0
}

func (x *NetworkSettingsRequest) GetDnsSettings() *NetworkSettingsRequest_DNSSettings {
	if x != nil {
		return x.DnsSettings
	}
	return nil
}

func (x *NetworkSettingsRequest) GetTunnelRemoteAddress() string {
	if x != nil {
		return x.TunnelRemoteAddress
	}
	return ""
}

func (x *NetworkSettingsRequest) GetIpv4Settings() *NetworkSettingsRequest_IPv4Settings {
	if x != nil {
		return x.Ipv4Settings
	}
	return nil
}

func (x *NetworkSettingsRequest) GetIpv6Settings() *NetworkSettingsRequest_IPv6Settings {
	if x != nil {
		return x.Ipv6Settings
	}
	return nil
}

// NetworkSettingsResponse is the response from the manager to the tunnel for a
// NetworkSettingsRequest
type NetworkSettingsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	ErrorMessage  string                 `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkSettingsResponse) Reset() {
	*x = NetworkSettingsResponse{}
	mi := &file_vpn_vpn_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkSettingsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkSettingsResponse) ProtoMessage() {}

func (x *NetworkSettingsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkSettingsResponse.ProtoReflect.Descriptor instead.
func (*NetworkSettingsResponse) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{12}
}

func (x *NetworkSettingsResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *NetworkSettingsResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

// StartRequest is a request from the manager to start the tunnel.  The tunnel replies with a
// StartResponse.
type StartRequest struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	TunnelFileDescriptor int32                  `protobuf:"varint,1,opt,name=tunnel_file_descriptor,json=tunnelFileDescriptor,proto3" json:"tunnel_file_descriptor,omitempty"`
	CoderUrl             string                 `protobuf:"bytes,2,opt,name=coder_url,json=coderUrl,proto3" json:"coder_url,omitempty"`
	ApiToken             string                 `protobuf:"bytes,3,opt,name=api_token,json=apiToken,proto3" json:"api_token,omitempty"`
	Headers              []*StartRequest_Header `protobuf:"bytes,4,rep,name=headers,proto3" json:"headers,omitempty"`
	// Device ID from Coder Desktop
	DeviceId string `protobuf:"bytes,5,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	// Device OS from Coder Desktop
	DeviceOs string `protobuf:"bytes,6,opt,name=device_os,json=deviceOs,proto3" json:"device_os,omitempty"`
	// Coder Desktop version
	CoderDesktopVersion string `protobuf:"bytes,7,opt,name=coder_desktop_version,json=coderDesktopVersion,proto3" json:"coder_desktop_version,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *StartRequest) Reset() {
	*x = StartRequest{}
	mi := &file_vpn_vpn_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartRequest) ProtoMessage() {}

func (x *StartRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartRequest.ProtoReflect.Descriptor instead.
func (*StartRequest) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{13}
}

func (x *StartRequest) GetTunnelFileDescriptor() int32 {
	if x != nil {
		return x.TunnelFileDescriptor
	}
	return 0
}

func (x *StartRequest) GetCoderUrl() string {
	if x != nil {
		return x.CoderUrl
	}
	return ""
}

func (x *StartRequest) GetApiToken() string {
	if x != nil {
		return x.ApiToken
	}
	return ""
}

func (x *StartRequest) GetHeaders() []*StartRequest_Header {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *StartRequest) GetDeviceId() string {
	if x != nil {
		return x.DeviceId
	}
	return ""
}

func (x *StartRequest) GetDeviceOs() string {
	if x != nil {
		return x.DeviceOs
	}
	return ""
}

func (x *StartRequest) GetCoderDesktopVersion() string {
	if x != nil {
		return x.CoderDesktopVersion
	}
	return ""
}

type StartResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	ErrorMessage  string                 `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartResponse) Reset() {
	*x = StartResponse{}
	mi := &file_vpn_vpn_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartResponse) ProtoMessage() {}

func (x *StartResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartResponse.ProtoReflect.Descriptor instead.
func (*StartResponse) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{14}
}

func (x *StartResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *StartResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

type StartProgressDownloadProgress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	BytesWritten  uint64                 `protobuf:"varint,1,opt,name=bytes_written,json=bytesWritten,proto3" json:"bytes_written,omitempty"`
	BytesTotal    *uint64                `protobuf:"varint,2,opt,name=bytes_total,json=bytesTotal,proto3,oneof" json:"bytes_total,omitempty"` // unknown in some situations
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartProgressDownloadProgress) Reset() {
	*x = StartProgressDownloadProgress{}
	mi := &file_vpn_vpn_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartProgressDownloadProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartProgressDownloadProgress) ProtoMessage() {}

func (x *StartProgressDownloadProgress) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartProgressDownloadProgress.ProtoReflect.Descriptor instead.
func (*StartProgressDownloadProgress) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{15}
}

func (x *StartProgressDownloadProgress) GetBytesWritten() uint64 {
	if x != nil {
		return x.BytesWritten
	}
	return 0
}

func (x *StartProgressDownloadProgress) GetBytesTotal() uint64 {
	if x != nil && x.BytesTotal != nil {
		return *x.BytesTotal
	}
	return 0
}

type StartProgress struct {
	state            protoimpl.MessageState         `protogen:"open.v1"`
	Stage            StartProgressStage             `protobuf:"varint,1,opt,name=stage,proto3,enum=vpn.StartProgressStage" json:"stage,omitempty"`
	DownloadProgress *StartProgressDownloadProgress `protobuf:"bytes,2,opt,name=download_progress,json=downloadProgress,proto3,oneof" json:"download_progress,omitempty"` // only set when stage == Downloading
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *StartProgress) Reset() {
	*x = StartProgress{}
	mi := &file_vpn_vpn_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartProgress) ProtoMessage() {}

func (x *StartProgress) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartProgress.ProtoReflect.Descriptor instead.
func (*StartProgress) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{16}
}

func (x *StartProgress) GetStage() StartProgressStage {
	if x != nil {
		return x.Stage
	}
	return StartProgressStage_Initializing
}

func (x *StartProgress) GetDownloadProgress() *StartProgressDownloadProgress {
	if x != nil {
		return x.DownloadProgress
	}
	return nil
}

// StopRequest is a request from the manager to stop the tunnel. The tunnel replies with a
// StopResponse.
type StopRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopRequest) Reset() {
	*x = StopRequest{}
	mi := &file_vpn_vpn_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopRequest) ProtoMessage() {}

func (x *StopRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopRequest.ProtoReflect.Descriptor instead.
func (*StopRequest) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{17}
}

// StopResponse is a response to stopping the tunnel. After sending this response, the tunnel closes
// its side of the bidirectional stream for writing.
type StopResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	ErrorMessage  string                 `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopResponse) Reset() {
	*x = StopResponse{}
	mi := &file_vpn_vpn_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopResponse) ProtoMessage() {}

func (x *StopResponse) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopResponse.ProtoReflect.Descriptor instead.
func (*StopResponse) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{18}
}

func (x *StopResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *StopResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

// StatusRequest is a request to get the status of the tunnel. The manager
// replies with a Status.
type StatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatusRequest) Reset() {
	*x = StatusRequest{}
	mi := &file_vpn_vpn_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatusRequest) ProtoMessage() {}

func (x *StatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatusRequest.ProtoReflect.Descriptor instead.
func (*StatusRequest) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{19}
}

// Status is sent in response to a StatusRequest or broadcasted to all clients
// when the status changes.
type Status struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	Lifecycle    Status_Lifecycle       `protobuf:"varint,1,opt,name=lifecycle,proto3,enum=vpn.Status_Lifecycle" json:"lifecycle,omitempty"`
	ErrorMessage string                 `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// This will be a FULL update with all workspaces and agents, so clients
	// should replace their current peer state. Only the Upserted fields will
	// be populated.
	PeerUpdate    *PeerUpdate `protobuf:"bytes,3,opt,name=peer_update,json=peerUpdate,proto3" json:"peer_update,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Status) Reset() {
	*x = Status{}
	mi := &file_vpn_vpn_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Status) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Status) ProtoMessage() {}

func (x *Status) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Status.ProtoReflect.Descriptor instead.
func (*Status) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{20}
}

func (x *Status) GetLifecycle() Status_Lifecycle {
	if x != nil {
		return x.Lifecycle
	}
	return Status_UNKNOWN
}

func (x *Status) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *Status) GetPeerUpdate() *PeerUpdate {
	if x != nil {
		return x.PeerUpdate
	}
	return nil
}

type Log_Field struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value         string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Log_Field) Reset() {
	*x = Log_Field{}
	mi := &file_vpn_vpn_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Log_Field) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Log_Field) ProtoMessage() {}

func (x *Log_Field) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Log_Field.ProtoReflect.Descriptor instead.
func (*Log_Field) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{5, 0}
}

func (x *Log_Field) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Log_Field) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type NetworkSettingsRequest_DNSSettings struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Servers       []string               `protobuf:"bytes,1,rep,name=servers,proto3" json:"servers,omitempty"`
	SearchDomains []string               `protobuf:"bytes,2,rep,name=search_domains,json=searchDomains,proto3" json:"search_domains,omitempty"`
	// domain_name is the primary domain name of the tunnel
	DomainName   string   `protobuf:"bytes,3,opt,name=domain_name,json=domainName,proto3" json:"domain_name,omitempty"`
	MatchDomains []string `protobuf:"bytes,4,rep,name=match_domains,json=matchDomains,proto3" json:"match_domains,omitempty"`
	// match_domains_no_search specifies if the domains in the matchDomains list should not be
	// appended to the resolver’s list of search domains.
	MatchDomainsNoSearch bool `protobuf:"varint,5,opt,name=match_domains_no_search,json=matchDomainsNoSearch,proto3" json:"match_domains_no_search,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *NetworkSettingsRequest_DNSSettings) Reset() {
	*x = NetworkSettingsRequest_DNSSettings{}
	mi := &file_vpn_vpn_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkSettingsRequest_DNSSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkSettingsRequest_DNSSettings) ProtoMessage() {}

func (x *NetworkSettingsRequest_DNSSettings) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkSettingsRequest_DNSSettings.ProtoReflect.Descriptor instead.
func (*NetworkSettingsRequest_DNSSettings) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{11, 0}
}

func (x *NetworkSettingsRequest_DNSSettings) GetServers() []string {
	if x != nil {
		return x.Servers
	}
	return nil
}

func (x *NetworkSettingsRequest_DNSSettings) GetSearchDomains() []string {
	if x != nil {
		return x.SearchDomains
	}
	return nil
}

func (x *NetworkSettingsRequest_DNSSettings) GetDomainName() string {
	if x != nil {
		return x.DomainName
	}
	return ""
}

func (x *NetworkSettingsRequest_DNSSettings) GetMatchDomains() []string {
	if x != nil {
		return x.MatchDomains
	}
	return nil
}

func (x *NetworkSettingsRequest_DNSSettings) GetMatchDomainsNoSearch() bool {
	if x != nil {
		return x.MatchDomainsNoSearch
	}
	return false
}

type NetworkSettingsRequest_IPv4Settings struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Addrs       []string               `protobuf:"bytes,1,rep,name=addrs,proto3" json:"addrs,omitempty"`
	SubnetMasks []string               `protobuf:"bytes,2,rep,name=subnet_masks,json=subnetMasks,proto3" json:"subnet_masks,omitempty"`
	// router is the next-hop router in dotted-decimal format
	Router         string                                           `protobuf:"bytes,3,opt,name=router,proto3" json:"router,omitempty"`
	IncludedRoutes []*NetworkSettingsRequest_IPv4Settings_IPv4Route `protobuf:"bytes,4,rep,name=included_routes,json=includedRoutes,proto3" json:"included_routes,omitempty"`
	ExcludedRoutes []*NetworkSettingsRequest_IPv4Settings_IPv4Route `protobuf:"bytes,5,rep,name=excluded_routes,json=excludedRoutes,proto3" json:"excluded_routes,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *NetworkSettingsRequest_IPv4Settings) Reset() {
	*x = NetworkSettingsRequest_IPv4Settings{}
	mi := &file_vpn_vpn_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkSettingsRequest_IPv4Settings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkSettingsRequest_IPv4Settings) ProtoMessage() {}

func (x *NetworkSettingsRequest_IPv4Settings) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkSettingsRequest_IPv4Settings.ProtoReflect.Descriptor instead.
func (*NetworkSettingsRequest_IPv4Settings) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{11, 1}
}

func (x *NetworkSettingsRequest_IPv4Settings) GetAddrs() []string {
	if x != nil {
		return x.Addrs
	}
	return nil
}

func (x *NetworkSettingsRequest_IPv4Settings) GetSubnetMasks() []string {
	if x != nil {
		return x.SubnetMasks
	}
	return nil
}

func (x *NetworkSettingsRequest_IPv4Settings) GetRouter() string {
	if x != nil {
		return x.Router
	}
	return ""
}

func (x *NetworkSettingsRequest_IPv4Settings) GetIncludedRoutes() []*NetworkSettingsRequest_IPv4Settings_IPv4Route {
	if x != nil {
		return x.IncludedRoutes
	}
	return nil
}

func (x *NetworkSettingsRequest_IPv4Settings) GetExcludedRoutes() []*NetworkSettingsRequest_IPv4Settings_IPv4Route {
	if x != nil {
		return x.ExcludedRoutes
	}
	return nil
}

type NetworkSettingsRequest_IPv6Settings struct {
	state          protoimpl.MessageState                           `protogen:"open.v1"`
	Addrs          []string                                         `protobuf:"bytes,1,rep,name=addrs,proto3" json:"addrs,omitempty"`
	PrefixLengths  []uint32                                         `protobuf:"varint,2,rep,packed,name=prefix_lengths,json=prefixLengths,proto3" json:"prefix_lengths,omitempty"`
	IncludedRoutes []*NetworkSettingsRequest_IPv6Settings_IPv6Route `protobuf:"bytes,3,rep,name=included_routes,json=includedRoutes,proto3" json:"included_routes,omitempty"`
	ExcludedRoutes []*NetworkSettingsRequest_IPv6Settings_IPv6Route `protobuf:"bytes,4,rep,name=excluded_routes,json=excludedRoutes,proto3" json:"excluded_routes,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *NetworkSettingsRequest_IPv6Settings) Reset() {
	*x = NetworkSettingsRequest_IPv6Settings{}
	mi := &file_vpn_vpn_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkSettingsRequest_IPv6Settings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkSettingsRequest_IPv6Settings) ProtoMessage() {}

func (x *NetworkSettingsRequest_IPv6Settings) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkSettingsRequest_IPv6Settings.ProtoReflect.Descriptor instead.
func (*NetworkSettingsRequest_IPv6Settings) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{11, 2}
}

func (x *NetworkSettingsRequest_IPv6Settings) GetAddrs() []string {
	if x != nil {
		return x.Addrs
	}
	return nil
}

func (x *NetworkSettingsRequest_IPv6Settings) GetPrefixLengths() []uint32 {
	if x != nil {
		return x.PrefixLengths
	}
	return nil
}

func (x *NetworkSettingsRequest_IPv6Settings) GetIncludedRoutes() []*NetworkSettingsRequest_IPv6Settings_IPv6Route {
	if x != nil {
		return x.IncludedRoutes
	}
	return nil
}

func (x *NetworkSettingsRequest_IPv6Settings) GetExcludedRoutes() []*NetworkSettingsRequest_IPv6Settings_IPv6Route {
	if x != nil {
		return x.ExcludedRoutes
	}
	return nil
}

type NetworkSettingsRequest_IPv4Settings_IPv4Route struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Destination string                 `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	Mask        string                 `protobuf:"bytes,2,opt,name=mask,proto3" json:"mask,omitempty"`
	// router is the next-hop router in dotted-decimal format
	Router        string `protobuf:"bytes,3,opt,name=router,proto3" json:"router,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkSettingsRequest_IPv4Settings_IPv4Route) Reset() {
	*x = NetworkSettingsRequest_IPv4Settings_IPv4Route{}
	mi := &file_vpn_vpn_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkSettingsRequest_IPv4Settings_IPv4Route) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkSettingsRequest_IPv4Settings_IPv4Route) ProtoMessage() {}

func (x *NetworkSettingsRequest_IPv4Settings_IPv4Route) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkSettingsRequest_IPv4Settings_IPv4Route.ProtoReflect.Descriptor instead.
func (*NetworkSettingsRequest_IPv4Settings_IPv4Route) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{11, 1, 0}
}

func (x *NetworkSettingsRequest_IPv4Settings_IPv4Route) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (x *NetworkSettingsRequest_IPv4Settings_IPv4Route) GetMask() string {
	if x != nil {
		return x.Mask
	}
	return ""
}

func (x *NetworkSettingsRequest_IPv4Settings_IPv4Route) GetRouter() string {
	if x != nil {
		return x.Router
	}
	return ""
}

type NetworkSettingsRequest_IPv6Settings_IPv6Route struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	Destination  string                 `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	PrefixLength uint32                 `protobuf:"varint,2,opt,name=prefix_length,json=prefixLength,proto3" json:"prefix_length,omitempty"`
	// router is the address of the next-hop
	Router        string `protobuf:"bytes,3,opt,name=router,proto3" json:"router,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkSettingsRequest_IPv6Settings_IPv6Route) Reset() {
	*x = NetworkSettingsRequest_IPv6Settings_IPv6Route{}
	mi := &file_vpn_vpn_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkSettingsRequest_IPv6Settings_IPv6Route) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkSettingsRequest_IPv6Settings_IPv6Route) ProtoMessage() {}

func (x *NetworkSettingsRequest_IPv6Settings_IPv6Route) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkSettingsRequest_IPv6Settings_IPv6Route.ProtoReflect.Descriptor instead.
func (*NetworkSettingsRequest_IPv6Settings_IPv6Route) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{11, 2, 0}
}

func (x *NetworkSettingsRequest_IPv6Settings_IPv6Route) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (x *NetworkSettingsRequest_IPv6Settings_IPv6Route) GetPrefixLength() uint32 {
	if x != nil {
		return x.PrefixLength
	}
	return 0
}

func (x *NetworkSettingsRequest_IPv6Settings_IPv6Route) GetRouter() string {
	if x != nil {
		return x.Router
	}
	return ""
}

// Additional HTTP headers added to all requests
type StartRequest_Header struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value         string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartRequest_Header) Reset() {
	*x = StartRequest_Header{}
	mi := &file_vpn_vpn_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartRequest_Header) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartRequest_Header) ProtoMessage() {}

func (x *StartRequest_Header) ProtoReflect() protoreflect.Message {
	mi := &file_vpn_vpn_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartRequest_Header.ProtoReflect.Descriptor instead.
func (*StartRequest_Header) Descriptor() ([]byte, []int) {
	return file_vpn_vpn_proto_rawDescGZIP(), []int{13, 0}
}

func (x *StartRequest_Header) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *StartRequest_Header) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

var File_vpn_vpn_proto protoreflect.FileDescriptor

const file_vpn_vpn_proto_rawDesc = "" +
	"\n" +
	"\rvpn/vpn.proto\x12\x03vpn\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/duration.proto\"=\n" +
	"\x03RPC\x12\x15\n" +
	"\x06msg_id\x18\x01 \x01(\x04R\x05msgId\x12\x1f\n" +
	"\vresponse_to\x18\x02 \x01(\x04R\n" +
	"responseTo\"\x8f\x02\n" +
	"\x0eManagerMessage\x12\x1a\n" +
	"\x03rpc\x18\x01 \x01(\v2\b.vpn.RPCR\x03rpc\x12<\n" +
	"\x0fget_peer_update\x18\x02 \x01(\v2\x12.vpn.GetPeerUpdateH\x00R\rgetPeerUpdate\x12I\n" +
	"\x10network_settings\x18\x03 \x01(\v2\x1c.vpn.NetworkSettingsResponseH\x00R\x0fnetworkSettings\x12)\n" +
	"\x05start\x18\x04 \x01(\v2\x11.vpn.StartRequestH\x00R\x05start\x12&\n" +
	"\x04stop\x18\x05 \x01(\v2\x10.vpn.StopRequestH\x00R\x04stopB\x05\n" +
	"\x03msg\"\xa3\x02\n" +
	"\rTunnelMessage\x12\x1a\n" +
	"\x03rpc\x18\x01 \x01(\v2\b.vpn.RPCR\x03rpc\x12\x1c\n" +
	"\x03log\x18\x02 \x01(\v2\b.vpn.LogH\x00R\x03log\x122\n" +
	"\vpeer_update\x18\x03 \x01(\v2\x0f.vpn.PeerUpdateH\x00R\n" +
	"peerUpdate\x12H\n" +
	"\x10network_settings\x18\x04 \x01(\v2\x1b.vpn.NetworkSettingsRequestH\x00R\x0fnetworkSettings\x12*\n" +
	"\x05start\x18\x05 \x01(\v2\x12.vpn.StartResponseH\x00R\x05start\x12'\n" +
	"\x04stop\x18\x06 \x01(\v2\x11.vpn.StopResponseH\x00R\x04stopB\x05\n" +
	"\x03msg\"\xb3\x01\n" +
	"\rClientMessage\x12\x1a\n" +
	"\x03rpc\x18\x01 \x01(\v2\b.vpn.RPCR\x03rpc\x12)\n" +
	"\x05start\x18\x02 \x01(\v2\x11.vpn.StartRequestH\x00R\x05start\x12&\n" +
	"\x04stop\x18\x03 \x01(\v2\x10.vpn.StopRequestH\x00R\x04stop\x12,\n" +
	"\x06status\x18\x04 \x01(\v2\x12.vpn.StatusRequestH\x00R\x06statusB\x05\n" +
	"\x03msg\"\xec\x01\n" +
	"\x0eServiceMessage\x12\x1a\n" +
	"\x03rpc\x18\x01 \x01(\v2\b.vpn.RPCR\x03rpc\x12*\n" +
	"\x05start\x18\x02 \x01(\v2\x12.vpn.StartResponseH\x00R\x05start\x12'\n" +
	"\x04stop\x18\x03 \x01(\v2\x11.vpn.StopResponseH\x00R\x04stop\x12%\n" +
	"\x06status\x18\x04 \x01(\v2\v.vpn.StatusH\x00R\x06status\x12;\n" +
	"\x0estart_progress\x18\x05 \x01(\v2\x12.vpn.StartProgressH\x00R\rstartProgressB\x05\n" +
	"\x03msg\"\x8f\x02\n" +
	"\x03Log\x12$\n" +
	"\x05level\x18\x01 \x01(\x0e2\x0e.vpn.Log.LevelR\x05level\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12!\n" +
	"\flogger_names\x18\x03 \x03(\tR\vloggerNames\x12&\n" +
	"\x06fields\x18\x04 \x03(\v2\x0e.vpn.Log.FieldR\x06fields\x1a1\n" +
	"\x05Field\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\"J\n" +
	"\x05Level\x12\t\n" +
	"\x05DEBUG\x10\x00\x12\b\n" +
	"\x04INFO\x10\x01\x12\b\n" +
	"\x04WARN\x10\x02\x12\t\n" +
	"\x05ERROR\x10\x03\x12\f\n" +
	"\bCRITICAL\x10\x04\x12\t\n" +
	"\x05FATAL\x10\x05\"\x0f\n" +
	"\rGetPeerUpdate\"\xf4\x01\n" +
	"\n" +
	"PeerUpdate\x12?\n" +
	"\x13upserted_workspaces\x18\x01 \x03(\v2\x0e.vpn.WorkspaceR\x12upsertedWorkspaces\x123\n" +
	"\x0fupserted_agents\x18\x02 \x03(\v2\n" +
	".vpn.AgentR\x0eupsertedAgents\x12=\n" +
	"\x12deleted_workspaces\x18\x03 \x03(\v2\x0e.vpn.WorkspaceR\x11deletedWorkspaces\x121\n" +
	"\x0edeleted_agents\x18\x04 \x03(\v2\n" +
	".vpn.AgentR\rdeletedAgents\"\xfd\x01\n" +
	"\tWorkspace\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\fR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12-\n" +
	"\x06status\x18\x03 \x01(\x0e2\x15.vpn.Workspace.StatusR\x06status\"\x9c\x01\n" +
	"\x06Status\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\v\n" +
	"\aPENDING\x10\x01\x12\f\n" +
	"\bSTARTING\x10\x02\x12\v\n" +
	"\aRUNNING\x10\x03\x12\f\n" +
	"\bSTOPPING\x10\x04\x12\v\n" +
	"\aSTOPPED\x10\x05\x12\n" +
	"\n" +
	"\x06FAILED\x10\x06\x12\r\n" +
	"\tCANCELING\x10\a\x12\f\n" +
	"\bCANCELED\x10\b\x12\f\n" +
	"\bDELETING\x10\t\x12\v\n" +
	"\aDELETED\x10\n" +
	"\"\xff\x01\n" +
	"\x05Agent\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\fR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12!\n" +
	"\fworkspace_id\x18\x03 \x01(\fR\vworkspaceId\x12\x12\n" +
	"\x04fqdn\x18\x04 \x03(\tR\x04fqdn\x12\x19\n" +
	"\bip_addrs\x18\x05 \x03(\tR\aipAddrs\x12A\n" +
	"\x0elast_handshake\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\rlastHandshake\x12/\n" +
	"\tlast_ping\x18\a \x01(\v2\r.vpn.LastPingH\x00R\blastPing\x88\x01\x01B\f\n" +
	"\n" +
	"_last_ping\"\xf0\x01\n" +
	"\bLastPing\x123\n" +
	"\alatency\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\alatency\x12\x17\n" +
	"\adid_p2p\x18\x02 \x01(\bR\x06didP2p\x12%\n" +
	"\x0epreferred_derp\x18\x03 \x01(\tR\rpreferredDerp\x12T\n" +
	"\x16preferred_derp_latency\x18\x04 \x01(\v2\x19.google.protobuf.DurationH\x00R\x14preferredDerpLatency\x88\x01\x01B\x19\n" +
	"\x17_preferred_derp_latency\"\xb5\n" +
	"\n" +
	"\x16NetworkSettingsRequest\x122\n" +
	"\x15tunnel_overhead_bytes\x18\x01 \x01(\rR\x13tunnelOverheadBytes\x12\x10\n" +
	"\x03mtu\x18\x02 \x01(\rR\x03mtu\x12J\n" +
	"\fdns_settings\x18\x03 \x01(\v2'.vpn.NetworkSettingsRequest.DNSSettingsR\vdnsSettings\x122\n" +
	"\x15tunnel_remote_address\x18\x04 \x01(\tR\x13tunnelRemoteAddress\x12M\n" +
	"\ripv4_settings\x18\x05 \x01(\v2(.vpn.NetworkSettingsRequest.IPv4SettingsR\fipv4Settings\x12M\n" +
	"\ripv6_settings\x18\x06 \x01(\v2(.vpn.NetworkSettingsRequest.IPv6SettingsR\fipv6Settings\x1a\xcb\x01\n" +
	"\vDNSSettings\x12\x18\n" +
	"\aservers\x18\x01 \x03(\tR\aservers\x12%\n" +
	"\x0esearch_domains\x18\x02 \x03(\tR\rsearchDomains\x12\x1f\n" +
	"\vdomain_name\x18\x03 \x01(\tR\n" +
	"domainName\x12#\n" +
	"\rmatch_domains\x18\x04 \x03(\tR\fmatchDomains\x125\n" +
	"\x17match_domains_no_search\x18\x05 \x01(\bR\x14matchDomainsNoSearch\x1a\xf4\x02\n" +
	"\fIPv4Settings\x12\x14\n" +
	"\x05addrs\x18\x01 \x03(\tR\x05addrs\x12!\n" +
	"\fsubnet_masks\x18\x02 \x03(\tR\vsubnetMasks\x12\x16\n" +
	"\x06router\x18\x03 \x01(\tR\x06router\x12[\n" +
	"\x0fincluded_routes\x18\x04 \x03(\v22.vpn.NetworkSettingsRequest.IPv4Settings.IPv4RouteR\x0eincludedRoutes\x12[\n" +
	"\x0fexcluded_routes\x18\x05 \x03(\v22.vpn.NetworkSettingsRequest.IPv4Settings.IPv4RouteR\x0eexcludedRoutes\x1aY\n" +
	"\tIPv4Route\x12 \n" +
	"\vdestination\x18\x01 \x01(\tR\vdestination\x12\x12\n" +
	"\x04mask\x18\x02 \x01(\tR\x04mask\x12\x16\n" +
	"\x06router\x18\x03 \x01(\tR\x06router\x1a\xf1\x02\n" +
	"\fIPv6Settings\x12\x14\n" +
	"\x05addrs\x18\x01 \x03(\tR\x05addrs\x12%\n" +
	"\x0eprefix_lengths\x18\x02 \x03(\rR\rprefixLengths\x12[\n" +
	"\x0fincluded_routes\x18\x03 \x03(\v22.vpn.NetworkSettingsRequest.IPv6Settings.IPv6RouteR\x0eincludedRoutes\x12[\n" +
	"\x0fexcluded_routes\x18\x04 \x03(\v22.vpn.NetworkSettingsRequest.IPv6Settings.IPv6RouteR\x0eexcludedRoutes\x1aj\n" +
	"\tIPv6Route\x12 \n" +
	"\vdestination\x18\x01 \x01(\tR\vdestination\x12#\n" +
	"\rprefix_length\x18\x02 \x01(\rR\fprefixLength\x12\x16\n" +
	"\x06router\x18\x03 \x01(\tR\x06router\"X\n" +
	"\x17NetworkSettingsResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\"\xd4\x02\n" +
	"\fStartRequest\x124\n" +
	"\x16tunnel_file_descriptor\x18\x01 \x01(\x05R\x14tunnelFileDescriptor\x12\x1b\n" +
	"\tcoder_url\x18\x02 \x01(\tR\bcoderUrl\x12\x1b\n" +
	"\tapi_token\x18\x03 \x01(\tR\bapiToken\x122\n" +
	"\aheaders\x18\x04 \x03(\v2\x18.vpn.StartRequest.HeaderR\aheaders\x12\x1b\n" +
	"\tdevice_id\x18\x05 \x01(\tR\bdeviceId\x12\x1b\n" +
	"\tdevice_os\x18\x06 \x01(\tR\bdeviceOs\x122\n" +
	"\x15coder_desktop_version\x18\a \x01(\tR\x13coderDesktopVersion\x1a2\n" +
	"\x06Header\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\"N\n" +
	"\rStartResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\"z\n" +
	"\x1dStartProgressDownloadProgress\x12#\n" +
	"\rbytes_written\x18\x01 \x01(\x04R\fbytesWritten\x12$\n" +
	"\vbytes_total\x18\x02 \x01(\x04H\x00R\n" +
	"bytesTotal\x88\x01\x01B\x0e\n" +
	"\f_bytes_total\"\xaa\x01\n" +
	"\rStartProgress\x12-\n" +
	"\x05stage\x18\x01 \x01(\x0e2\x17.vpn.StartProgressStageR\x05stage\x12T\n" +
	"\x11download_progress\x18\x02 \x01(\v2\".vpn.StartProgressDownloadProgressH\x00R\x10downloadProgress\x88\x01\x01B\x14\n" +
	"\x12_download_progress\"\r\n" +
	"\vStopRequest\"M\n" +
	"\fStopResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\"\x0f\n" +
	"\rStatusRequest\"\xe4\x01\n" +
	"\x06Status\x123\n" +
	"\tlifecycle\x18\x01 \x01(\x0e2\x15.vpn.Status.LifecycleR\tlifecycle\x12#\n" +
	"\rerror_message\x18\x02 \x01(\tR\ferrorMessage\x120\n" +
	"\vpeer_update\x18\x03 \x01(\v2\x0f.vpn.PeerUpdateR\n" +
	"peerUpdate\"N\n" +
	"\tLifecycle\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\f\n" +
	"\bSTARTING\x10\x01\x12\v\n" +
	"\aSTARTED\x10\x02\x12\f\n" +
	"\bSTOPPING\x10\x03\x12\v\n" +
	"\aSTOPPED\x10\x04*G\n" +
	"\x12StartProgressStage\x12\x10\n" +
	"\fInitializing\x10\x00\x12\x0f\n" +
	"\vDownloading\x10\x01\x12\x0e\n" +
	"\n" +
	"Finalizing\x10\x02B9Z\x1dgithub.com/coder/coder/v2/vpn\xaa\x02\x17Coder.Desktop.Vpn.Protob\x06proto3"

var (
	file_vpn_vpn_proto_rawDescOnce sync.Once
	file_vpn_vpn_proto_rawDescData []byte
)

func file_vpn_vpn_proto_rawDescGZIP() []byte {
	file_vpn_vpn_proto_rawDescOnce.Do(func() {
		file_vpn_vpn_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_vpn_vpn_proto_rawDesc), len(file_vpn_vpn_proto_rawDesc)))
	})
	return file_vpn_vpn_proto_rawDescData
}

var file_vpn_vpn_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_vpn_vpn_proto_msgTypes = make([]protoimpl.MessageInfo, 28)
var file_vpn_vpn_proto_goTypes = []any{
	(StartProgressStage)(0),                     // 0: vpn.StartProgressStage
	(Log_Level)(0),                              // 1: vpn.Log.Level
	(Workspace_Status)(0),                       // 2: vpn.Workspace.Status
	(Status_Lifecycle)(0),                       // 3: vpn.Status.Lifecycle
	(*RPC)(nil),                                 // 4: vpn.RPC
	(*ManagerMessage)(nil),                      // 5: vpn.ManagerMessage
	(*TunnelMessage)(nil),                       // 6: vpn.TunnelMessage
	(*ClientMessage)(nil),                       // 7: vpn.ClientMessage
	(*ServiceMessage)(nil),                      // 8: vpn.ServiceMessage
	(*Log)(nil),                                 // 9: vpn.Log
	(*GetPeerUpdate)(nil),                       // 10: vpn.GetPeerUpdate
	(*PeerUpdate)(nil),                          // 11: vpn.PeerUpdate
	(*Workspace)(nil),                           // 12: vpn.Workspace
	(*Agent)(nil),                               // 13: vpn.Agent
	(*LastPing)(nil),                            // 14: vpn.LastPing
	(*NetworkSettingsRequest)(nil),              // 15: vpn.NetworkSettingsRequest
	(*NetworkSettingsResponse)(nil),             // 16: vpn.NetworkSettingsResponse
	(*StartRequest)(nil),                        // 17: vpn.StartRequest
	(*StartResponse)(nil),                       // 18: vpn.StartResponse
	(*StartProgressDownloadProgress)(nil),       // 19: vpn.StartProgressDownloadProgress
	(*StartProgress)(nil),                       // 20: vpn.StartProgress
	(*StopRequest)(nil),                         // 21: vpn.StopRequest
	(*StopResponse)(nil),                        // 22: vpn.StopResponse
	(*StatusRequest)(nil),                       // 23: vpn.StatusRequest
	(*Status)(nil),                              // 24: vpn.Status
	(*Log_Field)(nil),                           // 25: vpn.Log.Field
	(*NetworkSettingsRequest_DNSSettings)(nil),  // 26: vpn.NetworkSettingsRequest.DNSSettings
	(*NetworkSettingsRequest_IPv4Settings)(nil), // 27: vpn.NetworkSettingsRequest.IPv4Settings
	(*NetworkSettingsRequest_IPv6Settings)(nil), // 28: vpn.NetworkSettingsRequest.IPv6Settings
	(*NetworkSettingsRequest_IPv4Settings_IPv4Route)(nil), // 29: vpn.NetworkSettingsRequest.IPv4Settings.IPv4Route
	(*NetworkSettingsRequest_IPv6Settings_IPv6Route)(nil), // 30: vpn.NetworkSettingsRequest.IPv6Settings.IPv6Route
	(*StartRequest_Header)(nil),                           // 31: vpn.StartRequest.Header
	(*timestamppb.Timestamp)(nil),                         // 32: google.protobuf.Timestamp
	(*durationpb.Duration)(nil),                           // 33: google.protobuf.Duration
}
var file_vpn_vpn_proto_depIdxs = []int32{
	4,  // 0: vpn.ManagerMessage.rpc:type_name -> vpn.RPC
	10, // 1: vpn.ManagerMessage.get_peer_update:type_name -> vpn.GetPeerUpdate
	16, // 2: vpn.ManagerMessage.network_settings:type_name -> vpn.NetworkSettingsResponse
	17, // 3: vpn.ManagerMessage.start:type_name -> vpn.StartRequest
	21, // 4: vpn.ManagerMessage.stop:type_name -> vpn.StopRequest
	4,  // 5: vpn.TunnelMessage.rpc:type_name -> vpn.RPC
	9,  // 6: vpn.TunnelMessage.log:type_name -> vpn.Log
	11, // 7: vpn.TunnelMessage.peer_update:type_name -> vpn.PeerUpdate
	15, // 8: vpn.TunnelMessage.network_settings:type_name -> vpn.NetworkSettingsRequest
	18, // 9: vpn.TunnelMessage.start:type_name -> vpn.StartResponse
	22, // 10: vpn.TunnelMessage.stop:type_name -> vpn.StopResponse
	4,  // 11: vpn.ClientMessage.rpc:type_name -> vpn.RPC
	17, // 12: vpn.ClientMessage.start:type_name -> vpn.StartRequest
	21, // 13: vpn.ClientMessage.stop:type_name -> vpn.StopRequest
	23, // 14: vpn.ClientMessage.status:type_name -> vpn.StatusRequest
	4,  // 15: vpn.ServiceMessage.rpc:type_name -> vpn.RPC
	18, // 16: vpn.ServiceMessage.start:type_name -> vpn.StartResponse
	22, // 17: vpn.ServiceMessage.stop:type_name -> vpn.StopResponse
	24, // 18: vpn.ServiceMessage.status:type_name -> vpn.Status
	20, // 19: vpn.ServiceMessage.start_progress:type_name -> vpn.StartProgress
	1,  // 20: vpn.Log.level:type_name -> vpn.Log.Level
	25, // 21: vpn.Log.fields:type_name -> vpn.Log.Field
	12, // 22: vpn.PeerUpdate.upserted_workspaces:type_name -> vpn.Workspace
	13, // 23: vpn.PeerUpdate.upserted_agents:type_name -> vpn.Agent
	12, // 24: vpn.PeerUpdate.deleted_workspaces:type_name -> vpn.Workspace
	13, // 25: vpn.PeerUpdate.deleted_agents:type_name -> vpn.Agent
	2,  // 26: vpn.Workspace.status:type_name -> vpn.Workspace.Status
	32, // 27: vpn.Agent.last_handshake:type_name -> google.protobuf.Timestamp
	14, // 28: vpn.Agent.last_ping:type_name -> vpn.LastPing
	33, // 29: vpn.LastPing.latency:type_name -> google.protobuf.Duration
	33, // 30: vpn.LastPing.preferred_derp_latency:type_name -> google.protobuf.Duration
	26, // 31: vpn.NetworkSettingsRequest.dns_settings:type_name -> vpn.NetworkSettingsRequest.DNSSettings
	27, // 32: vpn.NetworkSettingsRequest.ipv4_settings:type_name -> vpn.NetworkSettingsRequest.IPv4Settings
	28, // 33: vpn.NetworkSettingsRequest.ipv6_settings:type_name -> vpn.NetworkSettingsRequest.IPv6Settings
	31, // 34: vpn.StartRequest.headers:type_name -> vpn.StartRequest.Header
	0,  // 35: vpn.StartProgress.stage:type_name -> vpn.StartProgressStage
	19, // 36: vpn.StartProgress.download_progress:type_name -> vpn.StartProgressDownloadProgress
	3,  // 37: vpn.Status.lifecycle:type_name -> vpn.Status.Lifecycle
	11, // 38: vpn.Status.peer_update:type_name -> vpn.PeerUpdate
	29, // 39: vpn.NetworkSettingsRequest.IPv4Settings.included_routes:type_name -> vpn.NetworkSettingsRequest.IPv4Settings.IPv4Route
	29, // 40: vpn.NetworkSettingsRequest.IPv4Settings.excluded_routes:type_name -> vpn.NetworkSettingsRequest.IPv4Settings.IPv4Route
	30, // 41: vpn.NetworkSettingsRequest.IPv6Settings.included_routes:type_name -> vpn.NetworkSettingsRequest.IPv6Settings.IPv6Route
	30, // 42: vpn.NetworkSettingsRequest.IPv6Settings.excluded_routes:type_name -> vpn.NetworkSettingsRequest.IPv6Settings.IPv6Route
	43, // [43:43] is the sub-list for method output_type
	43, // [43:43] is the sub-list for method input_type
	43, // [43:43] is the sub-list for extension type_name
	43, // [43:43] is the sub-list for extension extendee
	0,  // [0:43] is the sub-list for field type_name
}

func init() { file_vpn_vpn_proto_init() }
func file_vpn_vpn_proto_init() {
	if File_vpn_vpn_proto != nil {
		return
	}
	file_vpn_vpn_proto_msgTypes[1].OneofWrappers = []any{
		(*ManagerMessage_GetPeerUpdate)(nil),
		(*ManagerMessage_NetworkSettings)(nil),
		(*ManagerMessage_Start)(nil),
		(*ManagerMessage_Stop)(nil),
	}
	file_vpn_vpn_proto_msgTypes[2].OneofWrappers = []any{
		(*TunnelMessage_Log)(nil),
		(*TunnelMessage_PeerUpdate)(nil),
		(*TunnelMessage_NetworkSettings)(nil),
		(*TunnelMessage_Start)(nil),
		(*TunnelMessage_Stop)(nil),
	}
	file_vpn_vpn_proto_msgTypes[3].OneofWrappers = []any{
		(*ClientMessage_Start)(nil),
		(*ClientMessage_Stop)(nil),
		(*ClientMessage_Status)(nil),
	}
	file_vpn_vpn_proto_msgTypes[4].OneofWrappers = []any{
		(*ServiceMessage_Start)(nil),
		(*ServiceMessage_Stop)(nil),
		(*ServiceMessage_Status)(nil),
		(*ServiceMessage_StartProgress)(nil),
	}
	file_vpn_vpn_proto_msgTypes[9].OneofWrappers = []any{}
	file_vpn_vpn_proto_msgTypes[10].OneofWrappers = []any{}
	file_vpn_vpn_proto_msgTypes[15].OneofWrappers = []any{}
	file_vpn_vpn_proto_msgTypes[16].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_vpn_vpn_proto_rawDesc), len(file_vpn_vpn_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   28,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_vpn_vpn_proto_goTypes,
		DependencyIndexes: file_vpn_vpn_proto_depIdxs,
		EnumInfos:         file_vpn_vpn_proto_enumTypes,
		MessageInfos:      file_vpn_vpn_proto_msgTypes,
	}.Build()
	File_vpn_vpn_proto = out.File
	file_vpn_vpn_proto_goTypes = nil
	file_vpn_vpn_proto_depIdxs = nil
}
