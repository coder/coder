// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: roles.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const customRoles = `-- name: CustomRoles :many
SELECT
	name, display_name, site_permissions, org_permissions, user_permissions, created_at, updated_at, organization_id, id, is_system, member_permissions
FROM
	custom_roles
WHERE
	true
	-- @lookup_roles will filter for exact (role_name, org_id) pairs
	-- To do this manually in SQL, you can construct an array and cast it:
	-- cast(ARRAY[('customrole','ece79dac-926e-44ca-9790-2ff7c5eb6e0c')] AS name_organization_pair[])
	AND CASE WHEN array_length($1 :: name_organization_pair[], 1) > 0  THEN
		-- Using 'coalesce' to avoid troubles with null literals being an empty string.
		(name, coalesce(organization_id, '00000000-0000-0000-0000-000000000000' ::uuid)) = ANY ($1::name_organization_pair[])
	ELSE true
	END
	-- This allows fetching all roles, or just site wide roles
	AND CASE WHEN $2 :: boolean  THEN
		organization_id IS null
	ELSE true
	END
	-- Allows fetching all roles to a particular organization
	AND CASE WHEN $3 :: uuid != '00000000-0000-0000-0000-000000000000'::uuid  THEN
		organization_id = $3
	ELSE true
	END
	-- Filter system roles. By default, system roles are excluded.
	-- System roles are managed by Coder and should be hidden from user-facing APIs.
	-- The authorization system uses @include_system_roles = true to load them.
	AND CASE WHEN $4 :: boolean THEN
		true
	ELSE
		is_system = false
	END
`

type CustomRolesParams struct {
	LookupRoles        []NameOrganizationPair `db:"lookup_roles" json:"lookup_roles"`
	ExcludeOrgRoles    bool                   `db:"exclude_org_roles" json:"exclude_org_roles"`
	OrganizationID     uuid.UUID              `db:"organization_id" json:"organization_id"`
	IncludeSystemRoles bool                   `db:"include_system_roles" json:"include_system_roles"`
}

func (q *Queries) CustomRoles(ctx context.Context, arg CustomRolesParams) ([]CustomRole, error) {
	rows, err := q.db.QueryContext(ctx, customRoles,
		pq.Array(arg.LookupRoles),
		arg.ExcludeOrgRoles,
		arg.OrganizationID,
		arg.IncludeSystemRoles,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomRole
	for rows.Next() {
		var i CustomRole
		if err := rows.Scan(
			&i.Name,
			&i.DisplayName,
			&i.SitePermissions,
			&i.OrgPermissions,
			&i.UserPermissions,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrganizationID,
			&i.ID,
			&i.IsSystem,
			&i.MemberPermissions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteCustomRole = `-- name: DeleteCustomRole :exec
DELETE FROM
	custom_roles
WHERE
	name = lower($1)
	AND organization_id = $2
	-- Prevents accidental deletion of system roles even if the API
	-- layer check is bypassed due to a bug.
	AND is_system = false
`

type DeleteCustomRoleParams struct {
	Name           string        `db:"name" json:"name"`
	OrganizationID uuid.NullUUID `db:"organization_id" json:"organization_id"`
}

func (q *Queries) DeleteCustomRole(ctx context.Context, arg DeleteCustomRoleParams) error {
	_, err := q.db.ExecContext(ctx, deleteCustomRole, arg.Name, arg.OrganizationID)
	return err
}

const insertCustomRole = `-- name: InsertCustomRole :one
INSERT INTO
	custom_roles (
	name,
	display_name,
	organization_id,
	site_permissions,
	org_permissions,
	user_permissions,
	member_permissions,
	is_system,
	created_at,
	updated_at
)
VALUES (
	-- Always force lowercase names
	lower($1),
	$2,
	$3,
	$4,
	$5,
	$6,
	$7,
	$8,
	now(),
	now()
)
RETURNING name, display_name, site_permissions, org_permissions, user_permissions, created_at, updated_at, organization_id, id, is_system, member_permissions
`

type InsertCustomRoleParams struct {
	Name              string                `db:"name" json:"name"`
	DisplayName       string                `db:"display_name" json:"display_name"`
	OrganizationID    uuid.NullUUID         `db:"organization_id" json:"organization_id"`
	SitePermissions   CustomRolePermissions `db:"site_permissions" json:"site_permissions"`
	OrgPermissions    CustomRolePermissions `db:"org_permissions" json:"org_permissions"`
	UserPermissions   CustomRolePermissions `db:"user_permissions" json:"user_permissions"`
	MemberPermissions CustomRolePermissions `db:"member_permissions" json:"member_permissions"`
	IsSystem          bool                  `db:"is_system" json:"is_system"`
}

func (q *Queries) InsertCustomRole(ctx context.Context, arg InsertCustomRoleParams) (CustomRole, error) {
	row := q.db.QueryRowContext(ctx, insertCustomRole,
		arg.Name,
		arg.DisplayName,
		arg.OrganizationID,
		arg.SitePermissions,
		arg.OrgPermissions,
		arg.UserPermissions,
		arg.MemberPermissions,
		arg.IsSystem,
	)
	var i CustomRole
	err := row.Scan(
		&i.Name,
		&i.DisplayName,
		&i.SitePermissions,
		&i.OrgPermissions,
		&i.UserPermissions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrganizationID,
		&i.ID,
		&i.IsSystem,
		&i.MemberPermissions,
	)
	return i, err
}

const updateCustomRole = `-- name: UpdateCustomRole :one
UPDATE
	custom_roles
SET
	display_name = $1,
	site_permissions = $2,
	org_permissions = $3,
	user_permissions = $4,
	member_permissions = $5,
	updated_at = now()
WHERE
	name = lower($6)
	AND organization_id = $7
RETURNING name, display_name, site_permissions, org_permissions, user_permissions, created_at, updated_at, organization_id, id, is_system, member_permissions
`

type UpdateCustomRoleParams struct {
	DisplayName       string                `db:"display_name" json:"display_name"`
	SitePermissions   CustomRolePermissions `db:"site_permissions" json:"site_permissions"`
	OrgPermissions    CustomRolePermissions `db:"org_permissions" json:"org_permissions"`
	UserPermissions   CustomRolePermissions `db:"user_permissions" json:"user_permissions"`
	MemberPermissions CustomRolePermissions `db:"member_permissions" json:"member_permissions"`
	Name              string                `db:"name" json:"name"`
	OrganizationID    uuid.NullUUID         `db:"organization_id" json:"organization_id"`
}

func (q *Queries) UpdateCustomRole(ctx context.Context, arg UpdateCustomRoleParams) (CustomRole, error) {
	row := q.db.QueryRowContext(ctx, updateCustomRole,
		arg.DisplayName,
		arg.SitePermissions,
		arg.OrgPermissions,
		arg.UserPermissions,
		arg.MemberPermissions,
		arg.Name,
		arg.OrganizationID,
	)
	var i CustomRole
	err := row.Scan(
		&i.Name,
		&i.DisplayName,
		&i.SitePermissions,
		&i.OrgPermissions,
		&i.UserPermissions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrganizationID,
		&i.ID,
		&i.IsSystem,
		&i.MemberPermissions,
	)
	return i, err
}
