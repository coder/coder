// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: workspaceappaudit.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const upsertWorkspaceAppAuditSession = `-- name: UpsertWorkspaceAppAuditSession :one
INSERT INTO
	workspace_app_audit_sessions (
		id,
		agent_id,
		app_id,
		user_id,
		ip,
		user_agent,
		slug_or_port,
		status_code,
		started_at,
		updated_at
	)
VALUES
	(
		$1,
		$2,
		$3,
		$4,
		$5,
		$6,
		$7,
		$8,
		$9,
		$10
	)
ON CONFLICT
	(agent_id, app_id, user_id, ip, user_agent, slug_or_port, status_code)
DO
	UPDATE
	SET
		-- ID is used to know if session was reset on upsert.
		id = CASE
			WHEN workspace_app_audit_sessions.updated_at > NOW() - ($11::bigint || ' ms')::interval
			THEN workspace_app_audit_sessions.id
			ELSE EXCLUDED.id
		END,
		started_at = CASE
			WHEN workspace_app_audit_sessions.updated_at > NOW() - ($11::bigint || ' ms')::interval
			THEN workspace_app_audit_sessions.started_at
			ELSE EXCLUDED.started_at
		END,
		updated_at = EXCLUDED.updated_at
RETURNING
	id = $1 AS new_or_stale
`

type UpsertWorkspaceAppAuditSessionParams struct {
	ID              uuid.UUID `db:"id" json:"id"`
	AgentID         uuid.UUID `db:"agent_id" json:"agent_id"`
	AppID           uuid.UUID `db:"app_id" json:"app_id"`
	UserID          uuid.UUID `db:"user_id" json:"user_id"`
	Ip              string    `db:"ip" json:"ip"`
	UserAgent       string    `db:"user_agent" json:"user_agent"`
	SlugOrPort      string    `db:"slug_or_port" json:"slug_or_port"`
	StatusCode      int32     `db:"status_code" json:"status_code"`
	StartedAt       time.Time `db:"started_at" json:"started_at"`
	UpdatedAt       time.Time `db:"updated_at" json:"updated_at"`
	StaleIntervalMS int64     `db:"stale_interval_ms" json:"stale_interval_ms"`
}

// The returned boolean, new_or_stale, can be used to deduce if a new session
// was started. This means that a new row was inserted (no previous session) or
// the updated_at is older than stale interval.
func (q *Queries) UpsertWorkspaceAppAuditSession(ctx context.Context, arg UpsertWorkspaceAppAuditSessionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, upsertWorkspaceAppAuditSession,
		arg.ID,
		arg.AgentID,
		arg.AppID,
		arg.UserID,
		arg.Ip,
		arg.UserAgent,
		arg.SlugOrPort,
		arg.StatusCode,
		arg.StartedAt,
		arg.UpdatedAt,
		arg.StaleIntervalMS,
	)
	var new_or_stale bool
	err := row.Scan(&new_or_stale)
	return new_or_stale, err
}
