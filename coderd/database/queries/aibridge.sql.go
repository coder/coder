// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: aibridge.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const calculateAIBridgeInterceptionsTelemetrySummary = `-- name: CalculateAIBridgeInterceptionsTelemetrySummary :one
WITH interceptions_in_range AS (
    -- Get all matching interceptions in the given timeframe.
    SELECT
        id,
        initiator_id,
        (ended_at - started_at) AS duration
    FROM
        aibridge_interceptions
    WHERE
        provider = $1::text
        AND model = $2::text
        -- TODO: use the client value once we have it (see https://github.com/coder/aibridge/issues/31)
        AND 'unknown' = $3::text
        AND ended_at IS NOT NULL -- incomplete interceptions are not included in summaries
        AND ended_at >= $4::timestamptz
        AND ended_at < $5::timestamptz
),
interception_counts AS (
    SELECT
        COUNT(id) AS interception_count,
        COUNT(DISTINCT initiator_id) AS unique_initiator_count
    FROM
        interceptions_in_range
),
duration_percentiles AS (
    SELECT
        (COALESCE(PERCENTILE_CONT(0.50) WITHIN GROUP (ORDER BY EXTRACT(EPOCH FROM duration)), 0) * 1000)::bigint AS interception_duration_p50_millis,
        (COALESCE(PERCENTILE_CONT(0.90) WITHIN GROUP (ORDER BY EXTRACT(EPOCH FROM duration)), 0) * 1000)::bigint AS interception_duration_p90_millis,
        (COALESCE(PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY EXTRACT(EPOCH FROM duration)), 0) * 1000)::bigint AS interception_duration_p95_millis,
        (COALESCE(PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY EXTRACT(EPOCH FROM duration)), 0) * 1000)::bigint AS interception_duration_p99_millis
    FROM
        interceptions_in_range
),
token_aggregates AS (
    SELECT
        COALESCE(SUM(tu.input_tokens), 0) AS token_count_input,
        COALESCE(SUM(tu.output_tokens), 0) AS token_count_output,
        -- Cached tokens are stored in metadata JSON, extract if available.
        -- Read tokens may be stored in:
        -- - cache_read_input (Anthropic)
        -- - prompt_cached (OpenAI)
        COALESCE(SUM(
            COALESCE((tu.metadata->>'cache_read_input')::bigint, 0) +
            COALESCE((tu.metadata->>'prompt_cached')::bigint, 0)
        ), 0) AS token_count_cached_read,
        -- Written tokens may be stored in:
        -- - cache_creation_input (Anthropic)
        -- Note that cache_ephemeral_5m_input and cache_ephemeral_1h_input on
        -- Anthropic are included in the cache_creation_input field.
        COALESCE(SUM(
            COALESCE((tu.metadata->>'cache_creation_input')::bigint, 0)
        ), 0) AS token_count_cached_written,
        COUNT(tu.id) AS token_usages_count
    FROM
        interceptions_in_range i
    LEFT JOIN
        aibridge_token_usages tu ON i.id = tu.interception_id
),
prompt_aggregates AS (
    SELECT
        COUNT(up.id) AS user_prompts_count
    FROM
        interceptions_in_range i
    LEFT JOIN
        aibridge_user_prompts up ON i.id = up.interception_id
),
tool_aggregates AS (
    SELECT
        COUNT(tu.id) FILTER (WHERE tu.injected = true) AS tool_calls_count_injected,
        COUNT(tu.id) FILTER (WHERE tu.injected = false) AS tool_calls_count_non_injected,
        COUNT(tu.id) FILTER (WHERE tu.injected = true AND tu.invocation_error IS NOT NULL) AS injected_tool_call_error_count
    FROM
        interceptions_in_range i
    LEFT JOIN
        aibridge_tool_usages tu ON i.id = tu.interception_id
)
SELECT
    ic.interception_count::bigint AS interception_count,
    dp.interception_duration_p50_millis::bigint AS interception_duration_p50_millis,
    dp.interception_duration_p90_millis::bigint AS interception_duration_p90_millis,
    dp.interception_duration_p95_millis::bigint AS interception_duration_p95_millis,
    dp.interception_duration_p99_millis::bigint AS interception_duration_p99_millis,
    ic.unique_initiator_count::bigint AS unique_initiator_count,
    pa.user_prompts_count::bigint AS user_prompts_count,
    tok_agg.token_usages_count::bigint AS token_usages_count,
    tok_agg.token_count_input::bigint AS token_count_input,
    tok_agg.token_count_output::bigint AS token_count_output,
    tok_agg.token_count_cached_read::bigint AS token_count_cached_read,
    tok_agg.token_count_cached_written::bigint AS token_count_cached_written,
    tool_agg.tool_calls_count_injected::bigint AS tool_calls_count_injected,
    tool_agg.tool_calls_count_non_injected::bigint AS tool_calls_count_non_injected,
    tool_agg.injected_tool_call_error_count::bigint AS injected_tool_call_error_count
FROM
    interception_counts ic,
    duration_percentiles dp,
    token_aggregates tok_agg,
    prompt_aggregates pa,
    tool_aggregates tool_agg
`

type CalculateAIBridgeInterceptionsTelemetrySummaryParams struct {
	Provider      string    `db:"provider" json:"provider"`
	Model         string    `db:"model" json:"model"`
	Client        string    `db:"client" json:"client"`
	EndedAtAfter  time.Time `db:"ended_at_after" json:"ended_at_after"`
	EndedAtBefore time.Time `db:"ended_at_before" json:"ended_at_before"`
}

type CalculateAIBridgeInterceptionsTelemetrySummaryRow struct {
	InterceptionCount             int64 `db:"interception_count" json:"interception_count"`
	InterceptionDurationP50Millis int64 `db:"interception_duration_p50_millis" json:"interception_duration_p50_millis"`
	InterceptionDurationP90Millis int64 `db:"interception_duration_p90_millis" json:"interception_duration_p90_millis"`
	InterceptionDurationP95Millis int64 `db:"interception_duration_p95_millis" json:"interception_duration_p95_millis"`
	InterceptionDurationP99Millis int64 `db:"interception_duration_p99_millis" json:"interception_duration_p99_millis"`
	UniqueInitiatorCount          int64 `db:"unique_initiator_count" json:"unique_initiator_count"`
	UserPromptsCount              int64 `db:"user_prompts_count" json:"user_prompts_count"`
	TokenUsagesCount              int64 `db:"token_usages_count" json:"token_usages_count"`
	TokenCountInput               int64 `db:"token_count_input" json:"token_count_input"`
	TokenCountOutput              int64 `db:"token_count_output" json:"token_count_output"`
	TokenCountCachedRead          int64 `db:"token_count_cached_read" json:"token_count_cached_read"`
	TokenCountCachedWritten       int64 `db:"token_count_cached_written" json:"token_count_cached_written"`
	ToolCallsCountInjected        int64 `db:"tool_calls_count_injected" json:"tool_calls_count_injected"`
	ToolCallsCountNonInjected     int64 `db:"tool_calls_count_non_injected" json:"tool_calls_count_non_injected"`
	InjectedToolCallErrorCount    int64 `db:"injected_tool_call_error_count" json:"injected_tool_call_error_count"`
}

// Calculates the telemetry summary for a given provider, model, and client
// combination for telemetry reporting.
func (q *Queries) CalculateAIBridgeInterceptionsTelemetrySummary(ctx context.Context, arg CalculateAIBridgeInterceptionsTelemetrySummaryParams) (CalculateAIBridgeInterceptionsTelemetrySummaryRow, error) {
	row := q.db.QueryRowContext(ctx, calculateAIBridgeInterceptionsTelemetrySummary,
		arg.Provider,
		arg.Model,
		arg.Client,
		arg.EndedAtAfter,
		arg.EndedAtBefore,
	)
	var i CalculateAIBridgeInterceptionsTelemetrySummaryRow
	err := row.Scan(
		&i.InterceptionCount,
		&i.InterceptionDurationP50Millis,
		&i.InterceptionDurationP90Millis,
		&i.InterceptionDurationP95Millis,
		&i.InterceptionDurationP99Millis,
		&i.UniqueInitiatorCount,
		&i.UserPromptsCount,
		&i.TokenUsagesCount,
		&i.TokenCountInput,
		&i.TokenCountOutput,
		&i.TokenCountCachedRead,
		&i.TokenCountCachedWritten,
		&i.ToolCallsCountInjected,
		&i.ToolCallsCountNonInjected,
		&i.InjectedToolCallErrorCount,
	)
	return i, err
}

const countAIBridgeInterceptions = `-- name: CountAIBridgeInterceptions :one
SELECT
	COUNT(*)
FROM
	aibridge_interceptions
WHERE
	-- Remove inflight interceptions (ones which lack an ended_at value).
	aibridge_interceptions.ended_at IS NOT NULL
	-- Filter by time frame
	AND CASE
		WHEN $1::timestamptz != '0001-01-01 00:00:00+00'::timestamptz THEN aibridge_interceptions.started_at >= $1::timestamptz
		ELSE true
	END
	AND CASE
		WHEN $2::timestamptz != '0001-01-01 00:00:00+00'::timestamptz THEN aibridge_interceptions.started_at <= $2::timestamptz
		ELSE true
	END
	-- Filter initiator_id
	AND CASE
		WHEN $3::uuid != '00000000-0000-0000-0000-000000000000'::uuid THEN aibridge_interceptions.initiator_id = $3::uuid
		ELSE true
	END
	-- Filter provider
	AND CASE
		WHEN $4::text != '' THEN aibridge_interceptions.provider = $4::text
		ELSE true
	END
	-- Filter model
	AND CASE
		WHEN $5::text != '' THEN aibridge_interceptions.model = $5::text
		ELSE true
	END
	-- Authorize Filter clause will be injected below in ListAuthorizedAIBridgeInterceptions
	-- @authorize_filter
`

type CountAIBridgeInterceptionsParams struct {
	StartedAfter  time.Time `db:"started_after" json:"started_after"`
	StartedBefore time.Time `db:"started_before" json:"started_before"`
	InitiatorID   uuid.UUID `db:"initiator_id" json:"initiator_id"`
	Provider      string    `db:"provider" json:"provider"`
	Model         string    `db:"model" json:"model"`
}

func (q *Queries) CountAIBridgeInterceptions(ctx context.Context, arg CountAIBridgeInterceptionsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAIBridgeInterceptions,
		arg.StartedAfter,
		arg.StartedBefore,
		arg.InitiatorID,
		arg.Provider,
		arg.Model,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOldAIBridgeRecords = `-- name: DeleteOldAIBridgeRecords :one
WITH
  -- We don't have FK relationships between the dependent tables and aibridge_interceptions, so we can't rely on DELETE CASCADE.
  to_delete AS (
    SELECT id FROM aibridge_interceptions
    WHERE started_at < $1::timestamp with time zone
  ),
  -- CTEs are executed in order.
  tool_usages AS (
    DELETE FROM aibridge_tool_usages
    WHERE interception_id IN (SELECT id FROM to_delete)
    RETURNING 1
  ),
  token_usages AS (
    DELETE FROM aibridge_token_usages
    WHERE interception_id IN (SELECT id FROM to_delete)
    RETURNING 1
  ),
  user_prompts AS (
    DELETE FROM aibridge_user_prompts
    WHERE interception_id IN (SELECT id FROM to_delete)
    RETURNING 1
  ),
  interceptions AS (
    DELETE FROM aibridge_interceptions
    WHERE id IN (SELECT id FROM to_delete)
    RETURNING 1
  )
SELECT (
  (SELECT COUNT(*) FROM tool_usages) +
  (SELECT COUNT(*) FROM token_usages) +
  (SELECT COUNT(*) FROM user_prompts) +
  (SELECT COUNT(*) FROM interceptions)
)::bigint as total_deleted
`

// Cumulative count.
func (q *Queries) DeleteOldAIBridgeRecords(ctx context.Context, beforeTime time.Time) (int64, error) {
	row := q.db.QueryRowContext(ctx, deleteOldAIBridgeRecords, beforeTime)
	var total_deleted int64
	err := row.Scan(&total_deleted)
	return total_deleted, err
}

const getAIBridgeInterceptionByID = `-- name: GetAIBridgeInterceptionByID :one
SELECT
	id, initiator_id, provider, model, started_at, metadata, ended_at, api_key_id
FROM
	aibridge_interceptions
WHERE
	id = $1::uuid
`

func (q *Queries) GetAIBridgeInterceptionByID(ctx context.Context, id uuid.UUID) (AIBridgeInterception, error) {
	row := q.db.QueryRowContext(ctx, getAIBridgeInterceptionByID, id)
	var i AIBridgeInterception
	err := row.Scan(
		&i.ID,
		&i.InitiatorID,
		&i.Provider,
		&i.Model,
		&i.StartedAt,
		&i.Metadata,
		&i.EndedAt,
		&i.APIKeyID,
	)
	return i, err
}

const getAIBridgeInterceptions = `-- name: GetAIBridgeInterceptions :many
SELECT
	id, initiator_id, provider, model, started_at, metadata, ended_at, api_key_id
FROM
	aibridge_interceptions
`

func (q *Queries) GetAIBridgeInterceptions(ctx context.Context) ([]AIBridgeInterception, error) {
	rows, err := q.db.QueryContext(ctx, getAIBridgeInterceptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AIBridgeInterception
	for rows.Next() {
		var i AIBridgeInterception
		if err := rows.Scan(
			&i.ID,
			&i.InitiatorID,
			&i.Provider,
			&i.Model,
			&i.StartedAt,
			&i.Metadata,
			&i.EndedAt,
			&i.APIKeyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAIBridgeTokenUsagesByInterceptionID = `-- name: GetAIBridgeTokenUsagesByInterceptionID :many
SELECT
	id, interception_id, provider_response_id, input_tokens, output_tokens, metadata, created_at
FROM
	aibridge_token_usages WHERE interception_id = $1::uuid
ORDER BY
	created_at ASC,
	id ASC
`

func (q *Queries) GetAIBridgeTokenUsagesByInterceptionID(ctx context.Context, interceptionID uuid.UUID) ([]AIBridgeTokenUsage, error) {
	rows, err := q.db.QueryContext(ctx, getAIBridgeTokenUsagesByInterceptionID, interceptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AIBridgeTokenUsage
	for rows.Next() {
		var i AIBridgeTokenUsage
		if err := rows.Scan(
			&i.ID,
			&i.InterceptionID,
			&i.ProviderResponseID,
			&i.InputTokens,
			&i.OutputTokens,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAIBridgeToolUsagesByInterceptionID = `-- name: GetAIBridgeToolUsagesByInterceptionID :many
SELECT
	id, interception_id, provider_response_id, server_url, tool, input, injected, invocation_error, metadata, created_at
FROM
	aibridge_tool_usages
WHERE
	interception_id = $1::uuid
ORDER BY
	created_at ASC,
	id ASC
`

func (q *Queries) GetAIBridgeToolUsagesByInterceptionID(ctx context.Context, interceptionID uuid.UUID) ([]AIBridgeToolUsage, error) {
	rows, err := q.db.QueryContext(ctx, getAIBridgeToolUsagesByInterceptionID, interceptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AIBridgeToolUsage
	for rows.Next() {
		var i AIBridgeToolUsage
		if err := rows.Scan(
			&i.ID,
			&i.InterceptionID,
			&i.ProviderResponseID,
			&i.ServerUrl,
			&i.Tool,
			&i.Input,
			&i.Injected,
			&i.InvocationError,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAIBridgeUserPromptsByInterceptionID = `-- name: GetAIBridgeUserPromptsByInterceptionID :many
SELECT
	id, interception_id, provider_response_id, prompt, metadata, created_at
FROM
	aibridge_user_prompts
WHERE
	interception_id = $1::uuid
ORDER BY
	created_at ASC,
	id ASC
`

func (q *Queries) GetAIBridgeUserPromptsByInterceptionID(ctx context.Context, interceptionID uuid.UUID) ([]AIBridgeUserPrompt, error) {
	rows, err := q.db.QueryContext(ctx, getAIBridgeUserPromptsByInterceptionID, interceptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AIBridgeUserPrompt
	for rows.Next() {
		var i AIBridgeUserPrompt
		if err := rows.Scan(
			&i.ID,
			&i.InterceptionID,
			&i.ProviderResponseID,
			&i.Prompt,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAIBridgeInterception = `-- name: InsertAIBridgeInterception :one
INSERT INTO aibridge_interceptions (
	id, api_key_id, initiator_id, provider, model, metadata, started_at
) VALUES (
	$1, $2, $3, $4, $5, COALESCE($6::jsonb, '{}'::jsonb), $7
)
RETURNING id, initiator_id, provider, model, started_at, metadata, ended_at, api_key_id
`

type InsertAIBridgeInterceptionParams struct {
	ID          uuid.UUID       `db:"id" json:"id"`
	APIKeyID    sql.NullString  `db:"api_key_id" json:"api_key_id"`
	InitiatorID uuid.UUID       `db:"initiator_id" json:"initiator_id"`
	Provider    string          `db:"provider" json:"provider"`
	Model       string          `db:"model" json:"model"`
	Metadata    json.RawMessage `db:"metadata" json:"metadata"`
	StartedAt   time.Time       `db:"started_at" json:"started_at"`
}

func (q *Queries) InsertAIBridgeInterception(ctx context.Context, arg InsertAIBridgeInterceptionParams) (AIBridgeInterception, error) {
	row := q.db.QueryRowContext(ctx, insertAIBridgeInterception,
		arg.ID,
		arg.APIKeyID,
		arg.InitiatorID,
		arg.Provider,
		arg.Model,
		arg.Metadata,
		arg.StartedAt,
	)
	var i AIBridgeInterception
	err := row.Scan(
		&i.ID,
		&i.InitiatorID,
		&i.Provider,
		&i.Model,
		&i.StartedAt,
		&i.Metadata,
		&i.EndedAt,
		&i.APIKeyID,
	)
	return i, err
}

const insertAIBridgeTokenUsage = `-- name: InsertAIBridgeTokenUsage :one
INSERT INTO aibridge_token_usages (
  id, interception_id, provider_response_id, input_tokens, output_tokens, metadata, created_at
) VALUES (
  $1, $2, $3, $4, $5, COALESCE($6::jsonb, '{}'::jsonb), $7
)
RETURNING id, interception_id, provider_response_id, input_tokens, output_tokens, metadata, created_at
`

type InsertAIBridgeTokenUsageParams struct {
	ID                 uuid.UUID       `db:"id" json:"id"`
	InterceptionID     uuid.UUID       `db:"interception_id" json:"interception_id"`
	ProviderResponseID string          `db:"provider_response_id" json:"provider_response_id"`
	InputTokens        int64           `db:"input_tokens" json:"input_tokens"`
	OutputTokens       int64           `db:"output_tokens" json:"output_tokens"`
	Metadata           json.RawMessage `db:"metadata" json:"metadata"`
	CreatedAt          time.Time       `db:"created_at" json:"created_at"`
}

func (q *Queries) InsertAIBridgeTokenUsage(ctx context.Context, arg InsertAIBridgeTokenUsageParams) (AIBridgeTokenUsage, error) {
	row := q.db.QueryRowContext(ctx, insertAIBridgeTokenUsage,
		arg.ID,
		arg.InterceptionID,
		arg.ProviderResponseID,
		arg.InputTokens,
		arg.OutputTokens,
		arg.Metadata,
		arg.CreatedAt,
	)
	var i AIBridgeTokenUsage
	err := row.Scan(
		&i.ID,
		&i.InterceptionID,
		&i.ProviderResponseID,
		&i.InputTokens,
		&i.OutputTokens,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const insertAIBridgeToolUsage = `-- name: InsertAIBridgeToolUsage :one
INSERT INTO aibridge_tool_usages (
  id, interception_id, provider_response_id, tool, server_url, input, injected, invocation_error, metadata, created_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, COALESCE($9::jsonb, '{}'::jsonb), $10
)
RETURNING id, interception_id, provider_response_id, server_url, tool, input, injected, invocation_error, metadata, created_at
`

type InsertAIBridgeToolUsageParams struct {
	ID                 uuid.UUID       `db:"id" json:"id"`
	InterceptionID     uuid.UUID       `db:"interception_id" json:"interception_id"`
	ProviderResponseID string          `db:"provider_response_id" json:"provider_response_id"`
	Tool               string          `db:"tool" json:"tool"`
	ServerUrl          sql.NullString  `db:"server_url" json:"server_url"`
	Input              string          `db:"input" json:"input"`
	Injected           bool            `db:"injected" json:"injected"`
	InvocationError    sql.NullString  `db:"invocation_error" json:"invocation_error"`
	Metadata           json.RawMessage `db:"metadata" json:"metadata"`
	CreatedAt          time.Time       `db:"created_at" json:"created_at"`
}

func (q *Queries) InsertAIBridgeToolUsage(ctx context.Context, arg InsertAIBridgeToolUsageParams) (AIBridgeToolUsage, error) {
	row := q.db.QueryRowContext(ctx, insertAIBridgeToolUsage,
		arg.ID,
		arg.InterceptionID,
		arg.ProviderResponseID,
		arg.Tool,
		arg.ServerUrl,
		arg.Input,
		arg.Injected,
		arg.InvocationError,
		arg.Metadata,
		arg.CreatedAt,
	)
	var i AIBridgeToolUsage
	err := row.Scan(
		&i.ID,
		&i.InterceptionID,
		&i.ProviderResponseID,
		&i.ServerUrl,
		&i.Tool,
		&i.Input,
		&i.Injected,
		&i.InvocationError,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const insertAIBridgeUserPrompt = `-- name: InsertAIBridgeUserPrompt :one
INSERT INTO aibridge_user_prompts (
  id, interception_id, provider_response_id, prompt, metadata, created_at
) VALUES (
  $1, $2, $3, $4, COALESCE($5::jsonb, '{}'::jsonb), $6
)
RETURNING id, interception_id, provider_response_id, prompt, metadata, created_at
`

type InsertAIBridgeUserPromptParams struct {
	ID                 uuid.UUID       `db:"id" json:"id"`
	InterceptionID     uuid.UUID       `db:"interception_id" json:"interception_id"`
	ProviderResponseID string          `db:"provider_response_id" json:"provider_response_id"`
	Prompt             string          `db:"prompt" json:"prompt"`
	Metadata           json.RawMessage `db:"metadata" json:"metadata"`
	CreatedAt          time.Time       `db:"created_at" json:"created_at"`
}

func (q *Queries) InsertAIBridgeUserPrompt(ctx context.Context, arg InsertAIBridgeUserPromptParams) (AIBridgeUserPrompt, error) {
	row := q.db.QueryRowContext(ctx, insertAIBridgeUserPrompt,
		arg.ID,
		arg.InterceptionID,
		arg.ProviderResponseID,
		arg.Prompt,
		arg.Metadata,
		arg.CreatedAt,
	)
	var i AIBridgeUserPrompt
	err := row.Scan(
		&i.ID,
		&i.InterceptionID,
		&i.ProviderResponseID,
		&i.Prompt,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const listAIBridgeInterceptions = `-- name: ListAIBridgeInterceptions :many
SELECT
	aibridge_interceptions.id, aibridge_interceptions.initiator_id, aibridge_interceptions.provider, aibridge_interceptions.model, aibridge_interceptions.started_at, aibridge_interceptions.metadata, aibridge_interceptions.ended_at, aibridge_interceptions.api_key_id,
	visible_users.id, visible_users.username, visible_users.name, visible_users.avatar_url
FROM
	aibridge_interceptions
JOIN
	visible_users ON visible_users.id = aibridge_interceptions.initiator_id
WHERE
	-- Remove inflight interceptions (ones which lack an ended_at value).
	aibridge_interceptions.ended_at IS NOT NULL
	-- Filter by time frame
	AND CASE
		WHEN $1::timestamptz != '0001-01-01 00:00:00+00'::timestamptz THEN aibridge_interceptions.started_at >= $1::timestamptz
		ELSE true
	END
	AND CASE
		WHEN $2::timestamptz != '0001-01-01 00:00:00+00'::timestamptz THEN aibridge_interceptions.started_at <= $2::timestamptz
		ELSE true
	END
	-- Filter initiator_id
	AND CASE
		WHEN $3::uuid != '00000000-0000-0000-0000-000000000000'::uuid THEN aibridge_interceptions.initiator_id = $3::uuid
		ELSE true
	END
	-- Filter provider
	AND CASE
		WHEN $4::text != '' THEN aibridge_interceptions.provider = $4::text
		ELSE true
	END
	-- Filter model
	AND CASE
		WHEN $5::text != '' THEN aibridge_interceptions.model = $5::text
		ELSE true
	END
	-- Cursor pagination
	AND CASE
		WHEN $6::uuid != '00000000-0000-0000-0000-000000000000'::uuid THEN (
			-- The pagination cursor is the last ID of the previous page.
			-- The query is ordered by the started_at field, so select all
			-- rows before the cursor and before the after_id UUID.
			-- This uses a less than operator because we're sorting DESC. The
			-- "after_id" terminology comes from our pagination parser in
			-- coderd.
			(aibridge_interceptions.started_at, aibridge_interceptions.id) < (
				(SELECT started_at FROM aibridge_interceptions WHERE id = $6),
				$6::uuid
			)
		)
		ELSE true
	END
	-- Authorize Filter clause will be injected below in ListAuthorizedAIBridgeInterceptions
	-- @authorize_filter
ORDER BY
	aibridge_interceptions.started_at DESC,
	aibridge_interceptions.id DESC
LIMIT COALESCE(NULLIF($8::integer, 0), 100)
OFFSET $7
`

type ListAIBridgeInterceptionsParams struct {
	StartedAfter  time.Time `db:"started_after" json:"started_after"`
	StartedBefore time.Time `db:"started_before" json:"started_before"`
	InitiatorID   uuid.UUID `db:"initiator_id" json:"initiator_id"`
	Provider      string    `db:"provider" json:"provider"`
	Model         string    `db:"model" json:"model"`
	AfterID       uuid.UUID `db:"after_id" json:"after_id"`
	Offset        int32     `db:"offset_" json:"offset_"`
	Limit         int32     `db:"limit_" json:"limit_"`
}

type ListAIBridgeInterceptionsRow struct {
	AIBridgeInterception AIBridgeInterception `db:"aibridge_interception" json:"aibridge_interception"`
	VisibleUser          VisibleUser          `db:"visible_user" json:"visible_user"`
}

func (q *Queries) ListAIBridgeInterceptions(ctx context.Context, arg ListAIBridgeInterceptionsParams) ([]ListAIBridgeInterceptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAIBridgeInterceptions,
		arg.StartedAfter,
		arg.StartedBefore,
		arg.InitiatorID,
		arg.Provider,
		arg.Model,
		arg.AfterID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAIBridgeInterceptionsRow
	for rows.Next() {
		var i ListAIBridgeInterceptionsRow
		if err := rows.Scan(
			&i.AIBridgeInterception.ID,
			&i.AIBridgeInterception.InitiatorID,
			&i.AIBridgeInterception.Provider,
			&i.AIBridgeInterception.Model,
			&i.AIBridgeInterception.StartedAt,
			&i.AIBridgeInterception.Metadata,
			&i.AIBridgeInterception.EndedAt,
			&i.AIBridgeInterception.APIKeyID,
			&i.VisibleUser.ID,
			&i.VisibleUser.Username,
			&i.VisibleUser.Name,
			&i.VisibleUser.AvatarURL,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAIBridgeInterceptionsTelemetrySummaries = `-- name: ListAIBridgeInterceptionsTelemetrySummaries :many
SELECT
    DISTINCT ON (provider, model, client)
    provider,
    model,
    -- TODO: use the client value once we have it (see https://github.com/coder/aibridge/issues/31)
    'unknown' AS client
FROM
    aibridge_interceptions
WHERE
    ended_at IS NOT NULL -- incomplete interceptions are not included in summaries
    AND ended_at >= $1::timestamptz
    AND ended_at < $2::timestamptz
`

type ListAIBridgeInterceptionsTelemetrySummariesParams struct {
	EndedAtAfter  time.Time `db:"ended_at_after" json:"ended_at_after"`
	EndedAtBefore time.Time `db:"ended_at_before" json:"ended_at_before"`
}

type ListAIBridgeInterceptionsTelemetrySummariesRow struct {
	Provider string `db:"provider" json:"provider"`
	Model    string `db:"model" json:"model"`
	Client   string `db:"client" json:"client"`
}

// Finds all unique AI Bridge interception telemetry summaries combinations
// (provider, model, client) in the given timeframe for telemetry reporting.
func (q *Queries) ListAIBridgeInterceptionsTelemetrySummaries(ctx context.Context, arg ListAIBridgeInterceptionsTelemetrySummariesParams) ([]ListAIBridgeInterceptionsTelemetrySummariesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAIBridgeInterceptionsTelemetrySummaries, arg.EndedAtAfter, arg.EndedAtBefore)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAIBridgeInterceptionsTelemetrySummariesRow
	for rows.Next() {
		var i ListAIBridgeInterceptionsTelemetrySummariesRow
		if err := rows.Scan(&i.Provider, &i.Model, &i.Client); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAIBridgeTokenUsagesByInterceptionIDs = `-- name: ListAIBridgeTokenUsagesByInterceptionIDs :many
SELECT
	id, interception_id, provider_response_id, input_tokens, output_tokens, metadata, created_at
FROM
	aibridge_token_usages
WHERE
	interception_id = ANY($1::uuid[])
ORDER BY
	created_at ASC,
	id ASC
`

func (q *Queries) ListAIBridgeTokenUsagesByInterceptionIDs(ctx context.Context, interceptionIds []uuid.UUID) ([]AIBridgeTokenUsage, error) {
	rows, err := q.db.QueryContext(ctx, listAIBridgeTokenUsagesByInterceptionIDs, pq.Array(interceptionIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AIBridgeTokenUsage
	for rows.Next() {
		var i AIBridgeTokenUsage
		if err := rows.Scan(
			&i.ID,
			&i.InterceptionID,
			&i.ProviderResponseID,
			&i.InputTokens,
			&i.OutputTokens,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAIBridgeToolUsagesByInterceptionIDs = `-- name: ListAIBridgeToolUsagesByInterceptionIDs :many
SELECT
	id, interception_id, provider_response_id, server_url, tool, input, injected, invocation_error, metadata, created_at
FROM
	aibridge_tool_usages
WHERE
	interception_id = ANY($1::uuid[])
ORDER BY
	created_at ASC,
	id ASC
`

func (q *Queries) ListAIBridgeToolUsagesByInterceptionIDs(ctx context.Context, interceptionIds []uuid.UUID) ([]AIBridgeToolUsage, error) {
	rows, err := q.db.QueryContext(ctx, listAIBridgeToolUsagesByInterceptionIDs, pq.Array(interceptionIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AIBridgeToolUsage
	for rows.Next() {
		var i AIBridgeToolUsage
		if err := rows.Scan(
			&i.ID,
			&i.InterceptionID,
			&i.ProviderResponseID,
			&i.ServerUrl,
			&i.Tool,
			&i.Input,
			&i.Injected,
			&i.InvocationError,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAIBridgeUserPromptsByInterceptionIDs = `-- name: ListAIBridgeUserPromptsByInterceptionIDs :many
SELECT
	id, interception_id, provider_response_id, prompt, metadata, created_at
FROM
	aibridge_user_prompts
WHERE
	interception_id = ANY($1::uuid[])
ORDER BY
	created_at ASC,
	id ASC
`

func (q *Queries) ListAIBridgeUserPromptsByInterceptionIDs(ctx context.Context, interceptionIds []uuid.UUID) ([]AIBridgeUserPrompt, error) {
	rows, err := q.db.QueryContext(ctx, listAIBridgeUserPromptsByInterceptionIDs, pq.Array(interceptionIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AIBridgeUserPrompt
	for rows.Next() {
		var i AIBridgeUserPrompt
		if err := rows.Scan(
			&i.ID,
			&i.InterceptionID,
			&i.ProviderResponseID,
			&i.Prompt,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAIBridgeInterceptionEnded = `-- name: UpdateAIBridgeInterceptionEnded :one
UPDATE aibridge_interceptions
	SET ended_at = $1::timestamptz
WHERE
	id = $2::uuid
	AND ended_at IS NULL
RETURNING id, initiator_id, provider, model, started_at, metadata, ended_at, api_key_id
`

type UpdateAIBridgeInterceptionEndedParams struct {
	EndedAt time.Time `db:"ended_at" json:"ended_at"`
	ID      uuid.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdateAIBridgeInterceptionEnded(ctx context.Context, arg UpdateAIBridgeInterceptionEndedParams) (AIBridgeInterception, error) {
	row := q.db.QueryRowContext(ctx, updateAIBridgeInterceptionEnded, arg.EndedAt, arg.ID)
	var i AIBridgeInterception
	err := row.Scan(
		&i.ID,
		&i.InitiatorID,
		&i.Provider,
		&i.Model,
		&i.StartedAt,
		&i.Metadata,
		&i.EndedAt,
		&i.APIKeyID,
	)
	return i, err
}
