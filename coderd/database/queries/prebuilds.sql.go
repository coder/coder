// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: prebuilds.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const claimPrebuiltWorkspace = `-- name: ClaimPrebuiltWorkspace :one
UPDATE workspaces w
SET owner_id   = $1::uuid,
	name       = $2::text,
	updated_at = $3::timestamptz,
	-- Update autostart_schedule, next_start_at and ttl according to template and workspace-level
	-- configurations, allowing the workspace to be managed by the lifecycle executor as expected.
	autostart_schedule = $4,
	next_start_at = $5,
	ttl = $6,
	-- Update last_used_at during claim to ensure the claimed workspace is treated as recently used.
	-- This avoids unintended dormancy caused by prebuilds having stale usage timestamps.
	last_used_at = $3::timestamptz,
	-- Clear dormant and deletion timestamps as a safeguard to ensure a clean lifecycle state after claim.
	-- These fields should not be set on prebuilds, but we defensively reset them here to prevent
	-- accidental dormancy or deletion by the lifecycle executor.
	dormant_at = NULL,
	deleting_at = NULL
WHERE w.id IN (
	SELECT p.id
	FROM workspace_prebuilds p
		INNER JOIN workspace_latest_builds b ON b.workspace_id = p.id
		INNER JOIN templates t ON p.template_id = t.id
	WHERE (b.transition = 'start'::workspace_transition
		AND b.job_status IN ('succeeded'::provisioner_job_status))
		-- The prebuilds system should never try to claim a prebuild for an inactive template version.
		-- Nevertheless, this filter is here as a defensive measure:
		AND b.template_version_id = t.active_version_id
		AND p.current_preset_id = $7::uuid
		AND p.ready
		AND NOT t.deleted
	LIMIT 1 FOR UPDATE OF p SKIP LOCKED -- Ensure that a concurrent request will not select the same prebuild.
)
RETURNING w.id, w.name
`

type ClaimPrebuiltWorkspaceParams struct {
	NewUserID         uuid.UUID      `db:"new_user_id" json:"new_user_id"`
	NewName           string         `db:"new_name" json:"new_name"`
	Now               time.Time      `db:"now" json:"now"`
	AutostartSchedule sql.NullString `db:"autostart_schedule" json:"autostart_schedule"`
	NextStartAt       sql.NullTime   `db:"next_start_at" json:"next_start_at"`
	WorkspaceTtl      sql.NullInt64  `db:"workspace_ttl" json:"workspace_ttl"`
	PresetID          uuid.UUID      `db:"preset_id" json:"preset_id"`
}

type ClaimPrebuiltWorkspaceRow struct {
	ID   uuid.UUID `db:"id" json:"id"`
	Name string    `db:"name" json:"name"`
}

func (q *Queries) ClaimPrebuiltWorkspace(ctx context.Context, arg ClaimPrebuiltWorkspaceParams) (ClaimPrebuiltWorkspaceRow, error) {
	row := q.db.QueryRowContext(ctx, claimPrebuiltWorkspace,
		arg.NewUserID,
		arg.NewName,
		arg.Now,
		arg.AutostartSchedule,
		arg.NextStartAt,
		arg.WorkspaceTtl,
		arg.PresetID,
	)
	var i ClaimPrebuiltWorkspaceRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const countInProgressPrebuilds = `-- name: CountInProgressPrebuilds :many
SELECT t.id AS template_id, wpb.template_version_id, wpb.transition, COUNT(wpb.transition)::int AS count, wlb.template_version_preset_id as preset_id
FROM workspace_latest_builds wlb
		INNER JOIN workspace_prebuild_builds wpb ON wpb.id = wlb.id
		-- We only need these counts for active template versions.
		-- It doesn't influence whether we create or delete prebuilds
		-- for inactive template versions. This is because we never create
		-- prebuilds for inactive template versions, we always delete
		-- running prebuilds for inactive template versions, and we ignore
		-- prebuilds that are still building.
		INNER JOIN templates t ON t.active_version_id = wlb.template_version_id
WHERE wlb.job_status IN ('pending'::provisioner_job_status, 'running'::provisioner_job_status)
  -- AND NOT t.deleted -- We don't exclude deleted templates because there's no constraint in the DB preventing a soft deletion on a template while workspaces are running.
GROUP BY t.id, wpb.template_version_id, wpb.transition, wlb.template_version_preset_id
`

type CountInProgressPrebuildsRow struct {
	TemplateID        uuid.UUID           `db:"template_id" json:"template_id"`
	TemplateVersionID uuid.UUID           `db:"template_version_id" json:"template_version_id"`
	Transition        WorkspaceTransition `db:"transition" json:"transition"`
	Count             int32               `db:"count" json:"count"`
	PresetID          uuid.NullUUID       `db:"preset_id" json:"preset_id"`
}

// CountInProgressPrebuilds returns the number of in-progress prebuilds, grouped by preset ID and transition.
// Prebuild considered in-progress if it's in the "pending", "starting", "stopping", or "deleting" state.
func (q *Queries) CountInProgressPrebuilds(ctx context.Context) ([]CountInProgressPrebuildsRow, error) {
	rows, err := q.db.QueryContext(ctx, countInProgressPrebuilds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountInProgressPrebuildsRow
	for rows.Next() {
		var i CountInProgressPrebuildsRow
		if err := rows.Scan(
			&i.TemplateID,
			&i.TemplateVersionID,
			&i.Transition,
			&i.Count,
			&i.PresetID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countPendingNonActivePrebuilds = `-- name: CountPendingNonActivePrebuilds :many
SELECT
	wpb.template_version_preset_id AS preset_id,
	COUNT(*)::int AS count
FROM workspace_prebuild_builds wpb
INNER JOIN provisioner_jobs pj ON pj.id = wpb.job_id
INNER JOIN workspaces w ON w.id = wpb.workspace_id
INNER JOIN templates t ON t.id = w.template_id
WHERE
	wpb.template_version_id != t.active_version_id
	-- Only considers initial builds, i.e. created by the reconciliation loop
	AND wpb.build_number = 1
	-- Only consider 'start' transitions (provisioning), not 'stop'/'delete' (deprovisioning)
	-- Deprovisioning jobs should complete naturally as they're already cleaning up resources
	AND wpb.transition = 'start'::workspace_transition
	-- Pending jobs that have not yet been picked up by a provisioner
	AND pj.job_status = 'pending'::provisioner_job_status
	AND pj.worker_id IS NULL
	AND pj.canceled_at IS NULL
	AND pj.completed_at IS NULL
GROUP BY wpb.template_version_preset_id
`

type CountPendingNonActivePrebuildsRow struct {
	PresetID uuid.NullUUID `db:"preset_id" json:"preset_id"`
	Count    int32         `db:"count" json:"count"`
}

// CountPendingNonActivePrebuilds returns the number of pending prebuilds for non-active template versions
func (q *Queries) CountPendingNonActivePrebuilds(ctx context.Context) ([]CountPendingNonActivePrebuildsRow, error) {
	rows, err := q.db.QueryContext(ctx, countPendingNonActivePrebuilds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountPendingNonActivePrebuildsRow
	for rows.Next() {
		var i CountPendingNonActivePrebuildsRow
		if err := rows.Scan(&i.PresetID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMatchingPresetID = `-- name: FindMatchingPresetID :one
WITH provided_params AS (
	SELECT
		unnest($1::text[]) AS name,
		unnest($2::text[]) AS value
),
preset_matches AS (
	SELECT
		tvp.id AS template_version_preset_id,
		COALESCE(COUNT(tvpp.name), 0) AS total_preset_params,
		COALESCE(COUNT(pp.name), 0) AS matching_params
	FROM template_version_presets tvp
	LEFT JOIN template_version_preset_parameters tvpp ON tvpp.template_version_preset_id = tvp.id
	LEFT JOIN provided_params pp ON pp.name = tvpp.name AND pp.value = tvpp.value
	WHERE tvp.template_version_id = $3
	GROUP BY tvp.id
)
SELECT pm.template_version_preset_id
FROM preset_matches pm
WHERE pm.total_preset_params = pm.matching_params  -- All preset parameters must match
ORDER BY pm.total_preset_params DESC               -- Return the preset with the most parameters
LIMIT 1
`

type FindMatchingPresetIDParams struct {
	ParameterNames    []string  `db:"parameter_names" json:"parameter_names"`
	ParameterValues   []string  `db:"parameter_values" json:"parameter_values"`
	TemplateVersionID uuid.UUID `db:"template_version_id" json:"template_version_id"`
}

// FindMatchingPresetID finds a preset ID that is the largest exact subset of the provided parameters.
// It returns the preset ID if a match is found, or NULL if no match is found.
// The query finds presets where all preset parameters are present in the provided parameters,
// and returns the preset with the most parameters (largest subset).
func (q *Queries) FindMatchingPresetID(ctx context.Context, arg FindMatchingPresetIDParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, findMatchingPresetID, pq.Array(arg.ParameterNames), pq.Array(arg.ParameterValues), arg.TemplateVersionID)
	var template_version_preset_id uuid.UUID
	err := row.Scan(&template_version_preset_id)
	return template_version_preset_id, err
}

const getOrganizationsWithPrebuildStatus = `-- name: GetOrganizationsWithPrebuildStatus :many
WITH orgs_with_prebuilds AS (
	-- Get unique organizations that have presets with prebuilds configured
	SELECT DISTINCT o.id, o.name
	FROM organizations o
	INNER JOIN templates t ON t.organization_id = o.id
	INNER JOIN template_versions tv ON tv.template_id = t.id
	INNER JOIN template_version_presets tvp ON tvp.template_version_id = tv.id
	WHERE tvp.desired_instances IS NOT NULL
),
prebuild_user_membership AS (
	-- Check if the user is a member of the organizations
	SELECT om.organization_id
	FROM organization_members om
	INNER JOIN orgs_with_prebuilds owp ON owp.id = om.organization_id
	WHERE om.user_id = $1::uuid
),
prebuild_groups AS (
	-- Check if the organizations have the prebuilds group
	SELECT g.organization_id, g.id as group_id
	FROM groups g
	INNER JOIN orgs_with_prebuilds owp ON owp.id = g.organization_id
	WHERE g.name = $2::text
),
prebuild_group_membership AS (
	-- Check if the user is in the prebuilds group
	SELECT pg.organization_id
	FROM prebuild_groups pg
	INNER JOIN group_members gm ON gm.group_id = pg.group_id
	WHERE gm.user_id = $1::uuid
)
SELECT
	owp.id AS organization_id,
	owp.name AS organization_name,
	(pum.organization_id IS NOT NULL)::boolean AS has_prebuild_user,
	pg.group_id AS prebuilds_group_id,
	(pgm.organization_id IS NOT NULL)::boolean AS has_prebuild_user_in_group
FROM orgs_with_prebuilds owp
LEFT JOIN prebuild_groups pg ON pg.organization_id = owp.id
LEFT JOIN prebuild_user_membership pum ON pum.organization_id = owp.id
LEFT JOIN prebuild_group_membership pgm ON pgm.organization_id = owp.id
`

type GetOrganizationsWithPrebuildStatusParams struct {
	UserID    uuid.UUID `db:"user_id" json:"user_id"`
	GroupName string    `db:"group_name" json:"group_name"`
}

type GetOrganizationsWithPrebuildStatusRow struct {
	OrganizationID         uuid.UUID     `db:"organization_id" json:"organization_id"`
	OrganizationName       string        `db:"organization_name" json:"organization_name"`
	HasPrebuildUser        bool          `db:"has_prebuild_user" json:"has_prebuild_user"`
	PrebuildsGroupID       uuid.NullUUID `db:"prebuilds_group_id" json:"prebuilds_group_id"`
	HasPrebuildUserInGroup bool          `db:"has_prebuild_user_in_group" json:"has_prebuild_user_in_group"`
}

// GetOrganizationsWithPrebuildStatus returns organizations with prebuilds configured and their
// membership status for the prebuilds system user (org membership, group existence, group membership).
func (q *Queries) GetOrganizationsWithPrebuildStatus(ctx context.Context, arg GetOrganizationsWithPrebuildStatusParams) ([]GetOrganizationsWithPrebuildStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrganizationsWithPrebuildStatus, arg.UserID, arg.GroupName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrganizationsWithPrebuildStatusRow
	for rows.Next() {
		var i GetOrganizationsWithPrebuildStatusRow
		if err := rows.Scan(
			&i.OrganizationID,
			&i.OrganizationName,
			&i.HasPrebuildUser,
			&i.PrebuildsGroupID,
			&i.HasPrebuildUserInGroup,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrebuildMetrics = `-- name: GetPrebuildMetrics :many
SELECT
	t.name as template_name,
	tvp.name as preset_name,
	o.name as organization_name,
	COUNT(*) as created_count,
	COUNT(*) FILTER (WHERE pj.job_status = 'failed'::provisioner_job_status) as failed_count,
	COUNT(*) FILTER (
			WHERE w.owner_id != 'c42fdf75-3097-471c-8c33-fb52454d81c0'::uuid -- The system user responsible for prebuilds.
		) as claimed_count
FROM workspaces w
INNER JOIN workspace_prebuild_builds wpb ON wpb.workspace_id = w.id
INNER JOIN templates t ON t.id = w.template_id
INNER JOIN template_version_presets tvp ON tvp.id = wpb.template_version_preset_id
INNER JOIN provisioner_jobs pj ON pj.id = wpb.job_id
INNER JOIN organizations o ON o.id = w.organization_id
WHERE NOT t.deleted AND wpb.build_number = 1
GROUP BY t.name, tvp.name, o.name
ORDER BY t.name, tvp.name, o.name
`

type GetPrebuildMetricsRow struct {
	TemplateName     string `db:"template_name" json:"template_name"`
	PresetName       string `db:"preset_name" json:"preset_name"`
	OrganizationName string `db:"organization_name" json:"organization_name"`
	CreatedCount     int64  `db:"created_count" json:"created_count"`
	FailedCount      int64  `db:"failed_count" json:"failed_count"`
	ClaimedCount     int64  `db:"claimed_count" json:"claimed_count"`
}

func (q *Queries) GetPrebuildMetrics(ctx context.Context) ([]GetPrebuildMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrebuildMetrics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPrebuildMetricsRow
	for rows.Next() {
		var i GetPrebuildMetricsRow
		if err := rows.Scan(
			&i.TemplateName,
			&i.PresetName,
			&i.OrganizationName,
			&i.CreatedCount,
			&i.FailedCount,
			&i.ClaimedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPresetsAtFailureLimit = `-- name: GetPresetsAtFailureLimit :many
WITH filtered_builds AS (
	-- Only select builds which are for prebuild creations
	SELECT wlb.template_version_id, wlb.created_at, tvp.id AS preset_id, wlb.job_status, tvp.desired_instances
	FROM template_version_presets tvp
			INNER JOIN workspace_latest_builds wlb ON wlb.template_version_preset_id = tvp.id
			INNER JOIN workspaces w ON wlb.workspace_id = w.id
			INNER JOIN template_versions tv ON wlb.template_version_id = tv.id
			INNER JOIN templates t ON tv.template_id = t.id AND t.active_version_id = tv.id
	WHERE tvp.desired_instances IS NOT NULL -- Consider only presets that have a prebuild configuration.
		AND wlb.transition = 'start'::workspace_transition
		AND w.owner_id = 'c42fdf75-3097-471c-8c33-fb52454d81c0'
),
time_sorted_builds AS (
	-- Group builds by preset, then sort each group by created_at.
	SELECT fb.template_version_id, fb.created_at, fb.preset_id, fb.job_status, fb.desired_instances,
		ROW_NUMBER() OVER (PARTITION BY fb.preset_id ORDER BY fb.created_at DESC) as rn
	FROM filtered_builds fb
)
SELECT
	tsb.template_version_id,
	tsb.preset_id
FROM time_sorted_builds tsb
WHERE tsb.rn <= $1::bigint
	AND tsb.job_status = 'failed'::provisioner_job_status
GROUP BY tsb.template_version_id, tsb.preset_id
HAVING COUNT(*) = $1::bigint
`

type GetPresetsAtFailureLimitRow struct {
	TemplateVersionID uuid.UUID `db:"template_version_id" json:"template_version_id"`
	PresetID          uuid.UUID `db:"preset_id" json:"preset_id"`
}

// GetPresetsAtFailureLimit groups workspace builds by preset ID.
// Each preset is associated with exactly one template version ID.
// For each preset, the query checks the last hard_limit builds.
// If all of them failed, the preset is considered to have hit the hard failure limit.
// The query returns a list of preset IDs that have reached this failure threshold.
// Only active template versions with configured presets are considered.
// For each preset, check the last hard_limit builds.
// If all of them failed, the preset is considered to have hit the hard failure limit.
func (q *Queries) GetPresetsAtFailureLimit(ctx context.Context, hardLimit int64) ([]GetPresetsAtFailureLimitRow, error) {
	rows, err := q.db.QueryContext(ctx, getPresetsAtFailureLimit, hardLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPresetsAtFailureLimitRow
	for rows.Next() {
		var i GetPresetsAtFailureLimitRow
		if err := rows.Scan(&i.TemplateVersionID, &i.PresetID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPresetsBackoff = `-- name: GetPresetsBackoff :many
WITH filtered_builds AS (
	-- Only select builds which are for prebuild creations
	SELECT wlb.template_version_id, wlb.created_at, tvp.id AS preset_id, wlb.job_status, tvp.desired_instances
	FROM template_version_presets tvp
			INNER JOIN workspace_latest_builds wlb ON wlb.template_version_preset_id = tvp.id
			INNER JOIN workspaces w ON wlb.workspace_id = w.id
			INNER JOIN template_versions tv ON wlb.template_version_id = tv.id
			INNER JOIN templates t ON tv.template_id = t.id AND t.active_version_id = tv.id
	WHERE tvp.desired_instances IS NOT NULL -- Consider only presets that have a prebuild configuration.
		AND wlb.transition = 'start'::workspace_transition
		AND w.owner_id = 'c42fdf75-3097-471c-8c33-fb52454d81c0'
		AND NOT t.deleted
),
time_sorted_builds AS (
	-- Group builds by preset, then sort each group by created_at.
	SELECT fb.template_version_id, fb.created_at, fb.preset_id, fb.job_status, fb.desired_instances,
		ROW_NUMBER() OVER (PARTITION BY fb.preset_id ORDER BY fb.created_at DESC) as rn
	FROM filtered_builds fb
),
failed_count AS (
	-- Count failed builds per preset in the given period
	SELECT preset_id, COUNT(*) AS num_failed
	FROM filtered_builds
	WHERE job_status = 'failed'::provisioner_job_status
		AND created_at >= $1::timestamptz
	GROUP BY preset_id
)
SELECT
		tsb.template_version_id,
		tsb.preset_id,
		COALESCE(fc.num_failed, 0)::int  AS num_failed,
		MAX(tsb.created_at)::timestamptz AS last_build_at
FROM time_sorted_builds tsb
		LEFT JOIN failed_count fc ON fc.preset_id = tsb.preset_id
WHERE tsb.rn <= tsb.desired_instances -- Fetch the last N builds, where N is the number of desired instances; if any fail, we backoff
		AND tsb.job_status = 'failed'::provisioner_job_status
		AND created_at >= $1::timestamptz
GROUP BY tsb.template_version_id, tsb.preset_id, fc.num_failed
`

type GetPresetsBackoffRow struct {
	TemplateVersionID uuid.UUID `db:"template_version_id" json:"template_version_id"`
	PresetID          uuid.UUID `db:"preset_id" json:"preset_id"`
	NumFailed         int32     `db:"num_failed" json:"num_failed"`
	LastBuildAt       time.Time `db:"last_build_at" json:"last_build_at"`
}

// GetPresetsBackoff groups workspace builds by preset ID.
// Each preset is associated with exactly one template version ID.
// For each group, the query checks up to N of the most recent jobs that occurred within the
// lookback period, where N equals the number of desired instances for the corresponding preset.
// If at least one of the job within a group has failed, we should backoff on the corresponding preset ID.
// Query returns a list of preset IDs for which we should backoff.
// Only active template versions with configured presets are considered.
// We also return the number of failed workspace builds that occurred during the lookback period.
//
// NOTE:
// - To **decide whether to back off**, we look at up to the N most recent builds (within the defined lookback period).
// - To **calculate the number of failed builds**, we consider all builds within the defined lookback period.
//
// The number of failed builds is used downstream to determine the backoff duration.
func (q *Queries) GetPresetsBackoff(ctx context.Context, lookback time.Time) ([]GetPresetsBackoffRow, error) {
	rows, err := q.db.QueryContext(ctx, getPresetsBackoff, lookback)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPresetsBackoffRow
	for rows.Next() {
		var i GetPresetsBackoffRow
		if err := rows.Scan(
			&i.TemplateVersionID,
			&i.PresetID,
			&i.NumFailed,
			&i.LastBuildAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRunningPrebuiltWorkspaces = `-- name: GetRunningPrebuiltWorkspaces :many
WITH latest_prebuilds AS (
	-- All workspaces that match the following criteria:
	-- 1. Owned by prebuilds user
	-- 2. Not deleted
	-- 3. Latest build is a 'start' transition
	-- 4. Latest build was successful
	SELECT
		workspaces.id,
		workspaces.name,
		workspaces.template_id,
		workspace_latest_builds.template_version_id,
		workspace_latest_builds.job_id,
		workspaces.created_at
	FROM workspace_latest_builds
	JOIN workspaces ON workspaces.id = workspace_latest_builds.workspace_id
	WHERE workspace_latest_builds.transition = 'start'::workspace_transition
	AND workspace_latest_builds.job_status = 'succeeded'::provisioner_job_status
	AND workspaces.owner_id = 'c42fdf75-3097-471c-8c33-fb52454d81c0'::UUID
	AND NOT workspaces.deleted
),
workspace_latest_presets AS (
	-- For each of the above workspaces, the preset_id of the most recent
	-- successful start transition.
	SELECT DISTINCT ON (latest_prebuilds.id)
		latest_prebuilds.id AS workspace_id,
		workspace_builds.template_version_preset_id AS current_preset_id
	FROM latest_prebuilds
	JOIN workspace_builds ON workspace_builds.workspace_id = latest_prebuilds.id
	WHERE workspace_builds.transition = 'start'::workspace_transition
	AND   workspace_builds.template_version_preset_id IS NOT NULL
	ORDER BY latest_prebuilds.id, workspace_builds.build_number DESC
),
ready_agents AS (
	-- For each of the above workspaces, check if all agents are ready.
	SELECT
		latest_prebuilds.job_id,
		BOOL_AND(workspace_agents.lifecycle_state = 'ready'::workspace_agent_lifecycle_state)::boolean AS ready
	FROM latest_prebuilds
	JOIN workspace_resources ON workspace_resources.job_id = latest_prebuilds.job_id
	JOIN workspace_agents ON workspace_agents.resource_id = workspace_resources.id
	WHERE workspace_agents.deleted = false
	AND workspace_agents.parent_id IS NULL
	GROUP BY latest_prebuilds.job_id
)
SELECT
	latest_prebuilds.id,
	latest_prebuilds.name,
	latest_prebuilds.template_id,
	latest_prebuilds.template_version_id,
	workspace_latest_presets.current_preset_id,
	COALESCE(ready_agents.ready, false)::boolean AS ready,
	latest_prebuilds.created_at
FROM latest_prebuilds
LEFT JOIN ready_agents ON ready_agents.job_id = latest_prebuilds.job_id
LEFT JOIN workspace_latest_presets ON workspace_latest_presets.workspace_id = latest_prebuilds.id
ORDER BY latest_prebuilds.id
`

type GetRunningPrebuiltWorkspacesRow struct {
	ID                uuid.UUID     `db:"id" json:"id"`
	Name              string        `db:"name" json:"name"`
	TemplateID        uuid.UUID     `db:"template_id" json:"template_id"`
	TemplateVersionID uuid.UUID     `db:"template_version_id" json:"template_version_id"`
	CurrentPresetID   uuid.NullUUID `db:"current_preset_id" json:"current_preset_id"`
	Ready             bool          `db:"ready" json:"ready"`
	CreatedAt         time.Time     `db:"created_at" json:"created_at"`
}

func (q *Queries) GetRunningPrebuiltWorkspaces(ctx context.Context) ([]GetRunningPrebuiltWorkspacesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRunningPrebuiltWorkspaces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRunningPrebuiltWorkspacesRow
	for rows.Next() {
		var i GetRunningPrebuiltWorkspacesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TemplateID,
			&i.TemplateVersionID,
			&i.CurrentPresetID,
			&i.Ready,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTemplatePresetsWithPrebuilds = `-- name: GetTemplatePresetsWithPrebuilds :many
SELECT
		t.id                        AS template_id,
		t.name                      AS template_name,
		o.id                        AS organization_id,
		o.name                      AS organization_name,
		tv.id                       AS template_version_id,
		tv.name                     AS template_version_name,
		tv.id = t.active_version_id AS using_active_version,
		tvp.id,
		tvp.name,
		tvp.desired_instances       AS desired_instances,
		tvp.scheduling_timezone,
		tvp.invalidate_after_secs   AS ttl,
		tvp.prebuild_status,
		tvp.last_invalidated_at,
		t.deleted,
		t.deprecated != ''          AS deprecated
FROM templates t
		INNER JOIN template_versions tv ON tv.template_id = t.id
		INNER JOIN template_version_presets tvp ON tvp.template_version_id = tv.id
		INNER JOIN organizations o ON o.id = t.organization_id
WHERE tvp.desired_instances IS NOT NULL -- Consider only presets that have a prebuild configuration.
  -- AND NOT t.deleted -- We don't exclude deleted templates because there's no constraint in the DB preventing a soft deletion on a template while workspaces are running.
	AND (t.id = $1::uuid OR $1 IS NULL)
`

type GetTemplatePresetsWithPrebuildsRow struct {
	TemplateID          uuid.UUID      `db:"template_id" json:"template_id"`
	TemplateName        string         `db:"template_name" json:"template_name"`
	OrganizationID      uuid.UUID      `db:"organization_id" json:"organization_id"`
	OrganizationName    string         `db:"organization_name" json:"organization_name"`
	TemplateVersionID   uuid.UUID      `db:"template_version_id" json:"template_version_id"`
	TemplateVersionName string         `db:"template_version_name" json:"template_version_name"`
	UsingActiveVersion  bool           `db:"using_active_version" json:"using_active_version"`
	ID                  uuid.UUID      `db:"id" json:"id"`
	Name                string         `db:"name" json:"name"`
	DesiredInstances    sql.NullInt32  `db:"desired_instances" json:"desired_instances"`
	SchedulingTimezone  string         `db:"scheduling_timezone" json:"scheduling_timezone"`
	Ttl                 sql.NullInt32  `db:"ttl" json:"ttl"`
	PrebuildStatus      PrebuildStatus `db:"prebuild_status" json:"prebuild_status"`
	LastInvalidatedAt   sql.NullTime   `db:"last_invalidated_at" json:"last_invalidated_at"`
	Deleted             bool           `db:"deleted" json:"deleted"`
	Deprecated          bool           `db:"deprecated" json:"deprecated"`
}

// GetTemplatePresetsWithPrebuilds retrieves template versions with configured presets and prebuilds.
// It also returns the number of desired instances for each preset.
// If template_id is specified, only template versions associated with that template will be returned.
func (q *Queries) GetTemplatePresetsWithPrebuilds(ctx context.Context, templateID uuid.NullUUID) ([]GetTemplatePresetsWithPrebuildsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTemplatePresetsWithPrebuilds, templateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTemplatePresetsWithPrebuildsRow
	for rows.Next() {
		var i GetTemplatePresetsWithPrebuildsRow
		if err := rows.Scan(
			&i.TemplateID,
			&i.TemplateName,
			&i.OrganizationID,
			&i.OrganizationName,
			&i.TemplateVersionID,
			&i.TemplateVersionName,
			&i.UsingActiveVersion,
			&i.ID,
			&i.Name,
			&i.DesiredInstances,
			&i.SchedulingTimezone,
			&i.Ttl,
			&i.PrebuildStatus,
			&i.LastInvalidatedAt,
			&i.Deleted,
			&i.Deprecated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePrebuildProvisionerJobWithCancel = `-- name: UpdatePrebuildProvisionerJobWithCancel :many
WITH jobs_to_cancel AS (
	SELECT pj.id, w.id AS workspace_id, w.template_id, wpb.template_version_preset_id
	FROM provisioner_jobs pj
	INNER JOIN workspace_prebuild_builds wpb ON wpb.job_id = pj.id
	INNER JOIN workspaces w ON w.id = wpb.workspace_id
	INNER JOIN templates t ON t.id = w.template_id
	WHERE
		wpb.template_version_id != t.active_version_id
		AND wpb.template_version_preset_id = $2
		-- Only considers initial builds, i.e. created by the reconciliation loop
		AND wpb.build_number = 1
		-- Only consider 'start' transitions (provisioning), not 'stop'/'delete' (deprovisioning)
		-- Deprovisioning jobs should complete naturally as they're already cleaning up resources
		AND wpb.transition = 'start'::workspace_transition
		-- Pending jobs that have not yet been picked up by a provisioner
		AND pj.job_status = 'pending'::provisioner_job_status
		AND pj.worker_id IS NULL
		AND pj.canceled_at IS NULL
		AND pj.completed_at IS NULL
)
UPDATE provisioner_jobs
SET
	canceled_at = $1::timestamptz,
	completed_at = $1::timestamptz
FROM jobs_to_cancel
WHERE provisioner_jobs.id = jobs_to_cancel.id
RETURNING jobs_to_cancel.id, jobs_to_cancel.workspace_id, jobs_to_cancel.template_id, jobs_to_cancel.template_version_preset_id
`

type UpdatePrebuildProvisionerJobWithCancelParams struct {
	Now      time.Time     `db:"now" json:"now"`
	PresetID uuid.NullUUID `db:"preset_id" json:"preset_id"`
}

type UpdatePrebuildProvisionerJobWithCancelRow struct {
	ID                      uuid.UUID     `db:"id" json:"id"`
	WorkspaceID             uuid.UUID     `db:"workspace_id" json:"workspace_id"`
	TemplateID              uuid.UUID     `db:"template_id" json:"template_id"`
	TemplateVersionPresetID uuid.NullUUID `db:"template_version_preset_id" json:"template_version_preset_id"`
}

// Cancels all pending provisioner jobs for prebuilt workspaces on a specific preset from an
// inactive template version.
// This is an optimization to clean up stale pending jobs.
func (q *Queries) UpdatePrebuildProvisionerJobWithCancel(ctx context.Context, arg UpdatePrebuildProvisionerJobWithCancelParams) ([]UpdatePrebuildProvisionerJobWithCancelRow, error) {
	rows, err := q.db.QueryContext(ctx, updatePrebuildProvisionerJobWithCancel, arg.Now, arg.PresetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpdatePrebuildProvisionerJobWithCancelRow
	for rows.Next() {
		var i UpdatePrebuildProvisionerJobWithCancelRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.TemplateID,
			&i.TemplateVersionPresetID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
