// Code generated by sqlc. DO NOT EDIT.
// source: workspacebuilds.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getWorkspaceBuildByID = `-- name: GetWorkspaceBuildByID :one
SELECT
	id, created_at, updated_at, workspace_id, project_version_id, name, before_id, after_id, transition, initiator, provisioner_state, job_id
FROM
	workspace_builds
WHERE
	id = $1
LIMIT
	1
`

func (q *sqlQuerier) GetWorkspaceBuildByID(ctx context.Context, id uuid.UUID) (WorkspaceBuild, error) {
	row := q.db.QueryRowContext(ctx, getWorkspaceBuildByID, id)
	var i WorkspaceBuild
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WorkspaceID,
		&i.ProjectVersionID,
		&i.Name,
		&i.BeforeID,
		&i.AfterID,
		&i.Transition,
		&i.Initiator,
		&i.ProvisionerState,
		&i.JobID,
	)
	return i, err
}

const getWorkspaceBuildByJobID = `-- name: GetWorkspaceBuildByJobID :one
SELECT
	id, created_at, updated_at, workspace_id, project_version_id, name, before_id, after_id, transition, initiator, provisioner_state, job_id
FROM
	workspace_builds
WHERE
	job_id = $1
LIMIT
	1
`

func (q *sqlQuerier) GetWorkspaceBuildByJobID(ctx context.Context, jobID uuid.UUID) (WorkspaceBuild, error) {
	row := q.db.QueryRowContext(ctx, getWorkspaceBuildByJobID, jobID)
	var i WorkspaceBuild
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WorkspaceID,
		&i.ProjectVersionID,
		&i.Name,
		&i.BeforeID,
		&i.AfterID,
		&i.Transition,
		&i.Initiator,
		&i.ProvisionerState,
		&i.JobID,
	)
	return i, err
}

const getWorkspaceBuildByWorkspaceID = `-- name: GetWorkspaceBuildByWorkspaceID :many
SELECT
	id, created_at, updated_at, workspace_id, project_version_id, name, before_id, after_id, transition, initiator, provisioner_state, job_id
FROM
	workspace_builds
WHERE
	workspace_id = $1
`

func (q *sqlQuerier) GetWorkspaceBuildByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]WorkspaceBuild, error) {
	rows, err := q.db.QueryContext(ctx, getWorkspaceBuildByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkspaceBuild
	for rows.Next() {
		var i WorkspaceBuild
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WorkspaceID,
			&i.ProjectVersionID,
			&i.Name,
			&i.BeforeID,
			&i.AfterID,
			&i.Transition,
			&i.Initiator,
			&i.ProvisionerState,
			&i.JobID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceBuildByWorkspaceIDAndName = `-- name: GetWorkspaceBuildByWorkspaceIDAndName :one
SELECT
	id, created_at, updated_at, workspace_id, project_version_id, name, before_id, after_id, transition, initiator, provisioner_state, job_id
FROM
	workspace_builds
WHERE
	workspace_id = $1
	AND "name" = $2
`

type GetWorkspaceBuildByWorkspaceIDAndNameParams struct {
	WorkspaceID uuid.UUID `db:"workspace_id" json:"workspace_id"`
	Name        string    `db:"name" json:"name"`
}

func (q *sqlQuerier) GetWorkspaceBuildByWorkspaceIDAndName(ctx context.Context, arg GetWorkspaceBuildByWorkspaceIDAndNameParams) (WorkspaceBuild, error) {
	row := q.db.QueryRowContext(ctx, getWorkspaceBuildByWorkspaceIDAndName, arg.WorkspaceID, arg.Name)
	var i WorkspaceBuild
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WorkspaceID,
		&i.ProjectVersionID,
		&i.Name,
		&i.BeforeID,
		&i.AfterID,
		&i.Transition,
		&i.Initiator,
		&i.ProvisionerState,
		&i.JobID,
	)
	return i, err
}

const getWorkspaceBuildByWorkspaceIDWithoutAfter = `-- name: GetWorkspaceBuildByWorkspaceIDWithoutAfter :one
SELECT
	id, created_at, updated_at, workspace_id, project_version_id, name, before_id, after_id, transition, initiator, provisioner_state, job_id
FROM
	workspace_builds
WHERE
	workspace_id = $1
	AND after_id IS NULL
LIMIT
	1
`

func (q *sqlQuerier) GetWorkspaceBuildByWorkspaceIDWithoutAfter(ctx context.Context, workspaceID uuid.UUID) (WorkspaceBuild, error) {
	row := q.db.QueryRowContext(ctx, getWorkspaceBuildByWorkspaceIDWithoutAfter, workspaceID)
	var i WorkspaceBuild
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WorkspaceID,
		&i.ProjectVersionID,
		&i.Name,
		&i.BeforeID,
		&i.AfterID,
		&i.Transition,
		&i.Initiator,
		&i.ProvisionerState,
		&i.JobID,
	)
	return i, err
}

const getWorkspaceBuildsByWorkspaceIDsWithoutAfter = `-- name: GetWorkspaceBuildsByWorkspaceIDsWithoutAfter :many
SELECT
	id, created_at, updated_at, workspace_id, project_version_id, name, before_id, after_id, transition, initiator, provisioner_state, job_id
FROM
	workspace_builds
WHERE
	workspace_id = ANY($1 :: uuid [ ])
	AND after_id IS NULL
`

func (q *sqlQuerier) GetWorkspaceBuildsByWorkspaceIDsWithoutAfter(ctx context.Context, ids []uuid.UUID) ([]WorkspaceBuild, error) {
	rows, err := q.db.QueryContext(ctx, getWorkspaceBuildsByWorkspaceIDsWithoutAfter, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkspaceBuild
	for rows.Next() {
		var i WorkspaceBuild
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WorkspaceID,
			&i.ProjectVersionID,
			&i.Name,
			&i.BeforeID,
			&i.AfterID,
			&i.Transition,
			&i.Initiator,
			&i.ProvisionerState,
			&i.JobID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertWorkspaceBuild = `-- name: InsertWorkspaceBuild :one
INSERT INTO
	workspace_builds (
		id,
		created_at,
		updated_at,
		workspace_id,
		project_version_id,
		before_id,
		"name",
		transition,
		initiator,
		job_id,
		provisioner_state
	)
VALUES
	($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id, created_at, updated_at, workspace_id, project_version_id, name, before_id, after_id, transition, initiator, provisioner_state, job_id
`

type InsertWorkspaceBuildParams struct {
	ID               uuid.UUID           `db:"id" json:"id"`
	CreatedAt        time.Time           `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time           `db:"updated_at" json:"updated_at"`
	WorkspaceID      uuid.UUID           `db:"workspace_id" json:"workspace_id"`
	ProjectVersionID uuid.UUID           `db:"project_version_id" json:"project_version_id"`
	BeforeID         uuid.NullUUID       `db:"before_id" json:"before_id"`
	Name             string              `db:"name" json:"name"`
	Transition       WorkspaceTransition `db:"transition" json:"transition"`
	Initiator        string              `db:"initiator" json:"initiator"`
	JobID            uuid.UUID           `db:"job_id" json:"job_id"`
	ProvisionerState []byte              `db:"provisioner_state" json:"provisioner_state"`
}

func (q *sqlQuerier) InsertWorkspaceBuild(ctx context.Context, arg InsertWorkspaceBuildParams) (WorkspaceBuild, error) {
	row := q.db.QueryRowContext(ctx, insertWorkspaceBuild,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.WorkspaceID,
		arg.ProjectVersionID,
		arg.BeforeID,
		arg.Name,
		arg.Transition,
		arg.Initiator,
		arg.JobID,
		arg.ProvisionerState,
	)
	var i WorkspaceBuild
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WorkspaceID,
		&i.ProjectVersionID,
		&i.Name,
		&i.BeforeID,
		&i.AfterID,
		&i.Transition,
		&i.Initiator,
		&i.ProvisionerState,
		&i.JobID,
	)
	return i, err
}

const updateWorkspaceBuildByID = `-- name: UpdateWorkspaceBuildByID :exec
UPDATE
	workspace_builds
SET
	updated_at = $2,
	after_id = $3,
	provisioner_state = $4
WHERE
	id = $1
`

type UpdateWorkspaceBuildByIDParams struct {
	ID               uuid.UUID     `db:"id" json:"id"`
	UpdatedAt        time.Time     `db:"updated_at" json:"updated_at"`
	AfterID          uuid.NullUUID `db:"after_id" json:"after_id"`
	ProvisionerState []byte        `db:"provisioner_state" json:"provisioner_state"`
}

func (q *sqlQuerier) UpdateWorkspaceBuildByID(ctx context.Context, arg UpdateWorkspaceBuildByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateWorkspaceBuildByID,
		arg.ID,
		arg.UpdatedAt,
		arg.AfterID,
		arg.ProvisionerState,
	)
	return err
}
