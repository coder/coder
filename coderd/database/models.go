// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0

package database

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

type APIKeyScope string

const (
	APIKeyScopeAll                APIKeyScope = "all"
	APIKeyScopeApplicationConnect APIKeyScope = "application_connect"
)

func (e *APIKeyScope) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = APIKeyScope(s)
	case string:
		*e = APIKeyScope(s)
	default:
		return fmt.Errorf("unsupported scan type for APIKeyScope: %T", src)
	}
	return nil
}

type NullAPIKeyScope struct {
	APIKeyScope APIKeyScope `json:"api_key_scope"`
	Valid       bool        `json:"valid"` // Valid is true if APIKeyScope is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAPIKeyScope) Scan(value interface{}) error {
	if value == nil {
		ns.APIKeyScope, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.APIKeyScope.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAPIKeyScope) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.APIKeyScope), nil
}

func (e APIKeyScope) Valid() bool {
	switch e {
	case APIKeyScopeAll,
		APIKeyScopeApplicationConnect:
		return true
	}
	return false
}

func AllAPIKeyScopeValues() []APIKeyScope {
	return []APIKeyScope{
		APIKeyScopeAll,
		APIKeyScopeApplicationConnect,
	}
}

type AppSharingLevel string

const (
	AppSharingLevelOwner         AppSharingLevel = "owner"
	AppSharingLevelAuthenticated AppSharingLevel = "authenticated"
	AppSharingLevelPublic        AppSharingLevel = "public"
)

func (e *AppSharingLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AppSharingLevel(s)
	case string:
		*e = AppSharingLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for AppSharingLevel: %T", src)
	}
	return nil
}

type NullAppSharingLevel struct {
	AppSharingLevel AppSharingLevel `json:"app_sharing_level"`
	Valid           bool            `json:"valid"` // Valid is true if AppSharingLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAppSharingLevel) Scan(value interface{}) error {
	if value == nil {
		ns.AppSharingLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AppSharingLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAppSharingLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AppSharingLevel), nil
}

func (e AppSharingLevel) Valid() bool {
	switch e {
	case AppSharingLevelOwner,
		AppSharingLevelAuthenticated,
		AppSharingLevelPublic:
		return true
	}
	return false
}

func AllAppSharingLevelValues() []AppSharingLevel {
	return []AppSharingLevel{
		AppSharingLevelOwner,
		AppSharingLevelAuthenticated,
		AppSharingLevelPublic,
	}
}

type AuditAction string

const (
	AuditActionCreate   AuditAction = "create"
	AuditActionWrite    AuditAction = "write"
	AuditActionDelete   AuditAction = "delete"
	AuditActionStart    AuditAction = "start"
	AuditActionStop     AuditAction = "stop"
	AuditActionLogin    AuditAction = "login"
	AuditActionLogout   AuditAction = "logout"
	AuditActionRegister AuditAction = "register"
)

func (e *AuditAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuditAction(s)
	case string:
		*e = AuditAction(s)
	default:
		return fmt.Errorf("unsupported scan type for AuditAction: %T", src)
	}
	return nil
}

type NullAuditAction struct {
	AuditAction AuditAction `json:"audit_action"`
	Valid       bool        `json:"valid"` // Valid is true if AuditAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuditAction) Scan(value interface{}) error {
	if value == nil {
		ns.AuditAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuditAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuditAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuditAction), nil
}

func (e AuditAction) Valid() bool {
	switch e {
	case AuditActionCreate,
		AuditActionWrite,
		AuditActionDelete,
		AuditActionStart,
		AuditActionStop,
		AuditActionLogin,
		AuditActionLogout,
		AuditActionRegister:
		return true
	}
	return false
}

func AllAuditActionValues() []AuditAction {
	return []AuditAction{
		AuditActionCreate,
		AuditActionWrite,
		AuditActionDelete,
		AuditActionStart,
		AuditActionStop,
		AuditActionLogin,
		AuditActionLogout,
		AuditActionRegister,
	}
}

type BuildReason string

const (
	BuildReasonInitiator  BuildReason = "initiator"
	BuildReasonAutostart  BuildReason = "autostart"
	BuildReasonAutostop   BuildReason = "autostop"
	BuildReasonAutolock   BuildReason = "autolock"
	BuildReasonFailedstop BuildReason = "failedstop"
	BuildReasonAutodelete BuildReason = "autodelete"
)

func (e *BuildReason) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BuildReason(s)
	case string:
		*e = BuildReason(s)
	default:
		return fmt.Errorf("unsupported scan type for BuildReason: %T", src)
	}
	return nil
}

type NullBuildReason struct {
	BuildReason BuildReason `json:"build_reason"`
	Valid       bool        `json:"valid"` // Valid is true if BuildReason is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBuildReason) Scan(value interface{}) error {
	if value == nil {
		ns.BuildReason, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BuildReason.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBuildReason) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BuildReason), nil
}

func (e BuildReason) Valid() bool {
	switch e {
	case BuildReasonInitiator,
		BuildReasonAutostart,
		BuildReasonAutostop,
		BuildReasonAutolock,
		BuildReasonFailedstop,
		BuildReasonAutodelete:
		return true
	}
	return false
}

func AllBuildReasonValues() []BuildReason {
	return []BuildReason{
		BuildReasonInitiator,
		BuildReasonAutostart,
		BuildReasonAutostop,
		BuildReasonAutolock,
		BuildReasonFailedstop,
		BuildReasonAutodelete,
	}
}

type GroupSource string

const (
	GroupSourceUser GroupSource = "user"
	GroupSourceOidc GroupSource = "oidc"
)

func (e *GroupSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GroupSource(s)
	case string:
		*e = GroupSource(s)
	default:
		return fmt.Errorf("unsupported scan type for GroupSource: %T", src)
	}
	return nil
}

type NullGroupSource struct {
	GroupSource GroupSource `json:"group_source"`
	Valid       bool        `json:"valid"` // Valid is true if GroupSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGroupSource) Scan(value interface{}) error {
	if value == nil {
		ns.GroupSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GroupSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGroupSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GroupSource), nil
}

func (e GroupSource) Valid() bool {
	switch e {
	case GroupSourceUser,
		GroupSourceOidc:
		return true
	}
	return false
}

func AllGroupSourceValues() []GroupSource {
	return []GroupSource{
		GroupSourceUser,
		GroupSourceOidc,
	}
}

type LogLevel string

const (
	LogLevelTrace LogLevel = "trace"
	LogLevelDebug LogLevel = "debug"
	LogLevelInfo  LogLevel = "info"
	LogLevelWarn  LogLevel = "warn"
	LogLevelError LogLevel = "error"
)

func (e *LogLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LogLevel(s)
	case string:
		*e = LogLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for LogLevel: %T", src)
	}
	return nil
}

type NullLogLevel struct {
	LogLevel LogLevel `json:"log_level"`
	Valid    bool     `json:"valid"` // Valid is true if LogLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLogLevel) Scan(value interface{}) error {
	if value == nil {
		ns.LogLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LogLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLogLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LogLevel), nil
}

func (e LogLevel) Valid() bool {
	switch e {
	case LogLevelTrace,
		LogLevelDebug,
		LogLevelInfo,
		LogLevelWarn,
		LogLevelError:
		return true
	}
	return false
}

func AllLogLevelValues() []LogLevel {
	return []LogLevel{
		LogLevelTrace,
		LogLevelDebug,
		LogLevelInfo,
		LogLevelWarn,
		LogLevelError,
	}
}

type LogSource string

const (
	LogSourceProvisionerDaemon LogSource = "provisioner_daemon"
	LogSourceProvisioner       LogSource = "provisioner"
)

func (e *LogSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LogSource(s)
	case string:
		*e = LogSource(s)
	default:
		return fmt.Errorf("unsupported scan type for LogSource: %T", src)
	}
	return nil
}

type NullLogSource struct {
	LogSource LogSource `json:"log_source"`
	Valid     bool      `json:"valid"` // Valid is true if LogSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLogSource) Scan(value interface{}) error {
	if value == nil {
		ns.LogSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LogSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLogSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LogSource), nil
}

func (e LogSource) Valid() bool {
	switch e {
	case LogSourceProvisionerDaemon,
		LogSourceProvisioner:
		return true
	}
	return false
}

func AllLogSourceValues() []LogSource {
	return []LogSource{
		LogSourceProvisionerDaemon,
		LogSourceProvisioner,
	}
}

// Specifies the method of authentication. "none" is a special case in which no authentication method is allowed.
type LoginType string

const (
	LoginTypePassword LoginType = "password"
	LoginTypeGithub   LoginType = "github"
	LoginTypeOIDC     LoginType = "oidc"
	LoginTypeToken    LoginType = "token"
	LoginTypeNone     LoginType = "none"
)

func (e *LoginType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LoginType(s)
	case string:
		*e = LoginType(s)
	default:
		return fmt.Errorf("unsupported scan type for LoginType: %T", src)
	}
	return nil
}

type NullLoginType struct {
	LoginType LoginType `json:"login_type"`
	Valid     bool      `json:"valid"` // Valid is true if LoginType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLoginType) Scan(value interface{}) error {
	if value == nil {
		ns.LoginType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LoginType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLoginType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LoginType), nil
}

func (e LoginType) Valid() bool {
	switch e {
	case LoginTypePassword,
		LoginTypeGithub,
		LoginTypeOIDC,
		LoginTypeToken,
		LoginTypeNone:
		return true
	}
	return false
}

func AllLoginTypeValues() []LoginType {
	return []LoginType{
		LoginTypePassword,
		LoginTypeGithub,
		LoginTypeOIDC,
		LoginTypeToken,
		LoginTypeNone,
	}
}

type ParameterDestinationScheme string

const (
	ParameterDestinationSchemeNone                ParameterDestinationScheme = "none"
	ParameterDestinationSchemeEnvironmentVariable ParameterDestinationScheme = "environment_variable"
	ParameterDestinationSchemeProvisionerVariable ParameterDestinationScheme = "provisioner_variable"
)

func (e *ParameterDestinationScheme) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParameterDestinationScheme(s)
	case string:
		*e = ParameterDestinationScheme(s)
	default:
		return fmt.Errorf("unsupported scan type for ParameterDestinationScheme: %T", src)
	}
	return nil
}

type NullParameterDestinationScheme struct {
	ParameterDestinationScheme ParameterDestinationScheme `json:"parameter_destination_scheme"`
	Valid                      bool                       `json:"valid"` // Valid is true if ParameterDestinationScheme is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParameterDestinationScheme) Scan(value interface{}) error {
	if value == nil {
		ns.ParameterDestinationScheme, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParameterDestinationScheme.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParameterDestinationScheme) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParameterDestinationScheme), nil
}

func (e ParameterDestinationScheme) Valid() bool {
	switch e {
	case ParameterDestinationSchemeNone,
		ParameterDestinationSchemeEnvironmentVariable,
		ParameterDestinationSchemeProvisionerVariable:
		return true
	}
	return false
}

func AllParameterDestinationSchemeValues() []ParameterDestinationScheme {
	return []ParameterDestinationScheme{
		ParameterDestinationSchemeNone,
		ParameterDestinationSchemeEnvironmentVariable,
		ParameterDestinationSchemeProvisionerVariable,
	}
}

type ParameterScope string

const (
	ParameterScopeTemplate  ParameterScope = "template"
	ParameterScopeImportJob ParameterScope = "import_job"
	ParameterScopeWorkspace ParameterScope = "workspace"
)

func (e *ParameterScope) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParameterScope(s)
	case string:
		*e = ParameterScope(s)
	default:
		return fmt.Errorf("unsupported scan type for ParameterScope: %T", src)
	}
	return nil
}

type NullParameterScope struct {
	ParameterScope ParameterScope `json:"parameter_scope"`
	Valid          bool           `json:"valid"` // Valid is true if ParameterScope is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParameterScope) Scan(value interface{}) error {
	if value == nil {
		ns.ParameterScope, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParameterScope.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParameterScope) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParameterScope), nil
}

func (e ParameterScope) Valid() bool {
	switch e {
	case ParameterScopeTemplate,
		ParameterScopeImportJob,
		ParameterScopeWorkspace:
		return true
	}
	return false
}

func AllParameterScopeValues() []ParameterScope {
	return []ParameterScope{
		ParameterScopeTemplate,
		ParameterScopeImportJob,
		ParameterScopeWorkspace,
	}
}

type ParameterSourceScheme string

const (
	ParameterSourceSchemeNone ParameterSourceScheme = "none"
	ParameterSourceSchemeData ParameterSourceScheme = "data"
)

func (e *ParameterSourceScheme) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParameterSourceScheme(s)
	case string:
		*e = ParameterSourceScheme(s)
	default:
		return fmt.Errorf("unsupported scan type for ParameterSourceScheme: %T", src)
	}
	return nil
}

type NullParameterSourceScheme struct {
	ParameterSourceScheme ParameterSourceScheme `json:"parameter_source_scheme"`
	Valid                 bool                  `json:"valid"` // Valid is true if ParameterSourceScheme is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParameterSourceScheme) Scan(value interface{}) error {
	if value == nil {
		ns.ParameterSourceScheme, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParameterSourceScheme.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParameterSourceScheme) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParameterSourceScheme), nil
}

func (e ParameterSourceScheme) Valid() bool {
	switch e {
	case ParameterSourceSchemeNone,
		ParameterSourceSchemeData:
		return true
	}
	return false
}

func AllParameterSourceSchemeValues() []ParameterSourceScheme {
	return []ParameterSourceScheme{
		ParameterSourceSchemeNone,
		ParameterSourceSchemeData,
	}
}

type ParameterTypeSystem string

const (
	ParameterTypeSystemNone ParameterTypeSystem = "none"
	ParameterTypeSystemHCL  ParameterTypeSystem = "hcl"
)

func (e *ParameterTypeSystem) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParameterTypeSystem(s)
	case string:
		*e = ParameterTypeSystem(s)
	default:
		return fmt.Errorf("unsupported scan type for ParameterTypeSystem: %T", src)
	}
	return nil
}

type NullParameterTypeSystem struct {
	ParameterTypeSystem ParameterTypeSystem `json:"parameter_type_system"`
	Valid               bool                `json:"valid"` // Valid is true if ParameterTypeSystem is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParameterTypeSystem) Scan(value interface{}) error {
	if value == nil {
		ns.ParameterTypeSystem, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParameterTypeSystem.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParameterTypeSystem) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParameterTypeSystem), nil
}

func (e ParameterTypeSystem) Valid() bool {
	switch e {
	case ParameterTypeSystemNone,
		ParameterTypeSystemHCL:
		return true
	}
	return false
}

func AllParameterTypeSystemValues() []ParameterTypeSystem {
	return []ParameterTypeSystem{
		ParameterTypeSystemNone,
		ParameterTypeSystemHCL,
	}
}

type ProvisionerJobType string

const (
	ProvisionerJobTypeTemplateVersionImport ProvisionerJobType = "template_version_import"
	ProvisionerJobTypeWorkspaceBuild        ProvisionerJobType = "workspace_build"
	ProvisionerJobTypeTemplateVersionDryRun ProvisionerJobType = "template_version_dry_run"
)

func (e *ProvisionerJobType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProvisionerJobType(s)
	case string:
		*e = ProvisionerJobType(s)
	default:
		return fmt.Errorf("unsupported scan type for ProvisionerJobType: %T", src)
	}
	return nil
}

type NullProvisionerJobType struct {
	ProvisionerJobType ProvisionerJobType `json:"provisioner_job_type"`
	Valid              bool               `json:"valid"` // Valid is true if ProvisionerJobType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProvisionerJobType) Scan(value interface{}) error {
	if value == nil {
		ns.ProvisionerJobType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProvisionerJobType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProvisionerJobType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProvisionerJobType), nil
}

func (e ProvisionerJobType) Valid() bool {
	switch e {
	case ProvisionerJobTypeTemplateVersionImport,
		ProvisionerJobTypeWorkspaceBuild,
		ProvisionerJobTypeTemplateVersionDryRun:
		return true
	}
	return false
}

func AllProvisionerJobTypeValues() []ProvisionerJobType {
	return []ProvisionerJobType{
		ProvisionerJobTypeTemplateVersionImport,
		ProvisionerJobTypeWorkspaceBuild,
		ProvisionerJobTypeTemplateVersionDryRun,
	}
}

type ProvisionerStorageMethod string

const (
	ProvisionerStorageMethodFile ProvisionerStorageMethod = "file"
)

func (e *ProvisionerStorageMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProvisionerStorageMethod(s)
	case string:
		*e = ProvisionerStorageMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for ProvisionerStorageMethod: %T", src)
	}
	return nil
}

type NullProvisionerStorageMethod struct {
	ProvisionerStorageMethod ProvisionerStorageMethod `json:"provisioner_storage_method"`
	Valid                    bool                     `json:"valid"` // Valid is true if ProvisionerStorageMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProvisionerStorageMethod) Scan(value interface{}) error {
	if value == nil {
		ns.ProvisionerStorageMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProvisionerStorageMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProvisionerStorageMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProvisionerStorageMethod), nil
}

func (e ProvisionerStorageMethod) Valid() bool {
	switch e {
	case ProvisionerStorageMethodFile:
		return true
	}
	return false
}

func AllProvisionerStorageMethodValues() []ProvisionerStorageMethod {
	return []ProvisionerStorageMethod{
		ProvisionerStorageMethodFile,
	}
}

type ProvisionerType string

const (
	ProvisionerTypeEcho      ProvisionerType = "echo"
	ProvisionerTypeTerraform ProvisionerType = "terraform"
)

func (e *ProvisionerType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProvisionerType(s)
	case string:
		*e = ProvisionerType(s)
	default:
		return fmt.Errorf("unsupported scan type for ProvisionerType: %T", src)
	}
	return nil
}

type NullProvisionerType struct {
	ProvisionerType ProvisionerType `json:"provisioner_type"`
	Valid           bool            `json:"valid"` // Valid is true if ProvisionerType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProvisionerType) Scan(value interface{}) error {
	if value == nil {
		ns.ProvisionerType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProvisionerType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProvisionerType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProvisionerType), nil
}

func (e ProvisionerType) Valid() bool {
	switch e {
	case ProvisionerTypeEcho,
		ProvisionerTypeTerraform:
		return true
	}
	return false
}

func AllProvisionerTypeValues() []ProvisionerType {
	return []ProvisionerType{
		ProvisionerTypeEcho,
		ProvisionerTypeTerraform,
	}
}

type ResourceType string

const (
	ResourceTypeOrganization    ResourceType = "organization"
	ResourceTypeTemplate        ResourceType = "template"
	ResourceTypeTemplateVersion ResourceType = "template_version"
	ResourceTypeUser            ResourceType = "user"
	ResourceTypeWorkspace       ResourceType = "workspace"
	ResourceTypeGitSshKey       ResourceType = "git_ssh_key"
	ResourceTypeApiKey          ResourceType = "api_key"
	ResourceTypeGroup           ResourceType = "group"
	ResourceTypeWorkspaceBuild  ResourceType = "workspace_build"
	ResourceTypeLicense         ResourceType = "license"
	ResourceTypeWorkspaceProxy  ResourceType = "workspace_proxy"
	ResourceTypeConvertLogin    ResourceType = "convert_login"
)

func (e *ResourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ResourceType(s)
	case string:
		*e = ResourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for ResourceType: %T", src)
	}
	return nil
}

type NullResourceType struct {
	ResourceType ResourceType `json:"resource_type"`
	Valid        bool         `json:"valid"` // Valid is true if ResourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullResourceType) Scan(value interface{}) error {
	if value == nil {
		ns.ResourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ResourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullResourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ResourceType), nil
}

func (e ResourceType) Valid() bool {
	switch e {
	case ResourceTypeOrganization,
		ResourceTypeTemplate,
		ResourceTypeTemplateVersion,
		ResourceTypeUser,
		ResourceTypeWorkspace,
		ResourceTypeGitSshKey,
		ResourceTypeApiKey,
		ResourceTypeGroup,
		ResourceTypeWorkspaceBuild,
		ResourceTypeLicense,
		ResourceTypeWorkspaceProxy,
		ResourceTypeConvertLogin:
		return true
	}
	return false
}

func AllResourceTypeValues() []ResourceType {
	return []ResourceType{
		ResourceTypeOrganization,
		ResourceTypeTemplate,
		ResourceTypeTemplateVersion,
		ResourceTypeUser,
		ResourceTypeWorkspace,
		ResourceTypeGitSshKey,
		ResourceTypeApiKey,
		ResourceTypeGroup,
		ResourceTypeWorkspaceBuild,
		ResourceTypeLicense,
		ResourceTypeWorkspaceProxy,
		ResourceTypeConvertLogin,
	}
}

type StartupScriptBehavior string

const (
	StartupScriptBehaviorBlocking    StartupScriptBehavior = "blocking"
	StartupScriptBehaviorNonBlocking StartupScriptBehavior = "non-blocking"
)

func (e *StartupScriptBehavior) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StartupScriptBehavior(s)
	case string:
		*e = StartupScriptBehavior(s)
	default:
		return fmt.Errorf("unsupported scan type for StartupScriptBehavior: %T", src)
	}
	return nil
}

type NullStartupScriptBehavior struct {
	StartupScriptBehavior StartupScriptBehavior `json:"startup_script_behavior"`
	Valid                 bool                  `json:"valid"` // Valid is true if StartupScriptBehavior is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStartupScriptBehavior) Scan(value interface{}) error {
	if value == nil {
		ns.StartupScriptBehavior, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StartupScriptBehavior.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStartupScriptBehavior) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StartupScriptBehavior), nil
}

func (e StartupScriptBehavior) Valid() bool {
	switch e {
	case StartupScriptBehaviorBlocking,
		StartupScriptBehaviorNonBlocking:
		return true
	}
	return false
}

func AllStartupScriptBehaviorValues() []StartupScriptBehavior {
	return []StartupScriptBehavior{
		StartupScriptBehaviorBlocking,
		StartupScriptBehaviorNonBlocking,
	}
}

// Defines the user status: active, dormant, or suspended.
type UserStatus string

const (
	UserStatusActive    UserStatus = "active"
	UserStatusSuspended UserStatus = "suspended"
	UserStatusDormant   UserStatus = "dormant"
)

func (e *UserStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserStatus(s)
	case string:
		*e = UserStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UserStatus: %T", src)
	}
	return nil
}

type NullUserStatus struct {
	UserStatus UserStatus `json:"user_status"`
	Valid      bool       `json:"valid"` // Valid is true if UserStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UserStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserStatus), nil
}

func (e UserStatus) Valid() bool {
	switch e {
	case UserStatusActive,
		UserStatusSuspended,
		UserStatusDormant:
		return true
	}
	return false
}

func AllUserStatusValues() []UserStatus {
	return []UserStatus{
		UserStatusActive,
		UserStatusSuspended,
		UserStatusDormant,
	}
}

type WorkspaceAgentLifecycleState string

const (
	WorkspaceAgentLifecycleStateCreated         WorkspaceAgentLifecycleState = "created"
	WorkspaceAgentLifecycleStateStarting        WorkspaceAgentLifecycleState = "starting"
	WorkspaceAgentLifecycleStateStartTimeout    WorkspaceAgentLifecycleState = "start_timeout"
	WorkspaceAgentLifecycleStateStartError      WorkspaceAgentLifecycleState = "start_error"
	WorkspaceAgentLifecycleStateReady           WorkspaceAgentLifecycleState = "ready"
	WorkspaceAgentLifecycleStateShuttingDown    WorkspaceAgentLifecycleState = "shutting_down"
	WorkspaceAgentLifecycleStateShutdownTimeout WorkspaceAgentLifecycleState = "shutdown_timeout"
	WorkspaceAgentLifecycleStateShutdownError   WorkspaceAgentLifecycleState = "shutdown_error"
	WorkspaceAgentLifecycleStateOff             WorkspaceAgentLifecycleState = "off"
)

func (e *WorkspaceAgentLifecycleState) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkspaceAgentLifecycleState(s)
	case string:
		*e = WorkspaceAgentLifecycleState(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkspaceAgentLifecycleState: %T", src)
	}
	return nil
}

type NullWorkspaceAgentLifecycleState struct {
	WorkspaceAgentLifecycleState WorkspaceAgentLifecycleState `json:"workspace_agent_lifecycle_state"`
	Valid                        bool                         `json:"valid"` // Valid is true if WorkspaceAgentLifecycleState is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkspaceAgentLifecycleState) Scan(value interface{}) error {
	if value == nil {
		ns.WorkspaceAgentLifecycleState, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkspaceAgentLifecycleState.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkspaceAgentLifecycleState) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkspaceAgentLifecycleState), nil
}

func (e WorkspaceAgentLifecycleState) Valid() bool {
	switch e {
	case WorkspaceAgentLifecycleStateCreated,
		WorkspaceAgentLifecycleStateStarting,
		WorkspaceAgentLifecycleStateStartTimeout,
		WorkspaceAgentLifecycleStateStartError,
		WorkspaceAgentLifecycleStateReady,
		WorkspaceAgentLifecycleStateShuttingDown,
		WorkspaceAgentLifecycleStateShutdownTimeout,
		WorkspaceAgentLifecycleStateShutdownError,
		WorkspaceAgentLifecycleStateOff:
		return true
	}
	return false
}

func AllWorkspaceAgentLifecycleStateValues() []WorkspaceAgentLifecycleState {
	return []WorkspaceAgentLifecycleState{
		WorkspaceAgentLifecycleStateCreated,
		WorkspaceAgentLifecycleStateStarting,
		WorkspaceAgentLifecycleStateStartTimeout,
		WorkspaceAgentLifecycleStateStartError,
		WorkspaceAgentLifecycleStateReady,
		WorkspaceAgentLifecycleStateShuttingDown,
		WorkspaceAgentLifecycleStateShutdownTimeout,
		WorkspaceAgentLifecycleStateShutdownError,
		WorkspaceAgentLifecycleStateOff,
	}
}

type WorkspaceAgentLogSource string

const (
	WorkspaceAgentLogSourceStartupScript  WorkspaceAgentLogSource = "startup_script"
	WorkspaceAgentLogSourceShutdownScript WorkspaceAgentLogSource = "shutdown_script"
	WorkspaceAgentLogSourceKubernetesLogs WorkspaceAgentLogSource = "kubernetes_logs"
	WorkspaceAgentLogSourceEnvbox         WorkspaceAgentLogSource = "envbox"
	WorkspaceAgentLogSourceEnvbuilder     WorkspaceAgentLogSource = "envbuilder"
	WorkspaceAgentLogSourceExternal       WorkspaceAgentLogSource = "external"
)

func (e *WorkspaceAgentLogSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkspaceAgentLogSource(s)
	case string:
		*e = WorkspaceAgentLogSource(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkspaceAgentLogSource: %T", src)
	}
	return nil
}

type NullWorkspaceAgentLogSource struct {
	WorkspaceAgentLogSource WorkspaceAgentLogSource `json:"workspace_agent_log_source"`
	Valid                   bool                    `json:"valid"` // Valid is true if WorkspaceAgentLogSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkspaceAgentLogSource) Scan(value interface{}) error {
	if value == nil {
		ns.WorkspaceAgentLogSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkspaceAgentLogSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkspaceAgentLogSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkspaceAgentLogSource), nil
}

func (e WorkspaceAgentLogSource) Valid() bool {
	switch e {
	case WorkspaceAgentLogSourceStartupScript,
		WorkspaceAgentLogSourceShutdownScript,
		WorkspaceAgentLogSourceKubernetesLogs,
		WorkspaceAgentLogSourceEnvbox,
		WorkspaceAgentLogSourceEnvbuilder,
		WorkspaceAgentLogSourceExternal:
		return true
	}
	return false
}

func AllWorkspaceAgentLogSourceValues() []WorkspaceAgentLogSource {
	return []WorkspaceAgentLogSource{
		WorkspaceAgentLogSourceStartupScript,
		WorkspaceAgentLogSourceShutdownScript,
		WorkspaceAgentLogSourceKubernetesLogs,
		WorkspaceAgentLogSourceEnvbox,
		WorkspaceAgentLogSourceEnvbuilder,
		WorkspaceAgentLogSourceExternal,
	}
}

type WorkspaceAgentSubsystem string

const (
	WorkspaceAgentSubsystemEnvbuilder WorkspaceAgentSubsystem = "envbuilder"
	WorkspaceAgentSubsystemEnvbox     WorkspaceAgentSubsystem = "envbox"
	WorkspaceAgentSubsystemNone       WorkspaceAgentSubsystem = "none"
	WorkspaceAgentSubsystemExectrace  WorkspaceAgentSubsystem = "exectrace"
)

func (e *WorkspaceAgentSubsystem) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkspaceAgentSubsystem(s)
	case string:
		*e = WorkspaceAgentSubsystem(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkspaceAgentSubsystem: %T", src)
	}
	return nil
}

type NullWorkspaceAgentSubsystem struct {
	WorkspaceAgentSubsystem WorkspaceAgentSubsystem `json:"workspace_agent_subsystem"`
	Valid                   bool                    `json:"valid"` // Valid is true if WorkspaceAgentSubsystem is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkspaceAgentSubsystem) Scan(value interface{}) error {
	if value == nil {
		ns.WorkspaceAgentSubsystem, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkspaceAgentSubsystem.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkspaceAgentSubsystem) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkspaceAgentSubsystem), nil
}

func (e WorkspaceAgentSubsystem) Valid() bool {
	switch e {
	case WorkspaceAgentSubsystemEnvbuilder,
		WorkspaceAgentSubsystemEnvbox,
		WorkspaceAgentSubsystemNone,
		WorkspaceAgentSubsystemExectrace:
		return true
	}
	return false
}

func AllWorkspaceAgentSubsystemValues() []WorkspaceAgentSubsystem {
	return []WorkspaceAgentSubsystem{
		WorkspaceAgentSubsystemEnvbuilder,
		WorkspaceAgentSubsystemEnvbox,
		WorkspaceAgentSubsystemNone,
		WorkspaceAgentSubsystemExectrace,
	}
}

type WorkspaceAppHealth string

const (
	WorkspaceAppHealthDisabled     WorkspaceAppHealth = "disabled"
	WorkspaceAppHealthInitializing WorkspaceAppHealth = "initializing"
	WorkspaceAppHealthHealthy      WorkspaceAppHealth = "healthy"
	WorkspaceAppHealthUnhealthy    WorkspaceAppHealth = "unhealthy"
)

func (e *WorkspaceAppHealth) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkspaceAppHealth(s)
	case string:
		*e = WorkspaceAppHealth(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkspaceAppHealth: %T", src)
	}
	return nil
}

type NullWorkspaceAppHealth struct {
	WorkspaceAppHealth WorkspaceAppHealth `json:"workspace_app_health"`
	Valid              bool               `json:"valid"` // Valid is true if WorkspaceAppHealth is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkspaceAppHealth) Scan(value interface{}) error {
	if value == nil {
		ns.WorkspaceAppHealth, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkspaceAppHealth.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkspaceAppHealth) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkspaceAppHealth), nil
}

func (e WorkspaceAppHealth) Valid() bool {
	switch e {
	case WorkspaceAppHealthDisabled,
		WorkspaceAppHealthInitializing,
		WorkspaceAppHealthHealthy,
		WorkspaceAppHealthUnhealthy:
		return true
	}
	return false
}

func AllWorkspaceAppHealthValues() []WorkspaceAppHealth {
	return []WorkspaceAppHealth{
		WorkspaceAppHealthDisabled,
		WorkspaceAppHealthInitializing,
		WorkspaceAppHealthHealthy,
		WorkspaceAppHealthUnhealthy,
	}
}

type WorkspaceTransition string

const (
	WorkspaceTransitionStart  WorkspaceTransition = "start"
	WorkspaceTransitionStop   WorkspaceTransition = "stop"
	WorkspaceTransitionDelete WorkspaceTransition = "delete"
)

func (e *WorkspaceTransition) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkspaceTransition(s)
	case string:
		*e = WorkspaceTransition(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkspaceTransition: %T", src)
	}
	return nil
}

type NullWorkspaceTransition struct {
	WorkspaceTransition WorkspaceTransition `json:"workspace_transition"`
	Valid               bool                `json:"valid"` // Valid is true if WorkspaceTransition is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkspaceTransition) Scan(value interface{}) error {
	if value == nil {
		ns.WorkspaceTransition, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkspaceTransition.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkspaceTransition) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkspaceTransition), nil
}

func (e WorkspaceTransition) Valid() bool {
	switch e {
	case WorkspaceTransitionStart,
		WorkspaceTransitionStop,
		WorkspaceTransitionDelete:
		return true
	}
	return false
}

func AllWorkspaceTransitionValues() []WorkspaceTransition {
	return []WorkspaceTransition{
		WorkspaceTransitionStart,
		WorkspaceTransitionStop,
		WorkspaceTransitionDelete,
	}
}

type APIKey struct {
	ID string `db:"id" json:"id"`
	// hashed_secret contains a SHA256 hash of the key secret. This is considered a secret and MUST NOT be returned from the API as it is used for API key encryption in app proxying code.
	HashedSecret    []byte      `db:"hashed_secret" json:"hashed_secret"`
	UserID          uuid.UUID   `db:"user_id" json:"user_id"`
	LastUsed        time.Time   `db:"last_used" json:"last_used"`
	ExpiresAt       time.Time   `db:"expires_at" json:"expires_at"`
	CreatedAt       time.Time   `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time   `db:"updated_at" json:"updated_at"`
	LoginType       LoginType   `db:"login_type" json:"login_type"`
	LifetimeSeconds int64       `db:"lifetime_seconds" json:"lifetime_seconds"`
	IPAddress       pqtype.Inet `db:"ip_address" json:"ip_address"`
	Scope           APIKeyScope `db:"scope" json:"scope"`
	TokenName       string      `db:"token_name" json:"token_name"`
}

type AuditLog struct {
	ID               uuid.UUID       `db:"id" json:"id"`
	Time             time.Time       `db:"time" json:"time"`
	UserID           uuid.UUID       `db:"user_id" json:"user_id"`
	OrganizationID   uuid.UUID       `db:"organization_id" json:"organization_id"`
	Ip               pqtype.Inet     `db:"ip" json:"ip"`
	UserAgent        sql.NullString  `db:"user_agent" json:"user_agent"`
	ResourceType     ResourceType    `db:"resource_type" json:"resource_type"`
	ResourceID       uuid.UUID       `db:"resource_id" json:"resource_id"`
	ResourceTarget   string          `db:"resource_target" json:"resource_target"`
	Action           AuditAction     `db:"action" json:"action"`
	Diff             json.RawMessage `db:"diff" json:"diff"`
	StatusCode       int32           `db:"status_code" json:"status_code"`
	AdditionalFields json.RawMessage `db:"additional_fields" json:"additional_fields"`
	RequestID        uuid.UUID       `db:"request_id" json:"request_id"`
	ResourceIcon     string          `db:"resource_icon" json:"resource_icon"`
}

type File struct {
	Hash      string    `db:"hash" json:"hash"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	CreatedBy uuid.UUID `db:"created_by" json:"created_by"`
	Mimetype  string    `db:"mimetype" json:"mimetype"`
	Data      []byte    `db:"data" json:"data"`
	ID        uuid.UUID `db:"id" json:"id"`
}

type GitAuthLink struct {
	ProviderID        string    `db:"provider_id" json:"provider_id"`
	UserID            uuid.UUID `db:"user_id" json:"user_id"`
	CreatedAt         time.Time `db:"created_at" json:"created_at"`
	UpdatedAt         time.Time `db:"updated_at" json:"updated_at"`
	OAuthAccessToken  string    `db:"oauth_access_token" json:"oauth_access_token"`
	OAuthRefreshToken string    `db:"oauth_refresh_token" json:"oauth_refresh_token"`
	OAuthExpiry       time.Time `db:"oauth_expiry" json:"oauth_expiry"`
}

type GitSSHKey struct {
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	CreatedAt  time.Time `db:"created_at" json:"created_at"`
	UpdatedAt  time.Time `db:"updated_at" json:"updated_at"`
	PrivateKey string    `db:"private_key" json:"private_key"`
	PublicKey  string    `db:"public_key" json:"public_key"`
}

type Group struct {
	ID             uuid.UUID `db:"id" json:"id"`
	Name           string    `db:"name" json:"name"`
	OrganizationID uuid.UUID `db:"organization_id" json:"organization_id"`
	AvatarURL      string    `db:"avatar_url" json:"avatar_url"`
	QuotaAllowance int32     `db:"quota_allowance" json:"quota_allowance"`
	// Display name is a custom, human-friendly group name that user can set. This is not required to be unique and can be the empty string.
	DisplayName string `db:"display_name" json:"display_name"`
	// Source indicates how the group was created. It can be created by a user manually, or through some system process like OIDC group sync.
	Source GroupSource `db:"source" json:"source"`
}

type GroupMember struct {
	UserID  uuid.UUID `db:"user_id" json:"user_id"`
	GroupID uuid.UUID `db:"group_id" json:"group_id"`
}

type License struct {
	ID         int32     `db:"id" json:"id"`
	UploadedAt time.Time `db:"uploaded_at" json:"uploaded_at"`
	JWT        string    `db:"jwt" json:"jwt"`
	// exp tracks the claim of the same name in the JWT, and we include it here so that we can easily query for licenses that have not yet expired.
	Exp  time.Time `db:"exp" json:"exp"`
	UUID uuid.UUID `db:"uuid" json:"uuid"`
}

type Organization struct {
	ID          uuid.UUID `db:"id" json:"id"`
	Name        string    `db:"name" json:"name"`
	Description string    `db:"description" json:"description"`
	CreatedAt   time.Time `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time `db:"updated_at" json:"updated_at"`
}

type OrganizationMember struct {
	UserID         uuid.UUID `db:"user_id" json:"user_id"`
	OrganizationID uuid.UUID `db:"organization_id" json:"organization_id"`
	CreatedAt      time.Time `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time `db:"updated_at" json:"updated_at"`
	Roles          []string  `db:"roles" json:"roles"`
}

type ParameterSchema struct {
	ID                       uuid.UUID                  `db:"id" json:"id"`
	CreatedAt                time.Time                  `db:"created_at" json:"created_at"`
	JobID                    uuid.UUID                  `db:"job_id" json:"job_id"`
	Name                     string                     `db:"name" json:"name"`
	Description              string                     `db:"description" json:"description"`
	DefaultSourceScheme      ParameterSourceScheme      `db:"default_source_scheme" json:"default_source_scheme"`
	DefaultSourceValue       string                     `db:"default_source_value" json:"default_source_value"`
	AllowOverrideSource      bool                       `db:"allow_override_source" json:"allow_override_source"`
	DefaultDestinationScheme ParameterDestinationScheme `db:"default_destination_scheme" json:"default_destination_scheme"`
	AllowOverrideDestination bool                       `db:"allow_override_destination" json:"allow_override_destination"`
	DefaultRefresh           string                     `db:"default_refresh" json:"default_refresh"`
	RedisplayValue           bool                       `db:"redisplay_value" json:"redisplay_value"`
	ValidationError          string                     `db:"validation_error" json:"validation_error"`
	ValidationCondition      string                     `db:"validation_condition" json:"validation_condition"`
	ValidationTypeSystem     ParameterTypeSystem        `db:"validation_type_system" json:"validation_type_system"`
	ValidationValueType      string                     `db:"validation_value_type" json:"validation_value_type"`
	Index                    int32                      `db:"index" json:"index"`
}

type ParameterValue struct {
	ID                uuid.UUID                  `db:"id" json:"id"`
	CreatedAt         time.Time                  `db:"created_at" json:"created_at"`
	UpdatedAt         time.Time                  `db:"updated_at" json:"updated_at"`
	Scope             ParameterScope             `db:"scope" json:"scope"`
	ScopeID           uuid.UUID                  `db:"scope_id" json:"scope_id"`
	Name              string                     `db:"name" json:"name"`
	SourceScheme      ParameterSourceScheme      `db:"source_scheme" json:"source_scheme"`
	SourceValue       string                     `db:"source_value" json:"source_value"`
	DestinationScheme ParameterDestinationScheme `db:"destination_scheme" json:"destination_scheme"`
}

type ProvisionerDaemon struct {
	ID           uuid.UUID         `db:"id" json:"id"`
	CreatedAt    time.Time         `db:"created_at" json:"created_at"`
	UpdatedAt    sql.NullTime      `db:"updated_at" json:"updated_at"`
	Name         string            `db:"name" json:"name"`
	Provisioners []ProvisionerType `db:"provisioners" json:"provisioners"`
	ReplicaID    uuid.NullUUID     `db:"replica_id" json:"replica_id"`
	Tags         StringMap         `db:"tags" json:"tags"`
}

type ProvisionerJob struct {
	ID             uuid.UUID                `db:"id" json:"id"`
	CreatedAt      time.Time                `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time                `db:"updated_at" json:"updated_at"`
	StartedAt      sql.NullTime             `db:"started_at" json:"started_at"`
	CanceledAt     sql.NullTime             `db:"canceled_at" json:"canceled_at"`
	CompletedAt    sql.NullTime             `db:"completed_at" json:"completed_at"`
	Error          sql.NullString           `db:"error" json:"error"`
	OrganizationID uuid.UUID                `db:"organization_id" json:"organization_id"`
	InitiatorID    uuid.UUID                `db:"initiator_id" json:"initiator_id"`
	Provisioner    ProvisionerType          `db:"provisioner" json:"provisioner"`
	StorageMethod  ProvisionerStorageMethod `db:"storage_method" json:"storage_method"`
	Type           ProvisionerJobType       `db:"type" json:"type"`
	Input          json.RawMessage          `db:"input" json:"input"`
	WorkerID       uuid.NullUUID            `db:"worker_id" json:"worker_id"`
	FileID         uuid.UUID                `db:"file_id" json:"file_id"`
	Tags           StringMap                `db:"tags" json:"tags"`
	ErrorCode      sql.NullString           `db:"error_code" json:"error_code"`
	TraceMetadata  pqtype.NullRawMessage    `db:"trace_metadata" json:"trace_metadata"`
}

type ProvisionerJobLog struct {
	JobID     uuid.UUID `db:"job_id" json:"job_id"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	Source    LogSource `db:"source" json:"source"`
	Level     LogLevel  `db:"level" json:"level"`
	Stage     string    `db:"stage" json:"stage"`
	Output    string    `db:"output" json:"output"`
	ID        int64     `db:"id" json:"id"`
}

type Replica struct {
	ID              uuid.UUID    `db:"id" json:"id"`
	CreatedAt       time.Time    `db:"created_at" json:"created_at"`
	StartedAt       time.Time    `db:"started_at" json:"started_at"`
	StoppedAt       sql.NullTime `db:"stopped_at" json:"stopped_at"`
	UpdatedAt       time.Time    `db:"updated_at" json:"updated_at"`
	Hostname        string       `db:"hostname" json:"hostname"`
	RegionID        int32        `db:"region_id" json:"region_id"`
	RelayAddress    string       `db:"relay_address" json:"relay_address"`
	DatabaseLatency int32        `db:"database_latency" json:"database_latency"`
	Version         string       `db:"version" json:"version"`
	Error           string       `db:"error" json:"error"`
	Primary         bool         `db:"primary" json:"primary"`
}

type SiteConfig struct {
	Key   string `db:"key" json:"key"`
	Value string `db:"value" json:"value"`
}

type TailnetAgent struct {
	ID            uuid.UUID       `db:"id" json:"id"`
	CoordinatorID uuid.UUID       `db:"coordinator_id" json:"coordinator_id"`
	UpdatedAt     time.Time       `db:"updated_at" json:"updated_at"`
	Node          json.RawMessage `db:"node" json:"node"`
}

type TailnetClient struct {
	ID            uuid.UUID       `db:"id" json:"id"`
	CoordinatorID uuid.UUID       `db:"coordinator_id" json:"coordinator_id"`
	AgentID       uuid.UUID       `db:"agent_id" json:"agent_id"`
	UpdatedAt     time.Time       `db:"updated_at" json:"updated_at"`
	Node          json.RawMessage `db:"node" json:"node"`
}

// We keep this separate from replicas in case we need to break the coordinator out into its own service
type TailnetCoordinator struct {
	ID          uuid.UUID `db:"id" json:"id"`
	HeartbeatAt time.Time `db:"heartbeat_at" json:"heartbeat_at"`
}

// Joins in the username + avatar url of the created by user.
type Template struct {
	ID                           uuid.UUID       `db:"id" json:"id"`
	CreatedAt                    time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt                    time.Time       `db:"updated_at" json:"updated_at"`
	OrganizationID               uuid.UUID       `db:"organization_id" json:"organization_id"`
	Deleted                      bool            `db:"deleted" json:"deleted"`
	Name                         string          `db:"name" json:"name"`
	Provisioner                  ProvisionerType `db:"provisioner" json:"provisioner"`
	ActiveVersionID              uuid.UUID       `db:"active_version_id" json:"active_version_id"`
	Description                  string          `db:"description" json:"description"`
	DefaultTTL                   int64           `db:"default_ttl" json:"default_ttl"`
	CreatedBy                    uuid.UUID       `db:"created_by" json:"created_by"`
	Icon                         string          `db:"icon" json:"icon"`
	UserACL                      TemplateACL     `db:"user_acl" json:"user_acl"`
	GroupACL                     TemplateACL     `db:"group_acl" json:"group_acl"`
	DisplayName                  string          `db:"display_name" json:"display_name"`
	AllowUserCancelWorkspaceJobs bool            `db:"allow_user_cancel_workspace_jobs" json:"allow_user_cancel_workspace_jobs"`
	MaxTTL                       int64           `db:"max_ttl" json:"max_ttl"`
	AllowUserAutostart           bool            `db:"allow_user_autostart" json:"allow_user_autostart"`
	AllowUserAutostop            bool            `db:"allow_user_autostop" json:"allow_user_autostop"`
	FailureTTL                   int64           `db:"failure_ttl" json:"failure_ttl"`
	InactivityTTL                int64           `db:"inactivity_ttl" json:"inactivity_ttl"`
	LockedTTL                    int64           `db:"locked_ttl" json:"locked_ttl"`
	RestartRequirementDaysOfWeek int16           `db:"restart_requirement_days_of_week" json:"restart_requirement_days_of_week"`
	RestartRequirementWeeks      int64           `db:"restart_requirement_weeks" json:"restart_requirement_weeks"`
	CreatedByAvatarURL           sql.NullString  `db:"created_by_avatar_url" json:"created_by_avatar_url"`
	CreatedByUsername            string          `db:"created_by_username" json:"created_by_username"`
}

type TemplateTable struct {
	ID              uuid.UUID       `db:"id" json:"id"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	OrganizationID  uuid.UUID       `db:"organization_id" json:"organization_id"`
	Deleted         bool            `db:"deleted" json:"deleted"`
	Name            string          `db:"name" json:"name"`
	Provisioner     ProvisionerType `db:"provisioner" json:"provisioner"`
	ActiveVersionID uuid.UUID       `db:"active_version_id" json:"active_version_id"`
	Description     string          `db:"description" json:"description"`
	// The default duration for autostop for workspaces created from this template.
	DefaultTTL int64       `db:"default_ttl" json:"default_ttl"`
	CreatedBy  uuid.UUID   `db:"created_by" json:"created_by"`
	Icon       string      `db:"icon" json:"icon"`
	UserACL    TemplateACL `db:"user_acl" json:"user_acl"`
	GroupACL   TemplateACL `db:"group_acl" json:"group_acl"`
	// Display name is a custom, human-friendly template name that user can set.
	DisplayName string `db:"display_name" json:"display_name"`
	// Allow users to cancel in-progress workspace jobs.
	AllowUserCancelWorkspaceJobs bool  `db:"allow_user_cancel_workspace_jobs" json:"allow_user_cancel_workspace_jobs"`
	MaxTTL                       int64 `db:"max_ttl" json:"max_ttl"`
	// Allow users to specify an autostart schedule for workspaces (enterprise).
	AllowUserAutostart bool `db:"allow_user_autostart" json:"allow_user_autostart"`
	// Allow users to specify custom autostop values for workspaces (enterprise).
	AllowUserAutostop bool  `db:"allow_user_autostop" json:"allow_user_autostop"`
	FailureTTL        int64 `db:"failure_ttl" json:"failure_ttl"`
	InactivityTTL     int64 `db:"inactivity_ttl" json:"inactivity_ttl"`
	LockedTTL         int64 `db:"locked_ttl" json:"locked_ttl"`
	// A bitmap of days of week to restart the workspace on, starting with Monday as the 0th bit, and Sunday as the 6th bit. The 7th bit is unused.
	RestartRequirementDaysOfWeek int16 `db:"restart_requirement_days_of_week" json:"restart_requirement_days_of_week"`
	// The number of weeks between restarts. 0 or 1 weeks means "every week", 2 week means "every second week", etc. Weeks are counted from January 2, 2023, which is the first Monday of 2023. This is to ensure workspaces are started consistently for all customers on the same n-week cycles.
	RestartRequirementWeeks int64 `db:"restart_requirement_weeks" json:"restart_requirement_weeks"`
}

// Joins in the username + avatar url of the created by user.
type TemplateVersion struct {
	ID                 uuid.UUID      `db:"id" json:"id"`
	TemplateID         uuid.NullUUID  `db:"template_id" json:"template_id"`
	OrganizationID     uuid.UUID      `db:"organization_id" json:"organization_id"`
	CreatedAt          time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt          time.Time      `db:"updated_at" json:"updated_at"`
	Name               string         `db:"name" json:"name"`
	Readme             string         `db:"readme" json:"readme"`
	JobID              uuid.UUID      `db:"job_id" json:"job_id"`
	CreatedBy          uuid.UUID      `db:"created_by" json:"created_by"`
	GitAuthProviders   []string       `db:"git_auth_providers" json:"git_auth_providers"`
	Message            string         `db:"message" json:"message"`
	CreatedByAvatarURL sql.NullString `db:"created_by_avatar_url" json:"created_by_avatar_url"`
	CreatedByUsername  string         `db:"created_by_username" json:"created_by_username"`
}

type TemplateVersionParameter struct {
	TemplateVersionID uuid.UUID `db:"template_version_id" json:"template_version_id"`
	// Parameter name
	Name string `db:"name" json:"name"`
	// Parameter description
	Description string `db:"description" json:"description"`
	// Parameter type
	Type string `db:"type" json:"type"`
	// Is parameter mutable?
	Mutable bool `db:"mutable" json:"mutable"`
	// Default value
	DefaultValue string `db:"default_value" json:"default_value"`
	// Icon
	Icon string `db:"icon" json:"icon"`
	// Additional options
	Options json.RawMessage `db:"options" json:"options"`
	// Validation: regex pattern
	ValidationRegex string `db:"validation_regex" json:"validation_regex"`
	// Validation: minimum length of value
	ValidationMin sql.NullInt32 `db:"validation_min" json:"validation_min"`
	// Validation: maximum length of value
	ValidationMax sql.NullInt32 `db:"validation_max" json:"validation_max"`
	// Validation: error displayed when the regex does not match.
	ValidationError string `db:"validation_error" json:"validation_error"`
	// Validation: consecutive values preserve the monotonic order
	ValidationMonotonic string `db:"validation_monotonic" json:"validation_monotonic"`
	// Is parameter required?
	Required bool `db:"required" json:"required"`
	// Display name of the rich parameter
	DisplayName string `db:"display_name" json:"display_name"`
	// Specifies the order in which to display parameters in user interfaces.
	DisplayOrder int32 `db:"display_order" json:"display_order"`
	// The value of an ephemeral parameter will not be preserved between consecutive workspace builds.
	Ephemeral bool `db:"ephemeral" json:"ephemeral"`
}

type TemplateVersionTable struct {
	ID             uuid.UUID     `db:"id" json:"id"`
	TemplateID     uuid.NullUUID `db:"template_id" json:"template_id"`
	OrganizationID uuid.UUID     `db:"organization_id" json:"organization_id"`
	CreatedAt      time.Time     `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time     `db:"updated_at" json:"updated_at"`
	Name           string        `db:"name" json:"name"`
	Readme         string        `db:"readme" json:"readme"`
	JobID          uuid.UUID     `db:"job_id" json:"job_id"`
	CreatedBy      uuid.UUID     `db:"created_by" json:"created_by"`
	// IDs of Git auth providers for a specific template version
	GitAuthProviders []string `db:"git_auth_providers" json:"git_auth_providers"`
	// Message describing the changes in this version of the template, similar to a Git commit message. Like a commit message, this should be a short, high-level description of the changes in this version of the template. This message is immutable and should not be updated after the fact.
	Message string `db:"message" json:"message"`
}

type TemplateVersionVariable struct {
	TemplateVersionID uuid.UUID `db:"template_version_id" json:"template_version_id"`
	// Variable name
	Name string `db:"name" json:"name"`
	// Variable description
	Description string `db:"description" json:"description"`
	// Variable type
	Type string `db:"type" json:"type"`
	// Variable value
	Value string `db:"value" json:"value"`
	// Variable default value
	DefaultValue string `db:"default_value" json:"default_value"`
	// Required variables needs a default value or a value provided by template admin
	Required bool `db:"required" json:"required"`
	// Sensitive variables have their values redacted in logs or site UI
	Sensitive bool `db:"sensitive" json:"sensitive"`
}

type User struct {
	ID             uuid.UUID      `db:"id" json:"id"`
	Email          string         `db:"email" json:"email"`
	Username       string         `db:"username" json:"username"`
	HashedPassword []byte         `db:"hashed_password" json:"hashed_password"`
	CreatedAt      time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time      `db:"updated_at" json:"updated_at"`
	Status         UserStatus     `db:"status" json:"status"`
	RBACRoles      pq.StringArray `db:"rbac_roles" json:"rbac_roles"`
	LoginType      LoginType      `db:"login_type" json:"login_type"`
	AvatarURL      sql.NullString `db:"avatar_url" json:"avatar_url"`
	Deleted        bool           `db:"deleted" json:"deleted"`
	LastSeenAt     time.Time      `db:"last_seen_at" json:"last_seen_at"`
	// Daily (!) cron schedule (with optional CRON_TZ) signifying the start of the user's quiet hours. If empty, the default quiet hours on the instance is used instead.
	QuietHoursSchedule string `db:"quiet_hours_schedule" json:"quiet_hours_schedule"`
}

type UserLink struct {
	UserID            uuid.UUID `db:"user_id" json:"user_id"`
	LoginType         LoginType `db:"login_type" json:"login_type"`
	LinkedID          string    `db:"linked_id" json:"linked_id"`
	OAuthAccessToken  string    `db:"oauth_access_token" json:"oauth_access_token"`
	OAuthRefreshToken string    `db:"oauth_refresh_token" json:"oauth_refresh_token"`
	OAuthExpiry       time.Time `db:"oauth_expiry" json:"oauth_expiry"`
}

// Visible fields of users are allowed to be joined with other tables for including context of other resources.
type VisibleUser struct {
	ID        uuid.UUID      `db:"id" json:"id"`
	Username  string         `db:"username" json:"username"`
	AvatarURL sql.NullString `db:"avatar_url" json:"avatar_url"`
}

type Workspace struct {
	ID                uuid.UUID      `db:"id" json:"id"`
	CreatedAt         time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt         time.Time      `db:"updated_at" json:"updated_at"`
	OwnerID           uuid.UUID      `db:"owner_id" json:"owner_id"`
	OrganizationID    uuid.UUID      `db:"organization_id" json:"organization_id"`
	TemplateID        uuid.UUID      `db:"template_id" json:"template_id"`
	Deleted           bool           `db:"deleted" json:"deleted"`
	Name              string         `db:"name" json:"name"`
	AutostartSchedule sql.NullString `db:"autostart_schedule" json:"autostart_schedule"`
	Ttl               sql.NullInt64  `db:"ttl" json:"ttl"`
	LastUsedAt        time.Time      `db:"last_used_at" json:"last_used_at"`
	LockedAt          sql.NullTime   `db:"locked_at" json:"locked_at"`
	DeletingAt        sql.NullTime   `db:"deleting_at" json:"deleting_at"`
}

type WorkspaceAgent struct {
	ID                   uuid.UUID             `db:"id" json:"id"`
	CreatedAt            time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt            time.Time             `db:"updated_at" json:"updated_at"`
	Name                 string                `db:"name" json:"name"`
	FirstConnectedAt     sql.NullTime          `db:"first_connected_at" json:"first_connected_at"`
	LastConnectedAt      sql.NullTime          `db:"last_connected_at" json:"last_connected_at"`
	DisconnectedAt       sql.NullTime          `db:"disconnected_at" json:"disconnected_at"`
	ResourceID           uuid.UUID             `db:"resource_id" json:"resource_id"`
	AuthToken            uuid.UUID             `db:"auth_token" json:"auth_token"`
	AuthInstanceID       sql.NullString        `db:"auth_instance_id" json:"auth_instance_id"`
	Architecture         string                `db:"architecture" json:"architecture"`
	EnvironmentVariables pqtype.NullRawMessage `db:"environment_variables" json:"environment_variables"`
	OperatingSystem      string                `db:"operating_system" json:"operating_system"`
	StartupScript        sql.NullString        `db:"startup_script" json:"startup_script"`
	InstanceMetadata     pqtype.NullRawMessage `db:"instance_metadata" json:"instance_metadata"`
	ResourceMetadata     pqtype.NullRawMessage `db:"resource_metadata" json:"resource_metadata"`
	Directory            string                `db:"directory" json:"directory"`
	// Version tracks the version of the currently running workspace agent. Workspace agents register their version upon start.
	Version                string        `db:"version" json:"version"`
	LastConnectedReplicaID uuid.NullUUID `db:"last_connected_replica_id" json:"last_connected_replica_id"`
	// Connection timeout in seconds, 0 means disabled.
	ConnectionTimeoutSeconds int32 `db:"connection_timeout_seconds" json:"connection_timeout_seconds"`
	// URL for troubleshooting the agent.
	TroubleshootingURL string `db:"troubleshooting_url" json:"troubleshooting_url"`
	// Path to file inside workspace containing the message of the day (MOTD) to show to the user when logging in via SSH.
	MOTDFile string `db:"motd_file" json:"motd_file"`
	// The current lifecycle state reported by the workspace agent.
	LifecycleState WorkspaceAgentLifecycleState `db:"lifecycle_state" json:"lifecycle_state"`
	// The number of seconds to wait for the startup script to complete. If the script does not complete within this time, the agent lifecycle will be marked as start_timeout.
	StartupScriptTimeoutSeconds int32 `db:"startup_script_timeout_seconds" json:"startup_script_timeout_seconds"`
	// The resolved path of a user-specified directory. e.g. ~/coder -> /home/coder/coder
	ExpandedDirectory string `db:"expanded_directory" json:"expanded_directory"`
	// Script that is executed before the agent is stopped.
	ShutdownScript sql.NullString `db:"shutdown_script" json:"shutdown_script"`
	// The number of seconds to wait for the shutdown script to complete. If the script does not complete within this time, the agent lifecycle will be marked as shutdown_timeout.
	ShutdownScriptTimeoutSeconds int32 `db:"shutdown_script_timeout_seconds" json:"shutdown_script_timeout_seconds"`
	// Total length of startup logs
	LogsLength int32 `db:"logs_length" json:"logs_length"`
	// Whether the startup logs overflowed in length
	LogsOverflowed bool `db:"logs_overflowed" json:"logs_overflowed"`
	// When startup script behavior is non-blocking, the workspace will be ready and accessible upon agent connection, when it is blocking, workspace will wait for the startup script to complete before becoming ready and accessible.
	StartupScriptBehavior StartupScriptBehavior `db:"startup_script_behavior" json:"startup_script_behavior"`
	// The time the agent entered the starting lifecycle state
	StartedAt sql.NullTime `db:"started_at" json:"started_at"`
	// The time the agent entered the ready or start_error lifecycle state
	ReadyAt    sql.NullTime              `db:"ready_at" json:"ready_at"`
	Subsystems []WorkspaceAgentSubsystem `db:"subsystems" json:"subsystems"`
}

type WorkspaceAgentLog struct {
	AgentID   uuid.UUID               `db:"agent_id" json:"agent_id"`
	CreatedAt time.Time               `db:"created_at" json:"created_at"`
	Output    string                  `db:"output" json:"output"`
	ID        int64                   `db:"id" json:"id"`
	Level     LogLevel                `db:"level" json:"level"`
	Source    WorkspaceAgentLogSource `db:"source" json:"source"`
}

type WorkspaceAgentMetadatum struct {
	WorkspaceAgentID uuid.UUID `db:"workspace_agent_id" json:"workspace_agent_id"`
	DisplayName      string    `db:"display_name" json:"display_name"`
	Key              string    `db:"key" json:"key"`
	Script           string    `db:"script" json:"script"`
	Value            string    `db:"value" json:"value"`
	Error            string    `db:"error" json:"error"`
	Timeout          int64     `db:"timeout" json:"timeout"`
	Interval         int64     `db:"interval" json:"interval"`
	CollectedAt      time.Time `db:"collected_at" json:"collected_at"`
}

type WorkspaceAgentStat struct {
	ID                          uuid.UUID       `db:"id" json:"id"`
	CreatedAt                   time.Time       `db:"created_at" json:"created_at"`
	UserID                      uuid.UUID       `db:"user_id" json:"user_id"`
	AgentID                     uuid.UUID       `db:"agent_id" json:"agent_id"`
	WorkspaceID                 uuid.UUID       `db:"workspace_id" json:"workspace_id"`
	TemplateID                  uuid.UUID       `db:"template_id" json:"template_id"`
	ConnectionsByProto          json.RawMessage `db:"connections_by_proto" json:"connections_by_proto"`
	ConnectionCount             int64           `db:"connection_count" json:"connection_count"`
	RxPackets                   int64           `db:"rx_packets" json:"rx_packets"`
	RxBytes                     int64           `db:"rx_bytes" json:"rx_bytes"`
	TxPackets                   int64           `db:"tx_packets" json:"tx_packets"`
	TxBytes                     int64           `db:"tx_bytes" json:"tx_bytes"`
	ConnectionMedianLatencyMS   float64         `db:"connection_median_latency_ms" json:"connection_median_latency_ms"`
	SessionCountVSCode          int64           `db:"session_count_vscode" json:"session_count_vscode"`
	SessionCountJetBrains       int64           `db:"session_count_jetbrains" json:"session_count_jetbrains"`
	SessionCountReconnectingPTY int64           `db:"session_count_reconnecting_pty" json:"session_count_reconnecting_pty"`
	SessionCountSSH             int64           `db:"session_count_ssh" json:"session_count_ssh"`
}

type WorkspaceApp struct {
	ID                   uuid.UUID          `db:"id" json:"id"`
	CreatedAt            time.Time          `db:"created_at" json:"created_at"`
	AgentID              uuid.UUID          `db:"agent_id" json:"agent_id"`
	DisplayName          string             `db:"display_name" json:"display_name"`
	Icon                 string             `db:"icon" json:"icon"`
	Command              sql.NullString     `db:"command" json:"command"`
	Url                  sql.NullString     `db:"url" json:"url"`
	HealthcheckUrl       string             `db:"healthcheck_url" json:"healthcheck_url"`
	HealthcheckInterval  int32              `db:"healthcheck_interval" json:"healthcheck_interval"`
	HealthcheckThreshold int32              `db:"healthcheck_threshold" json:"healthcheck_threshold"`
	Health               WorkspaceAppHealth `db:"health" json:"health"`
	Subdomain            bool               `db:"subdomain" json:"subdomain"`
	SharingLevel         AppSharingLevel    `db:"sharing_level" json:"sharing_level"`
	Slug                 string             `db:"slug" json:"slug"`
	External             bool               `db:"external" json:"external"`
}

// Joins in the username + avatar url of the initiated by user.
type WorkspaceBuild struct {
	ID                   uuid.UUID           `db:"id" json:"id"`
	CreatedAt            time.Time           `db:"created_at" json:"created_at"`
	UpdatedAt            time.Time           `db:"updated_at" json:"updated_at"`
	WorkspaceID          uuid.UUID           `db:"workspace_id" json:"workspace_id"`
	TemplateVersionID    uuid.UUID           `db:"template_version_id" json:"template_version_id"`
	BuildNumber          int32               `db:"build_number" json:"build_number"`
	Transition           WorkspaceTransition `db:"transition" json:"transition"`
	InitiatorID          uuid.UUID           `db:"initiator_id" json:"initiator_id"`
	ProvisionerState     []byte              `db:"provisioner_state" json:"provisioner_state"`
	JobID                uuid.UUID           `db:"job_id" json:"job_id"`
	Deadline             time.Time           `db:"deadline" json:"deadline"`
	Reason               BuildReason         `db:"reason" json:"reason"`
	DailyCost            int32               `db:"daily_cost" json:"daily_cost"`
	MaxDeadline          time.Time           `db:"max_deadline" json:"max_deadline"`
	InitiatorByAvatarUrl sql.NullString      `db:"initiator_by_avatar_url" json:"initiator_by_avatar_url"`
	InitiatorByUsername  string              `db:"initiator_by_username" json:"initiator_by_username"`
}

type WorkspaceBuildParameter struct {
	WorkspaceBuildID uuid.UUID `db:"workspace_build_id" json:"workspace_build_id"`
	// Parameter name
	Name string `db:"name" json:"name"`
	// Parameter value
	Value string `db:"value" json:"value"`
}

type WorkspaceBuildTable struct {
	ID                uuid.UUID           `db:"id" json:"id"`
	CreatedAt         time.Time           `db:"created_at" json:"created_at"`
	UpdatedAt         time.Time           `db:"updated_at" json:"updated_at"`
	WorkspaceID       uuid.UUID           `db:"workspace_id" json:"workspace_id"`
	TemplateVersionID uuid.UUID           `db:"template_version_id" json:"template_version_id"`
	BuildNumber       int32               `db:"build_number" json:"build_number"`
	Transition        WorkspaceTransition `db:"transition" json:"transition"`
	InitiatorID       uuid.UUID           `db:"initiator_id" json:"initiator_id"`
	ProvisionerState  []byte              `db:"provisioner_state" json:"provisioner_state"`
	JobID             uuid.UUID           `db:"job_id" json:"job_id"`
	Deadline          time.Time           `db:"deadline" json:"deadline"`
	Reason            BuildReason         `db:"reason" json:"reason"`
	DailyCost         int32               `db:"daily_cost" json:"daily_cost"`
	MaxDeadline       time.Time           `db:"max_deadline" json:"max_deadline"`
}

type WorkspaceProxy struct {
	ID          uuid.UUID `db:"id" json:"id"`
	Name        string    `db:"name" json:"name"`
	DisplayName string    `db:"display_name" json:"display_name"`
	// Expects an emoji character. (/emojis/1f1fa-1f1f8.png)
	Icon string `db:"icon" json:"icon"`
	// Full url including scheme of the proxy api url: https://us.example.com
	Url string `db:"url" json:"url"`
	// Hostname with the wildcard for subdomain based app hosting: *.us.example.com
	WildcardHostname string    `db:"wildcard_hostname" json:"wildcard_hostname"`
	CreatedAt        time.Time `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time `db:"updated_at" json:"updated_at"`
	// Boolean indicator of a deleted workspace proxy. Proxies are soft-deleted.
	Deleted bool `db:"deleted" json:"deleted"`
	// Hashed secret is used to authenticate the workspace proxy using a session token.
	TokenHashedSecret []byte `db:"token_hashed_secret" json:"token_hashed_secret"`
	RegionID          int32  `db:"region_id" json:"region_id"`
	DerpEnabled       bool   `db:"derp_enabled" json:"derp_enabled"`
	// Disables app/terminal proxying for this proxy and only acts as a DERP relay.
	DerpOnly bool `db:"derp_only" json:"derp_only"`
}

type WorkspaceResource struct {
	ID           uuid.UUID           `db:"id" json:"id"`
	CreatedAt    time.Time           `db:"created_at" json:"created_at"`
	JobID        uuid.UUID           `db:"job_id" json:"job_id"`
	Transition   WorkspaceTransition `db:"transition" json:"transition"`
	Type         string              `db:"type" json:"type"`
	Name         string              `db:"name" json:"name"`
	Hide         bool                `db:"hide" json:"hide"`
	Icon         string              `db:"icon" json:"icon"`
	InstanceType sql.NullString      `db:"instance_type" json:"instance_type"`
	DailyCost    int32               `db:"daily_cost" json:"daily_cost"`
}

type WorkspaceResourceMetadatum struct {
	WorkspaceResourceID uuid.UUID      `db:"workspace_resource_id" json:"workspace_resource_id"`
	Key                 string         `db:"key" json:"key"`
	Value               sql.NullString `db:"value" json:"value"`
	Sensitive           bool           `db:"sensitive" json:"sensitive"`
	ID                  int64          `db:"id" json:"id"`
}
