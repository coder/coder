// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0

package database

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

type APIKeyScope string

const (
	APIKeyScopeAll                APIKeyScope = "all"
	APIKeyScopeApplicationConnect APIKeyScope = "application_connect"
)

func (e *APIKeyScope) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = APIKeyScope(s)
	case string:
		*e = APIKeyScope(s)
	default:
		return fmt.Errorf("unsupported scan type for APIKeyScope: %T", src)
	}
	return nil
}

type NullAPIKeyScope struct {
	APIKeyScope APIKeyScope `json:"api_key_scope"`
	Valid       bool        `json:"valid"` // Valid is true if APIKeyScope is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAPIKeyScope) Scan(value interface{}) error {
	if value == nil {
		ns.APIKeyScope, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.APIKeyScope.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAPIKeyScope) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.APIKeyScope), nil
}

func (e APIKeyScope) Valid() bool {
	switch e {
	case APIKeyScopeAll,
		APIKeyScopeApplicationConnect:
		return true
	}
	return false
}

func AllAPIKeyScopeValues() []APIKeyScope {
	return []APIKeyScope{
		APIKeyScopeAll,
		APIKeyScopeApplicationConnect,
	}
}

type AppSharingLevel string

const (
	AppSharingLevelOwner         AppSharingLevel = "owner"
	AppSharingLevelAuthenticated AppSharingLevel = "authenticated"
	AppSharingLevelPublic        AppSharingLevel = "public"
)

func (e *AppSharingLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AppSharingLevel(s)
	case string:
		*e = AppSharingLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for AppSharingLevel: %T", src)
	}
	return nil
}

type NullAppSharingLevel struct {
	AppSharingLevel AppSharingLevel `json:"app_sharing_level"`
	Valid           bool            `json:"valid"` // Valid is true if AppSharingLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAppSharingLevel) Scan(value interface{}) error {
	if value == nil {
		ns.AppSharingLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AppSharingLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAppSharingLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AppSharingLevel), nil
}

func (e AppSharingLevel) Valid() bool {
	switch e {
	case AppSharingLevelOwner,
		AppSharingLevelAuthenticated,
		AppSharingLevelPublic:
		return true
	}
	return false
}

func AllAppSharingLevelValues() []AppSharingLevel {
	return []AppSharingLevel{
		AppSharingLevelOwner,
		AppSharingLevelAuthenticated,
		AppSharingLevelPublic,
	}
}

type AuditAction string

const (
	AuditActionCreate   AuditAction = "create"
	AuditActionWrite    AuditAction = "write"
	AuditActionDelete   AuditAction = "delete"
	AuditActionStart    AuditAction = "start"
	AuditActionStop     AuditAction = "stop"
	AuditActionLogin    AuditAction = "login"
	AuditActionLogout   AuditAction = "logout"
	AuditActionRegister AuditAction = "register"
)

func (e *AuditAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuditAction(s)
	case string:
		*e = AuditAction(s)
	default:
		return fmt.Errorf("unsupported scan type for AuditAction: %T", src)
	}
	return nil
}

type NullAuditAction struct {
	AuditAction AuditAction `json:"audit_action"`
	Valid       bool        `json:"valid"` // Valid is true if AuditAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuditAction) Scan(value interface{}) error {
	if value == nil {
		ns.AuditAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuditAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuditAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuditAction), nil
}

func (e AuditAction) Valid() bool {
	switch e {
	case AuditActionCreate,
		AuditActionWrite,
		AuditActionDelete,
		AuditActionStart,
		AuditActionStop,
		AuditActionLogin,
		AuditActionLogout,
		AuditActionRegister:
		return true
	}
	return false
}

func AllAuditActionValues() []AuditAction {
	return []AuditAction{
		AuditActionCreate,
		AuditActionWrite,
		AuditActionDelete,
		AuditActionStart,
		AuditActionStop,
		AuditActionLogin,
		AuditActionLogout,
		AuditActionRegister,
	}
}

type AutomaticUpdates string

const (
	AutomaticUpdatesAlways AutomaticUpdates = "always"
	AutomaticUpdatesNever  AutomaticUpdates = "never"
)

func (e *AutomaticUpdates) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AutomaticUpdates(s)
	case string:
		*e = AutomaticUpdates(s)
	default:
		return fmt.Errorf("unsupported scan type for AutomaticUpdates: %T", src)
	}
	return nil
}

type NullAutomaticUpdates struct {
	AutomaticUpdates AutomaticUpdates `json:"automatic_updates"`
	Valid            bool             `json:"valid"` // Valid is true if AutomaticUpdates is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAutomaticUpdates) Scan(value interface{}) error {
	if value == nil {
		ns.AutomaticUpdates, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AutomaticUpdates.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAutomaticUpdates) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AutomaticUpdates), nil
}

func (e AutomaticUpdates) Valid() bool {
	switch e {
	case AutomaticUpdatesAlways,
		AutomaticUpdatesNever:
		return true
	}
	return false
}

func AllAutomaticUpdatesValues() []AutomaticUpdates {
	return []AutomaticUpdates{
		AutomaticUpdatesAlways,
		AutomaticUpdatesNever,
	}
}

type BuildReason string

const (
	BuildReasonInitiator  BuildReason = "initiator"
	BuildReasonAutostart  BuildReason = "autostart"
	BuildReasonAutostop   BuildReason = "autostop"
	BuildReasonDormancy   BuildReason = "dormancy"
	BuildReasonFailedstop BuildReason = "failedstop"
	BuildReasonAutodelete BuildReason = "autodelete"
)

func (e *BuildReason) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BuildReason(s)
	case string:
		*e = BuildReason(s)
	default:
		return fmt.Errorf("unsupported scan type for BuildReason: %T", src)
	}
	return nil
}

type NullBuildReason struct {
	BuildReason BuildReason `json:"build_reason"`
	Valid       bool        `json:"valid"` // Valid is true if BuildReason is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBuildReason) Scan(value interface{}) error {
	if value == nil {
		ns.BuildReason, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BuildReason.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBuildReason) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BuildReason), nil
}

func (e BuildReason) Valid() bool {
	switch e {
	case BuildReasonInitiator,
		BuildReasonAutostart,
		BuildReasonAutostop,
		BuildReasonDormancy,
		BuildReasonFailedstop,
		BuildReasonAutodelete:
		return true
	}
	return false
}

func AllBuildReasonValues() []BuildReason {
	return []BuildReason{
		BuildReasonInitiator,
		BuildReasonAutostart,
		BuildReasonAutostop,
		BuildReasonDormancy,
		BuildReasonFailedstop,
		BuildReasonAutodelete,
	}
}

type DisplayApp string

const (
	DisplayAppVscode               DisplayApp = "vscode"
	DisplayAppVscodeInsiders       DisplayApp = "vscode_insiders"
	DisplayAppWebTerminal          DisplayApp = "web_terminal"
	DisplayAppSSHHelper            DisplayApp = "ssh_helper"
	DisplayAppPortForwardingHelper DisplayApp = "port_forwarding_helper"
)

func (e *DisplayApp) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DisplayApp(s)
	case string:
		*e = DisplayApp(s)
	default:
		return fmt.Errorf("unsupported scan type for DisplayApp: %T", src)
	}
	return nil
}

type NullDisplayApp struct {
	DisplayApp DisplayApp `json:"display_app"`
	Valid      bool       `json:"valid"` // Valid is true if DisplayApp is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDisplayApp) Scan(value interface{}) error {
	if value == nil {
		ns.DisplayApp, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DisplayApp.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDisplayApp) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DisplayApp), nil
}

func (e DisplayApp) Valid() bool {
	switch e {
	case DisplayAppVscode,
		DisplayAppVscodeInsiders,
		DisplayAppWebTerminal,
		DisplayAppSSHHelper,
		DisplayAppPortForwardingHelper:
		return true
	}
	return false
}

func AllDisplayAppValues() []DisplayApp {
	return []DisplayApp{
		DisplayAppVscode,
		DisplayAppVscodeInsiders,
		DisplayAppWebTerminal,
		DisplayAppSSHHelper,
		DisplayAppPortForwardingHelper,
	}
}

type GroupSource string

const (
	GroupSourceUser GroupSource = "user"
	GroupSourceOidc GroupSource = "oidc"
)

func (e *GroupSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GroupSource(s)
	case string:
		*e = GroupSource(s)
	default:
		return fmt.Errorf("unsupported scan type for GroupSource: %T", src)
	}
	return nil
}

type NullGroupSource struct {
	GroupSource GroupSource `json:"group_source"`
	Valid       bool        `json:"valid"` // Valid is true if GroupSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGroupSource) Scan(value interface{}) error {
	if value == nil {
		ns.GroupSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GroupSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGroupSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GroupSource), nil
}

func (e GroupSource) Valid() bool {
	switch e {
	case GroupSourceUser,
		GroupSourceOidc:
		return true
	}
	return false
}

func AllGroupSourceValues() []GroupSource {
	return []GroupSource{
		GroupSourceUser,
		GroupSourceOidc,
	}
}

type LogLevel string

const (
	LogLevelTrace LogLevel = "trace"
	LogLevelDebug LogLevel = "debug"
	LogLevelInfo  LogLevel = "info"
	LogLevelWarn  LogLevel = "warn"
	LogLevelError LogLevel = "error"
)

func (e *LogLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LogLevel(s)
	case string:
		*e = LogLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for LogLevel: %T", src)
	}
	return nil
}

type NullLogLevel struct {
	LogLevel LogLevel `json:"log_level"`
	Valid    bool     `json:"valid"` // Valid is true if LogLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLogLevel) Scan(value interface{}) error {
	if value == nil {
		ns.LogLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LogLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLogLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LogLevel), nil
}

func (e LogLevel) Valid() bool {
	switch e {
	case LogLevelTrace,
		LogLevelDebug,
		LogLevelInfo,
		LogLevelWarn,
		LogLevelError:
		return true
	}
	return false
}

func AllLogLevelValues() []LogLevel {
	return []LogLevel{
		LogLevelTrace,
		LogLevelDebug,
		LogLevelInfo,
		LogLevelWarn,
		LogLevelError,
	}
}

type LogSource string

const (
	LogSourceProvisionerDaemon LogSource = "provisioner_daemon"
	LogSourceProvisioner       LogSource = "provisioner"
)

func (e *LogSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LogSource(s)
	case string:
		*e = LogSource(s)
	default:
		return fmt.Errorf("unsupported scan type for LogSource: %T", src)
	}
	return nil
}

type NullLogSource struct {
	LogSource LogSource `json:"log_source"`
	Valid     bool      `json:"valid"` // Valid is true if LogSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLogSource) Scan(value interface{}) error {
	if value == nil {
		ns.LogSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LogSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLogSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LogSource), nil
}

func (e LogSource) Valid() bool {
	switch e {
	case LogSourceProvisionerDaemon,
		LogSourceProvisioner:
		return true
	}
	return false
}

func AllLogSourceValues() []LogSource {
	return []LogSource{
		LogSourceProvisionerDaemon,
		LogSourceProvisioner,
	}
}

// Specifies the method of authentication. "none" is a special case in which no authentication method is allowed.
type LoginType string

const (
	LoginTypePassword LoginType = "password"
	LoginTypeGithub   LoginType = "github"
	LoginTypeOIDC     LoginType = "oidc"
	LoginTypeToken    LoginType = "token"
	LoginTypeNone     LoginType = "none"
)

func (e *LoginType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LoginType(s)
	case string:
		*e = LoginType(s)
	default:
		return fmt.Errorf("unsupported scan type for LoginType: %T", src)
	}
	return nil
}

type NullLoginType struct {
	LoginType LoginType `json:"login_type"`
	Valid     bool      `json:"valid"` // Valid is true if LoginType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLoginType) Scan(value interface{}) error {
	if value == nil {
		ns.LoginType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LoginType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLoginType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LoginType), nil
}

func (e LoginType) Valid() bool {
	switch e {
	case LoginTypePassword,
		LoginTypeGithub,
		LoginTypeOIDC,
		LoginTypeToken,
		LoginTypeNone:
		return true
	}
	return false
}

func AllLoginTypeValues() []LoginType {
	return []LoginType{
		LoginTypePassword,
		LoginTypeGithub,
		LoginTypeOIDC,
		LoginTypeToken,
		LoginTypeNone,
	}
}

type ParameterDestinationScheme string

const (
	ParameterDestinationSchemeNone                ParameterDestinationScheme = "none"
	ParameterDestinationSchemeEnvironmentVariable ParameterDestinationScheme = "environment_variable"
	ParameterDestinationSchemeProvisionerVariable ParameterDestinationScheme = "provisioner_variable"
)

func (e *ParameterDestinationScheme) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParameterDestinationScheme(s)
	case string:
		*e = ParameterDestinationScheme(s)
	default:
		return fmt.Errorf("unsupported scan type for ParameterDestinationScheme: %T", src)
	}
	return nil
}

type NullParameterDestinationScheme struct {
	ParameterDestinationScheme ParameterDestinationScheme `json:"parameter_destination_scheme"`
	Valid                      bool                       `json:"valid"` // Valid is true if ParameterDestinationScheme is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParameterDestinationScheme) Scan(value interface{}) error {
	if value == nil {
		ns.ParameterDestinationScheme, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParameterDestinationScheme.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParameterDestinationScheme) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParameterDestinationScheme), nil
}

func (e ParameterDestinationScheme) Valid() bool {
	switch e {
	case ParameterDestinationSchemeNone,
		ParameterDestinationSchemeEnvironmentVariable,
		ParameterDestinationSchemeProvisionerVariable:
		return true
	}
	return false
}

func AllParameterDestinationSchemeValues() []ParameterDestinationScheme {
	return []ParameterDestinationScheme{
		ParameterDestinationSchemeNone,
		ParameterDestinationSchemeEnvironmentVariable,
		ParameterDestinationSchemeProvisionerVariable,
	}
}

type ParameterScope string

const (
	ParameterScopeTemplate  ParameterScope = "template"
	ParameterScopeImportJob ParameterScope = "import_job"
	ParameterScopeWorkspace ParameterScope = "workspace"
)

func (e *ParameterScope) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParameterScope(s)
	case string:
		*e = ParameterScope(s)
	default:
		return fmt.Errorf("unsupported scan type for ParameterScope: %T", src)
	}
	return nil
}

type NullParameterScope struct {
	ParameterScope ParameterScope `json:"parameter_scope"`
	Valid          bool           `json:"valid"` // Valid is true if ParameterScope is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParameterScope) Scan(value interface{}) error {
	if value == nil {
		ns.ParameterScope, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParameterScope.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParameterScope) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParameterScope), nil
}

func (e ParameterScope) Valid() bool {
	switch e {
	case ParameterScopeTemplate,
		ParameterScopeImportJob,
		ParameterScopeWorkspace:
		return true
	}
	return false
}

func AllParameterScopeValues() []ParameterScope {
	return []ParameterScope{
		ParameterScopeTemplate,
		ParameterScopeImportJob,
		ParameterScopeWorkspace,
	}
}

type ParameterSourceScheme string

const (
	ParameterSourceSchemeNone ParameterSourceScheme = "none"
	ParameterSourceSchemeData ParameterSourceScheme = "data"
)

func (e *ParameterSourceScheme) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParameterSourceScheme(s)
	case string:
		*e = ParameterSourceScheme(s)
	default:
		return fmt.Errorf("unsupported scan type for ParameterSourceScheme: %T", src)
	}
	return nil
}

type NullParameterSourceScheme struct {
	ParameterSourceScheme ParameterSourceScheme `json:"parameter_source_scheme"`
	Valid                 bool                  `json:"valid"` // Valid is true if ParameterSourceScheme is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParameterSourceScheme) Scan(value interface{}) error {
	if value == nil {
		ns.ParameterSourceScheme, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParameterSourceScheme.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParameterSourceScheme) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParameterSourceScheme), nil
}

func (e ParameterSourceScheme) Valid() bool {
	switch e {
	case ParameterSourceSchemeNone,
		ParameterSourceSchemeData:
		return true
	}
	return false
}

func AllParameterSourceSchemeValues() []ParameterSourceScheme {
	return []ParameterSourceScheme{
		ParameterSourceSchemeNone,
		ParameterSourceSchemeData,
	}
}

type ParameterTypeSystem string

const (
	ParameterTypeSystemNone ParameterTypeSystem = "none"
	ParameterTypeSystemHCL  ParameterTypeSystem = "hcl"
)

func (e *ParameterTypeSystem) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParameterTypeSystem(s)
	case string:
		*e = ParameterTypeSystem(s)
	default:
		return fmt.Errorf("unsupported scan type for ParameterTypeSystem: %T", src)
	}
	return nil
}

type NullParameterTypeSystem struct {
	ParameterTypeSystem ParameterTypeSystem `json:"parameter_type_system"`
	Valid               bool                `json:"valid"` // Valid is true if ParameterTypeSystem is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParameterTypeSystem) Scan(value interface{}) error {
	if value == nil {
		ns.ParameterTypeSystem, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParameterTypeSystem.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParameterTypeSystem) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParameterTypeSystem), nil
}

func (e ParameterTypeSystem) Valid() bool {
	switch e {
	case ParameterTypeSystemNone,
		ParameterTypeSystemHCL:
		return true
	}
	return false
}

func AllParameterTypeSystemValues() []ParameterTypeSystem {
	return []ParameterTypeSystem{
		ParameterTypeSystemNone,
		ParameterTypeSystemHCL,
	}
}

// Computed status of a provisioner job. Jobs could be stuck in a hung state, these states do not guarantee any transition to another state.
type ProvisionerJobStatus string

const (
	ProvisionerJobStatusPending   ProvisionerJobStatus = "pending"
	ProvisionerJobStatusRunning   ProvisionerJobStatus = "running"
	ProvisionerJobStatusSucceeded ProvisionerJobStatus = "succeeded"
	ProvisionerJobStatusCanceling ProvisionerJobStatus = "canceling"
	ProvisionerJobStatusCanceled  ProvisionerJobStatus = "canceled"
	ProvisionerJobStatusFailed    ProvisionerJobStatus = "failed"
	ProvisionerJobStatusUnknown   ProvisionerJobStatus = "unknown"
)

func (e *ProvisionerJobStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProvisionerJobStatus(s)
	case string:
		*e = ProvisionerJobStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ProvisionerJobStatus: %T", src)
	}
	return nil
}

type NullProvisionerJobStatus struct {
	ProvisionerJobStatus ProvisionerJobStatus `json:"provisioner_job_status"`
	Valid                bool                 `json:"valid"` // Valid is true if ProvisionerJobStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProvisionerJobStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ProvisionerJobStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProvisionerJobStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProvisionerJobStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProvisionerJobStatus), nil
}

func (e ProvisionerJobStatus) Valid() bool {
	switch e {
	case ProvisionerJobStatusPending,
		ProvisionerJobStatusRunning,
		ProvisionerJobStatusSucceeded,
		ProvisionerJobStatusCanceling,
		ProvisionerJobStatusCanceled,
		ProvisionerJobStatusFailed,
		ProvisionerJobStatusUnknown:
		return true
	}
	return false
}

func AllProvisionerJobStatusValues() []ProvisionerJobStatus {
	return []ProvisionerJobStatus{
		ProvisionerJobStatusPending,
		ProvisionerJobStatusRunning,
		ProvisionerJobStatusSucceeded,
		ProvisionerJobStatusCanceling,
		ProvisionerJobStatusCanceled,
		ProvisionerJobStatusFailed,
		ProvisionerJobStatusUnknown,
	}
}

type ProvisionerJobType string

const (
	ProvisionerJobTypeTemplateVersionImport ProvisionerJobType = "template_version_import"
	ProvisionerJobTypeWorkspaceBuild        ProvisionerJobType = "workspace_build"
	ProvisionerJobTypeTemplateVersionDryRun ProvisionerJobType = "template_version_dry_run"
)

func (e *ProvisionerJobType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProvisionerJobType(s)
	case string:
		*e = ProvisionerJobType(s)
	default:
		return fmt.Errorf("unsupported scan type for ProvisionerJobType: %T", src)
	}
	return nil
}

type NullProvisionerJobType struct {
	ProvisionerJobType ProvisionerJobType `json:"provisioner_job_type"`
	Valid              bool               `json:"valid"` // Valid is true if ProvisionerJobType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProvisionerJobType) Scan(value interface{}) error {
	if value == nil {
		ns.ProvisionerJobType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProvisionerJobType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProvisionerJobType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProvisionerJobType), nil
}

func (e ProvisionerJobType) Valid() bool {
	switch e {
	case ProvisionerJobTypeTemplateVersionImport,
		ProvisionerJobTypeWorkspaceBuild,
		ProvisionerJobTypeTemplateVersionDryRun:
		return true
	}
	return false
}

func AllProvisionerJobTypeValues() []ProvisionerJobType {
	return []ProvisionerJobType{
		ProvisionerJobTypeTemplateVersionImport,
		ProvisionerJobTypeWorkspaceBuild,
		ProvisionerJobTypeTemplateVersionDryRun,
	}
}

type ProvisionerStorageMethod string

const (
	ProvisionerStorageMethodFile ProvisionerStorageMethod = "file"
)

func (e *ProvisionerStorageMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProvisionerStorageMethod(s)
	case string:
		*e = ProvisionerStorageMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for ProvisionerStorageMethod: %T", src)
	}
	return nil
}

type NullProvisionerStorageMethod struct {
	ProvisionerStorageMethod ProvisionerStorageMethod `json:"provisioner_storage_method"`
	Valid                    bool                     `json:"valid"` // Valid is true if ProvisionerStorageMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProvisionerStorageMethod) Scan(value interface{}) error {
	if value == nil {
		ns.ProvisionerStorageMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProvisionerStorageMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProvisionerStorageMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProvisionerStorageMethod), nil
}

func (e ProvisionerStorageMethod) Valid() bool {
	switch e {
	case ProvisionerStorageMethodFile:
		return true
	}
	return false
}

func AllProvisionerStorageMethodValues() []ProvisionerStorageMethod {
	return []ProvisionerStorageMethod{
		ProvisionerStorageMethodFile,
	}
}

type ProvisionerType string

const (
	ProvisionerTypeEcho      ProvisionerType = "echo"
	ProvisionerTypeTerraform ProvisionerType = "terraform"
)

func (e *ProvisionerType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProvisionerType(s)
	case string:
		*e = ProvisionerType(s)
	default:
		return fmt.Errorf("unsupported scan type for ProvisionerType: %T", src)
	}
	return nil
}

type NullProvisionerType struct {
	ProvisionerType ProvisionerType `json:"provisioner_type"`
	Valid           bool            `json:"valid"` // Valid is true if ProvisionerType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProvisionerType) Scan(value interface{}) error {
	if value == nil {
		ns.ProvisionerType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProvisionerType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProvisionerType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProvisionerType), nil
}

func (e ProvisionerType) Valid() bool {
	switch e {
	case ProvisionerTypeEcho,
		ProvisionerTypeTerraform:
		return true
	}
	return false
}

func AllProvisionerTypeValues() []ProvisionerType {
	return []ProvisionerType{
		ProvisionerTypeEcho,
		ProvisionerTypeTerraform,
	}
}

type ResourceType string

const (
	ResourceTypeOrganization    ResourceType = "organization"
	ResourceTypeTemplate        ResourceType = "template"
	ResourceTypeTemplateVersion ResourceType = "template_version"
	ResourceTypeUser            ResourceType = "user"
	ResourceTypeWorkspace       ResourceType = "workspace"
	ResourceTypeGitSshKey       ResourceType = "git_ssh_key"
	ResourceTypeApiKey          ResourceType = "api_key"
	ResourceTypeGroup           ResourceType = "group"
	ResourceTypeWorkspaceBuild  ResourceType = "workspace_build"
	ResourceTypeLicense         ResourceType = "license"
	ResourceTypeWorkspaceProxy  ResourceType = "workspace_proxy"
	ResourceTypeConvertLogin    ResourceType = "convert_login"
	ResourceTypeHealthSettings  ResourceType = "health_settings"
)

func (e *ResourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ResourceType(s)
	case string:
		*e = ResourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for ResourceType: %T", src)
	}
	return nil
}

type NullResourceType struct {
	ResourceType ResourceType `json:"resource_type"`
	Valid        bool         `json:"valid"` // Valid is true if ResourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullResourceType) Scan(value interface{}) error {
	if value == nil {
		ns.ResourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ResourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullResourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ResourceType), nil
}

func (e ResourceType) Valid() bool {
	switch e {
	case ResourceTypeOrganization,
		ResourceTypeTemplate,
		ResourceTypeTemplateVersion,
		ResourceTypeUser,
		ResourceTypeWorkspace,
		ResourceTypeGitSshKey,
		ResourceTypeApiKey,
		ResourceTypeGroup,
		ResourceTypeWorkspaceBuild,
		ResourceTypeLicense,
		ResourceTypeWorkspaceProxy,
		ResourceTypeConvertLogin,
		ResourceTypeHealthSettings:
		return true
	}
	return false
}

func AllResourceTypeValues() []ResourceType {
	return []ResourceType{
		ResourceTypeOrganization,
		ResourceTypeTemplate,
		ResourceTypeTemplateVersion,
		ResourceTypeUser,
		ResourceTypeWorkspace,
		ResourceTypeGitSshKey,
		ResourceTypeApiKey,
		ResourceTypeGroup,
		ResourceTypeWorkspaceBuild,
		ResourceTypeLicense,
		ResourceTypeWorkspaceProxy,
		ResourceTypeConvertLogin,
		ResourceTypeHealthSettings,
	}
}

type StartupScriptBehavior string

const (
	StartupScriptBehaviorBlocking    StartupScriptBehavior = "blocking"
	StartupScriptBehaviorNonBlocking StartupScriptBehavior = "non-blocking"
)

func (e *StartupScriptBehavior) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StartupScriptBehavior(s)
	case string:
		*e = StartupScriptBehavior(s)
	default:
		return fmt.Errorf("unsupported scan type for StartupScriptBehavior: %T", src)
	}
	return nil
}

type NullStartupScriptBehavior struct {
	StartupScriptBehavior StartupScriptBehavior `json:"startup_script_behavior"`
	Valid                 bool                  `json:"valid"` // Valid is true if StartupScriptBehavior is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStartupScriptBehavior) Scan(value interface{}) error {
	if value == nil {
		ns.StartupScriptBehavior, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StartupScriptBehavior.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStartupScriptBehavior) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StartupScriptBehavior), nil
}

func (e StartupScriptBehavior) Valid() bool {
	switch e {
	case StartupScriptBehaviorBlocking,
		StartupScriptBehaviorNonBlocking:
		return true
	}
	return false
}

func AllStartupScriptBehaviorValues() []StartupScriptBehavior {
	return []StartupScriptBehavior{
		StartupScriptBehaviorBlocking,
		StartupScriptBehaviorNonBlocking,
	}
}

type TailnetStatus string

const (
	TailnetStatusOk   TailnetStatus = "ok"
	TailnetStatusLost TailnetStatus = "lost"
)

func (e *TailnetStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TailnetStatus(s)
	case string:
		*e = TailnetStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TailnetStatus: %T", src)
	}
	return nil
}

type NullTailnetStatus struct {
	TailnetStatus TailnetStatus `json:"tailnet_status"`
	Valid         bool          `json:"valid"` // Valid is true if TailnetStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTailnetStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TailnetStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TailnetStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTailnetStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TailnetStatus), nil
}

func (e TailnetStatus) Valid() bool {
	switch e {
	case TailnetStatusOk,
		TailnetStatusLost:
		return true
	}
	return false
}

func AllTailnetStatusValues() []TailnetStatus {
	return []TailnetStatus{
		TailnetStatusOk,
		TailnetStatusLost,
	}
}

// Defines the users status: active, dormant, or suspended.
type UserStatus string

const (
	UserStatusActive    UserStatus = "active"
	UserStatusSuspended UserStatus = "suspended"
	UserStatusDormant   UserStatus = "dormant"
)

func (e *UserStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserStatus(s)
	case string:
		*e = UserStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UserStatus: %T", src)
	}
	return nil
}

type NullUserStatus struct {
	UserStatus UserStatus `json:"user_status"`
	Valid      bool       `json:"valid"` // Valid is true if UserStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UserStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserStatus), nil
}

func (e UserStatus) Valid() bool {
	switch e {
	case UserStatusActive,
		UserStatusSuspended,
		UserStatusDormant:
		return true
	}
	return false
}

func AllUserStatusValues() []UserStatus {
	return []UserStatus{
		UserStatusActive,
		UserStatusSuspended,
		UserStatusDormant,
	}
}

type WorkspaceAgentLifecycleState string

const (
	WorkspaceAgentLifecycleStateCreated         WorkspaceAgentLifecycleState = "created"
	WorkspaceAgentLifecycleStateStarting        WorkspaceAgentLifecycleState = "starting"
	WorkspaceAgentLifecycleStateStartTimeout    WorkspaceAgentLifecycleState = "start_timeout"
	WorkspaceAgentLifecycleStateStartError      WorkspaceAgentLifecycleState = "start_error"
	WorkspaceAgentLifecycleStateReady           WorkspaceAgentLifecycleState = "ready"
	WorkspaceAgentLifecycleStateShuttingDown    WorkspaceAgentLifecycleState = "shutting_down"
	WorkspaceAgentLifecycleStateShutdownTimeout WorkspaceAgentLifecycleState = "shutdown_timeout"
	WorkspaceAgentLifecycleStateShutdownError   WorkspaceAgentLifecycleState = "shutdown_error"
	WorkspaceAgentLifecycleStateOff             WorkspaceAgentLifecycleState = "off"
)

func (e *WorkspaceAgentLifecycleState) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkspaceAgentLifecycleState(s)
	case string:
		*e = WorkspaceAgentLifecycleState(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkspaceAgentLifecycleState: %T", src)
	}
	return nil
}

type NullWorkspaceAgentLifecycleState struct {
	WorkspaceAgentLifecycleState WorkspaceAgentLifecycleState `json:"workspace_agent_lifecycle_state"`
	Valid                        bool                         `json:"valid"` // Valid is true if WorkspaceAgentLifecycleState is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkspaceAgentLifecycleState) Scan(value interface{}) error {
	if value == nil {
		ns.WorkspaceAgentLifecycleState, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkspaceAgentLifecycleState.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkspaceAgentLifecycleState) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkspaceAgentLifecycleState), nil
}

func (e WorkspaceAgentLifecycleState) Valid() bool {
	switch e {
	case WorkspaceAgentLifecycleStateCreated,
		WorkspaceAgentLifecycleStateStarting,
		WorkspaceAgentLifecycleStateStartTimeout,
		WorkspaceAgentLifecycleStateStartError,
		WorkspaceAgentLifecycleStateReady,
		WorkspaceAgentLifecycleStateShuttingDown,
		WorkspaceAgentLifecycleStateShutdownTimeout,
		WorkspaceAgentLifecycleStateShutdownError,
		WorkspaceAgentLifecycleStateOff:
		return true
	}
	return false
}

func AllWorkspaceAgentLifecycleStateValues() []WorkspaceAgentLifecycleState {
	return []WorkspaceAgentLifecycleState{
		WorkspaceAgentLifecycleStateCreated,
		WorkspaceAgentLifecycleStateStarting,
		WorkspaceAgentLifecycleStateStartTimeout,
		WorkspaceAgentLifecycleStateStartError,
		WorkspaceAgentLifecycleStateReady,
		WorkspaceAgentLifecycleStateShuttingDown,
		WorkspaceAgentLifecycleStateShutdownTimeout,
		WorkspaceAgentLifecycleStateShutdownError,
		WorkspaceAgentLifecycleStateOff,
	}
}

type WorkspaceAgentSubsystem string

const (
	WorkspaceAgentSubsystemEnvbuilder WorkspaceAgentSubsystem = "envbuilder"
	WorkspaceAgentSubsystemEnvbox     WorkspaceAgentSubsystem = "envbox"
	WorkspaceAgentSubsystemNone       WorkspaceAgentSubsystem = "none"
	WorkspaceAgentSubsystemExectrace  WorkspaceAgentSubsystem = "exectrace"
)

func (e *WorkspaceAgentSubsystem) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkspaceAgentSubsystem(s)
	case string:
		*e = WorkspaceAgentSubsystem(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkspaceAgentSubsystem: %T", src)
	}
	return nil
}

type NullWorkspaceAgentSubsystem struct {
	WorkspaceAgentSubsystem WorkspaceAgentSubsystem `json:"workspace_agent_subsystem"`
	Valid                   bool                    `json:"valid"` // Valid is true if WorkspaceAgentSubsystem is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkspaceAgentSubsystem) Scan(value interface{}) error {
	if value == nil {
		ns.WorkspaceAgentSubsystem, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkspaceAgentSubsystem.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkspaceAgentSubsystem) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkspaceAgentSubsystem), nil
}

func (e WorkspaceAgentSubsystem) Valid() bool {
	switch e {
	case WorkspaceAgentSubsystemEnvbuilder,
		WorkspaceAgentSubsystemEnvbox,
		WorkspaceAgentSubsystemNone,
		WorkspaceAgentSubsystemExectrace:
		return true
	}
	return false
}

func AllWorkspaceAgentSubsystemValues() []WorkspaceAgentSubsystem {
	return []WorkspaceAgentSubsystem{
		WorkspaceAgentSubsystemEnvbuilder,
		WorkspaceAgentSubsystemEnvbox,
		WorkspaceAgentSubsystemNone,
		WorkspaceAgentSubsystemExectrace,
	}
}

type WorkspaceAppHealth string

const (
	WorkspaceAppHealthDisabled     WorkspaceAppHealth = "disabled"
	WorkspaceAppHealthInitializing WorkspaceAppHealth = "initializing"
	WorkspaceAppHealthHealthy      WorkspaceAppHealth = "healthy"
	WorkspaceAppHealthUnhealthy    WorkspaceAppHealth = "unhealthy"
)

func (e *WorkspaceAppHealth) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkspaceAppHealth(s)
	case string:
		*e = WorkspaceAppHealth(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkspaceAppHealth: %T", src)
	}
	return nil
}

type NullWorkspaceAppHealth struct {
	WorkspaceAppHealth WorkspaceAppHealth `json:"workspace_app_health"`
	Valid              bool               `json:"valid"` // Valid is true if WorkspaceAppHealth is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkspaceAppHealth) Scan(value interface{}) error {
	if value == nil {
		ns.WorkspaceAppHealth, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkspaceAppHealth.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkspaceAppHealth) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkspaceAppHealth), nil
}

func (e WorkspaceAppHealth) Valid() bool {
	switch e {
	case WorkspaceAppHealthDisabled,
		WorkspaceAppHealthInitializing,
		WorkspaceAppHealthHealthy,
		WorkspaceAppHealthUnhealthy:
		return true
	}
	return false
}

func AllWorkspaceAppHealthValues() []WorkspaceAppHealth {
	return []WorkspaceAppHealth{
		WorkspaceAppHealthDisabled,
		WorkspaceAppHealthInitializing,
		WorkspaceAppHealthHealthy,
		WorkspaceAppHealthUnhealthy,
	}
}

type WorkspaceTransition string

const (
	WorkspaceTransitionStart  WorkspaceTransition = "start"
	WorkspaceTransitionStop   WorkspaceTransition = "stop"
	WorkspaceTransitionDelete WorkspaceTransition = "delete"
)

func (e *WorkspaceTransition) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkspaceTransition(s)
	case string:
		*e = WorkspaceTransition(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkspaceTransition: %T", src)
	}
	return nil
}

type NullWorkspaceTransition struct {
	WorkspaceTransition WorkspaceTransition `json:"workspace_transition"`
	Valid               bool                `json:"valid"` // Valid is true if WorkspaceTransition is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkspaceTransition) Scan(value interface{}) error {
	if value == nil {
		ns.WorkspaceTransition, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkspaceTransition.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkspaceTransition) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkspaceTransition), nil
}

func (e WorkspaceTransition) Valid() bool {
	switch e {
	case WorkspaceTransitionStart,
		WorkspaceTransitionStop,
		WorkspaceTransitionDelete:
		return true
	}
	return false
}

func AllWorkspaceTransitionValues() []WorkspaceTransition {
	return []WorkspaceTransition{
		WorkspaceTransitionStart,
		WorkspaceTransitionStop,
		WorkspaceTransitionDelete,
	}
}

type APIKey struct {
	ID string `db:"id" json:"id"`
	// hashed_secret contains a SHA256 hash of the key secret. This is considered a secret and MUST NOT be returned from the API as it is used for API key encryption in app proxying code.
	HashedSecret    []byte      `db:"hashed_secret" json:"hashed_secret"`
	UserID          uuid.UUID   `db:"user_id" json:"user_id"`
	LastUsed        time.Time   `db:"last_used" json:"last_used"`
	ExpiresAt       time.Time   `db:"expires_at" json:"expires_at"`
	CreatedAt       time.Time   `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time   `db:"updated_at" json:"updated_at"`
	LoginType       LoginType   `db:"login_type" json:"login_type"`
	LifetimeSeconds int64       `db:"lifetime_seconds" json:"lifetime_seconds"`
	IPAddress       pqtype.Inet `db:"ip_address" json:"ip_address"`
	Scope           APIKeyScope `db:"scope" json:"scope"`
	TokenName       string      `db:"token_name" json:"token_name"`
}

type AuditLog struct {
	ID               uuid.UUID       `db:"id" json:"id"`
	Time             time.Time       `db:"time" json:"time"`
	UserID           uuid.UUID       `db:"user_id" json:"user_id"`
	OrganizationID   uuid.UUID       `db:"organization_id" json:"organization_id"`
	Ip               pqtype.Inet     `db:"ip" json:"ip"`
	UserAgent        sql.NullString  `db:"user_agent" json:"user_agent"`
	ResourceType     ResourceType    `db:"resource_type" json:"resource_type"`
	ResourceID       uuid.UUID       `db:"resource_id" json:"resource_id"`
	ResourceTarget   string          `db:"resource_target" json:"resource_target"`
	Action           AuditAction     `db:"action" json:"action"`
	Diff             json.RawMessage `db:"diff" json:"diff"`
	StatusCode       int32           `db:"status_code" json:"status_code"`
	AdditionalFields json.RawMessage `db:"additional_fields" json:"additional_fields"`
	RequestID        uuid.UUID       `db:"request_id" json:"request_id"`
	ResourceIcon     string          `db:"resource_icon" json:"resource_icon"`
}

// A table used to store the keys used to encrypt the database.
type DBCryptKey struct {
	// An integer used to identify the key.
	Number int32 `db:"number" json:"number"`
	// If the key is active, the digest of the active key.
	ActiveKeyDigest sql.NullString `db:"active_key_digest" json:"active_key_digest"`
	// If the key has been revoked, the digest of the revoked key.
	RevokedKeyDigest sql.NullString `db:"revoked_key_digest" json:"revoked_key_digest"`
	// The time at which the key was created.
	CreatedAt sql.NullTime `db:"created_at" json:"created_at"`
	// The time at which the key was revoked.
	RevokedAt sql.NullTime `db:"revoked_at" json:"revoked_at"`
	// A column used to test the encryption.
	Test string `db:"test" json:"test"`
}

type ExternalAuthLink struct {
	ProviderID        string    `db:"provider_id" json:"provider_id"`
	UserID            uuid.UUID `db:"user_id" json:"user_id"`
	CreatedAt         time.Time `db:"created_at" json:"created_at"`
	UpdatedAt         time.Time `db:"updated_at" json:"updated_at"`
	OAuthAccessToken  string    `db:"oauth_access_token" json:"oauth_access_token"`
	OAuthRefreshToken string    `db:"oauth_refresh_token" json:"oauth_refresh_token"`
	OAuthExpiry       time.Time `db:"oauth_expiry" json:"oauth_expiry"`
	// The ID of the key used to encrypt the OAuth access token. If this is NULL, the access token is not encrypted
	OAuthAccessTokenKeyID sql.NullString `db:"oauth_access_token_key_id" json:"oauth_access_token_key_id"`
	// The ID of the key used to encrypt the OAuth refresh token. If this is NULL, the refresh token is not encrypted
	OAuthRefreshTokenKeyID sql.NullString        `db:"oauth_refresh_token_key_id" json:"oauth_refresh_token_key_id"`
	OAuthExtra             pqtype.NullRawMessage `db:"oauth_extra" json:"oauth_extra"`
}

type File struct {
	Hash      string    `db:"hash" json:"hash"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	CreatedBy uuid.UUID `db:"created_by" json:"created_by"`
	Mimetype  string    `db:"mimetype" json:"mimetype"`
	Data      []byte    `db:"data" json:"data"`
	ID        uuid.UUID `db:"id" json:"id"`
}

type GitSSHKey struct {
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	CreatedAt  time.Time `db:"created_at" json:"created_at"`
	UpdatedAt  time.Time `db:"updated_at" json:"updated_at"`
	PrivateKey string    `db:"private_key" json:"private_key"`
	PublicKey  string    `db:"public_key" json:"public_key"`
}

type Group struct {
	ID             uuid.UUID `db:"id" json:"id"`
	Name           string    `db:"name" json:"name"`
	OrganizationID uuid.UUID `db:"organization_id" json:"organization_id"`
	AvatarURL      string    `db:"avatar_url" json:"avatar_url"`
	QuotaAllowance int32     `db:"quota_allowance" json:"quota_allowance"`
	// Display name is a custom, human-friendly group name that user can set. This is not required to be unique and can be the empty string.
	DisplayName string `db:"display_name" json:"display_name"`
	// Source indicates how the group was created. It can be created by a user manually, or through some system process like OIDC group sync.
	Source GroupSource `db:"source" json:"source"`
}

type GroupMember struct {
	UserID  uuid.UUID `db:"user_id" json:"user_id"`
	GroupID uuid.UUID `db:"group_id" json:"group_id"`
}

type License struct {
	ID         int32     `db:"id" json:"id"`
	UploadedAt time.Time `db:"uploaded_at" json:"uploaded_at"`
	JWT        string    `db:"jwt" json:"jwt"`
	// exp tracks the claim of the same name in the JWT, and we include it here so that we can easily query for licenses that have not yet expired.
	Exp  time.Time `db:"exp" json:"exp"`
	UUID uuid.UUID `db:"uuid" json:"uuid"`
}

// A table used to configure apps that can use Coder as an OAuth2 provider, the reverse of what we are calling external authentication.
type OAuth2ProviderApp struct {
	ID          uuid.UUID `db:"id" json:"id"`
	CreatedAt   time.Time `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time `db:"updated_at" json:"updated_at"`
	Name        string    `db:"name" json:"name"`
	Icon        string    `db:"icon" json:"icon"`
	CallbackURL string    `db:"callback_url" json:"callback_url"`
}

type OAuth2ProviderAppSecret struct {
	ID           uuid.UUID    `db:"id" json:"id"`
	CreatedAt    time.Time    `db:"created_at" json:"created_at"`
	LastUsedAt   sql.NullTime `db:"last_used_at" json:"last_used_at"`
	HashedSecret []byte       `db:"hashed_secret" json:"hashed_secret"`
	// The tail end of the original secret so secrets can be differentiated.
	DisplaySecret string    `db:"display_secret" json:"display_secret"`
	AppID         uuid.UUID `db:"app_id" json:"app_id"`
}

type Organization struct {
	ID          uuid.UUID `db:"id" json:"id"`
	Name        string    `db:"name" json:"name"`
	Description string    `db:"description" json:"description"`
	CreatedAt   time.Time `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time `db:"updated_at" json:"updated_at"`
}

type OrganizationMember struct {
	UserID         uuid.UUID `db:"user_id" json:"user_id"`
	OrganizationID uuid.UUID `db:"organization_id" json:"organization_id"`
	CreatedAt      time.Time `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time `db:"updated_at" json:"updated_at"`
	Roles          []string  `db:"roles" json:"roles"`
}

type ParameterSchema struct {
	ID                       uuid.UUID                  `db:"id" json:"id"`
	CreatedAt                time.Time                  `db:"created_at" json:"created_at"`
	JobID                    uuid.UUID                  `db:"job_id" json:"job_id"`
	Name                     string                     `db:"name" json:"name"`
	Description              string                     `db:"description" json:"description"`
	DefaultSourceScheme      ParameterSourceScheme      `db:"default_source_scheme" json:"default_source_scheme"`
	DefaultSourceValue       string                     `db:"default_source_value" json:"default_source_value"`
	AllowOverrideSource      bool                       `db:"allow_override_source" json:"allow_override_source"`
	DefaultDestinationScheme ParameterDestinationScheme `db:"default_destination_scheme" json:"default_destination_scheme"`
	AllowOverrideDestination bool                       `db:"allow_override_destination" json:"allow_override_destination"`
	DefaultRefresh           string                     `db:"default_refresh" json:"default_refresh"`
	RedisplayValue           bool                       `db:"redisplay_value" json:"redisplay_value"`
	ValidationError          string                     `db:"validation_error" json:"validation_error"`
	ValidationCondition      string                     `db:"validation_condition" json:"validation_condition"`
	ValidationTypeSystem     ParameterTypeSystem        `db:"validation_type_system" json:"validation_type_system"`
	ValidationValueType      string                     `db:"validation_value_type" json:"validation_value_type"`
	Index                    int32                      `db:"index" json:"index"`
}

type ParameterValue struct {
	ID                uuid.UUID                  `db:"id" json:"id"`
	CreatedAt         time.Time                  `db:"created_at" json:"created_at"`
	UpdatedAt         time.Time                  `db:"updated_at" json:"updated_at"`
	Scope             ParameterScope             `db:"scope" json:"scope"`
	ScopeID           uuid.UUID                  `db:"scope_id" json:"scope_id"`
	Name              string                     `db:"name" json:"name"`
	SourceScheme      ParameterSourceScheme      `db:"source_scheme" json:"source_scheme"`
	SourceValue       string                     `db:"source_value" json:"source_value"`
	DestinationScheme ParameterDestinationScheme `db:"destination_scheme" json:"destination_scheme"`
}

type ProvisionerDaemon struct {
	ID           uuid.UUID         `db:"id" json:"id"`
	CreatedAt    time.Time         `db:"created_at" json:"created_at"`
	Name         string            `db:"name" json:"name"`
	Provisioners []ProvisionerType `db:"provisioners" json:"provisioners"`
	ReplicaID    uuid.NullUUID     `db:"replica_id" json:"replica_id"`
	Tags         StringMap         `db:"tags" json:"tags"`
	LastSeenAt   sql.NullTime      `db:"last_seen_at" json:"last_seen_at"`
	Version      string            `db:"version" json:"version"`
	// The API version of the provisioner daemon
	APIVersion string `db:"api_version" json:"api_version"`
}

type ProvisionerJob struct {
	ID             uuid.UUID                `db:"id" json:"id"`
	CreatedAt      time.Time                `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time                `db:"updated_at" json:"updated_at"`
	StartedAt      sql.NullTime             `db:"started_at" json:"started_at"`
	CanceledAt     sql.NullTime             `db:"canceled_at" json:"canceled_at"`
	CompletedAt    sql.NullTime             `db:"completed_at" json:"completed_at"`
	Error          sql.NullString           `db:"error" json:"error"`
	OrganizationID uuid.UUID                `db:"organization_id" json:"organization_id"`
	InitiatorID    uuid.UUID                `db:"initiator_id" json:"initiator_id"`
	Provisioner    ProvisionerType          `db:"provisioner" json:"provisioner"`
	StorageMethod  ProvisionerStorageMethod `db:"storage_method" json:"storage_method"`
	Type           ProvisionerJobType       `db:"type" json:"type"`
	Input          json.RawMessage          `db:"input" json:"input"`
	WorkerID       uuid.NullUUID            `db:"worker_id" json:"worker_id"`
	FileID         uuid.UUID                `db:"file_id" json:"file_id"`
	Tags           StringMap                `db:"tags" json:"tags"`
	ErrorCode      sql.NullString           `db:"error_code" json:"error_code"`
	TraceMetadata  pqtype.NullRawMessage    `db:"trace_metadata" json:"trace_metadata"`
	// Computed column to track the status of the job.
	JobStatus ProvisionerJobStatus `db:"job_status" json:"job_status"`
}

type ProvisionerJobLog struct {
	JobID     uuid.UUID `db:"job_id" json:"job_id"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	Source    LogSource `db:"source" json:"source"`
	Level     LogLevel  `db:"level" json:"level"`
	Stage     string    `db:"stage" json:"stage"`
	Output    string    `db:"output" json:"output"`
	ID        int64     `db:"id" json:"id"`
}

type Replica struct {
	ID              uuid.UUID    `db:"id" json:"id"`
	CreatedAt       time.Time    `db:"created_at" json:"created_at"`
	StartedAt       time.Time    `db:"started_at" json:"started_at"`
	StoppedAt       sql.NullTime `db:"stopped_at" json:"stopped_at"`
	UpdatedAt       time.Time    `db:"updated_at" json:"updated_at"`
	Hostname        string       `db:"hostname" json:"hostname"`
	RegionID        int32        `db:"region_id" json:"region_id"`
	RelayAddress    string       `db:"relay_address" json:"relay_address"`
	DatabaseLatency int32        `db:"database_latency" json:"database_latency"`
	Version         string       `db:"version" json:"version"`
	Error           string       `db:"error" json:"error"`
	Primary         bool         `db:"primary" json:"primary"`
}

type SiteConfig struct {
	Key   string `db:"key" json:"key"`
	Value string `db:"value" json:"value"`
}

type TailnetAgent struct {
	ID            uuid.UUID       `db:"id" json:"id"`
	CoordinatorID uuid.UUID       `db:"coordinator_id" json:"coordinator_id"`
	UpdatedAt     time.Time       `db:"updated_at" json:"updated_at"`
	Node          json.RawMessage `db:"node" json:"node"`
}

type TailnetClient struct {
	ID            uuid.UUID       `db:"id" json:"id"`
	CoordinatorID uuid.UUID       `db:"coordinator_id" json:"coordinator_id"`
	UpdatedAt     time.Time       `db:"updated_at" json:"updated_at"`
	Node          json.RawMessage `db:"node" json:"node"`
}

type TailnetClientSubscription struct {
	ClientID      uuid.UUID `db:"client_id" json:"client_id"`
	CoordinatorID uuid.UUID `db:"coordinator_id" json:"coordinator_id"`
	AgentID       uuid.UUID `db:"agent_id" json:"agent_id"`
	UpdatedAt     time.Time `db:"updated_at" json:"updated_at"`
}

// We keep this separate from replicas in case we need to break the coordinator out into its own service
type TailnetCoordinator struct {
	ID          uuid.UUID `db:"id" json:"id"`
	HeartbeatAt time.Time `db:"heartbeat_at" json:"heartbeat_at"`
}

type TailnetPeer struct {
	ID            uuid.UUID     `db:"id" json:"id"`
	CoordinatorID uuid.UUID     `db:"coordinator_id" json:"coordinator_id"`
	UpdatedAt     time.Time     `db:"updated_at" json:"updated_at"`
	Node          []byte        `db:"node" json:"node"`
	Status        TailnetStatus `db:"status" json:"status"`
}

type TailnetTunnel struct {
	CoordinatorID uuid.UUID `db:"coordinator_id" json:"coordinator_id"`
	SrcID         uuid.UUID `db:"src_id" json:"src_id"`
	DstID         uuid.UUID `db:"dst_id" json:"dst_id"`
	UpdatedAt     time.Time `db:"updated_at" json:"updated_at"`
}

// Joins in the username + avatar url of the created by user.
type Template struct {
	ID                            uuid.UUID       `db:"id" json:"id"`
	CreatedAt                     time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt                     time.Time       `db:"updated_at" json:"updated_at"`
	OrganizationID                uuid.UUID       `db:"organization_id" json:"organization_id"`
	Deleted                       bool            `db:"deleted" json:"deleted"`
	Name                          string          `db:"name" json:"name"`
	Provisioner                   ProvisionerType `db:"provisioner" json:"provisioner"`
	ActiveVersionID               uuid.UUID       `db:"active_version_id" json:"active_version_id"`
	Description                   string          `db:"description" json:"description"`
	DefaultTTL                    int64           `db:"default_ttl" json:"default_ttl"`
	CreatedBy                     uuid.UUID       `db:"created_by" json:"created_by"`
	Icon                          string          `db:"icon" json:"icon"`
	UserACL                       TemplateACL     `db:"user_acl" json:"user_acl"`
	GroupACL                      TemplateACL     `db:"group_acl" json:"group_acl"`
	DisplayName                   string          `db:"display_name" json:"display_name"`
	AllowUserCancelWorkspaceJobs  bool            `db:"allow_user_cancel_workspace_jobs" json:"allow_user_cancel_workspace_jobs"`
	MaxTTL                        int64           `db:"max_ttl" json:"max_ttl"`
	AllowUserAutostart            bool            `db:"allow_user_autostart" json:"allow_user_autostart"`
	AllowUserAutostop             bool            `db:"allow_user_autostop" json:"allow_user_autostop"`
	FailureTTL                    int64           `db:"failure_ttl" json:"failure_ttl"`
	TimeTilDormant                int64           `db:"time_til_dormant" json:"time_til_dormant"`
	TimeTilDormantAutoDelete      int64           `db:"time_til_dormant_autodelete" json:"time_til_dormant_autodelete"`
	AutostopRequirementDaysOfWeek int16           `db:"autostop_requirement_days_of_week" json:"autostop_requirement_days_of_week"`
	AutostopRequirementWeeks      int64           `db:"autostop_requirement_weeks" json:"autostop_requirement_weeks"`
	AutostartBlockDaysOfWeek      int16           `db:"autostart_block_days_of_week" json:"autostart_block_days_of_week"`
	RequireActiveVersion          bool            `db:"require_active_version" json:"require_active_version"`
	Deprecated                    string          `db:"deprecated" json:"deprecated"`
	UseMaxTtl                     bool            `db:"use_max_ttl" json:"use_max_ttl"`
	CreatedByAvatarURL            string          `db:"created_by_avatar_url" json:"created_by_avatar_url"`
	CreatedByUsername             string          `db:"created_by_username" json:"created_by_username"`
}

type TemplateTable struct {
	ID              uuid.UUID       `db:"id" json:"id"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	OrganizationID  uuid.UUID       `db:"organization_id" json:"organization_id"`
	Deleted         bool            `db:"deleted" json:"deleted"`
	Name            string          `db:"name" json:"name"`
	Provisioner     ProvisionerType `db:"provisioner" json:"provisioner"`
	ActiveVersionID uuid.UUID       `db:"active_version_id" json:"active_version_id"`
	Description     string          `db:"description" json:"description"`
	// The default duration for autostop for workspaces created from this template.
	DefaultTTL int64       `db:"default_ttl" json:"default_ttl"`
	CreatedBy  uuid.UUID   `db:"created_by" json:"created_by"`
	Icon       string      `db:"icon" json:"icon"`
	UserACL    TemplateACL `db:"user_acl" json:"user_acl"`
	GroupACL   TemplateACL `db:"group_acl" json:"group_acl"`
	// Display name is a custom, human-friendly template name that user can set.
	DisplayName string `db:"display_name" json:"display_name"`
	// Allow users to cancel in-progress workspace jobs.
	AllowUserCancelWorkspaceJobs bool  `db:"allow_user_cancel_workspace_jobs" json:"allow_user_cancel_workspace_jobs"`
	MaxTTL                       int64 `db:"max_ttl" json:"max_ttl"`
	// Allow users to specify an autostart schedule for workspaces (enterprise).
	AllowUserAutostart bool `db:"allow_user_autostart" json:"allow_user_autostart"`
	// Allow users to specify custom autostop values for workspaces (enterprise).
	AllowUserAutostop        bool  `db:"allow_user_autostop" json:"allow_user_autostop"`
	FailureTTL               int64 `db:"failure_ttl" json:"failure_ttl"`
	TimeTilDormant           int64 `db:"time_til_dormant" json:"time_til_dormant"`
	TimeTilDormantAutoDelete int64 `db:"time_til_dormant_autodelete" json:"time_til_dormant_autodelete"`
	// A bitmap of days of week to restart the workspace on, starting with Monday as the 0th bit, and Sunday as the 6th bit. The 7th bit is unused.
	AutostopRequirementDaysOfWeek int16 `db:"autostop_requirement_days_of_week" json:"autostop_requirement_days_of_week"`
	// The number of weeks between restarts. 0 or 1 weeks means "every week", 2 week means "every second week", etc. Weeks are counted from January 2, 2023, which is the first Monday of 2023. This is to ensure workspaces are started consistently for all customers on the same n-week cycles.
	AutostopRequirementWeeks int64 `db:"autostop_requirement_weeks" json:"autostop_requirement_weeks"`
	// A bitmap of days of week that autostart of a workspace is not allowed. Default allows all days. This is intended as a cost savings measure to prevent auto start on weekends (for example).
	AutostartBlockDaysOfWeek int16 `db:"autostart_block_days_of_week" json:"autostart_block_days_of_week"`
	RequireActiveVersion     bool  `db:"require_active_version" json:"require_active_version"`
	// If set to a non empty string, the template will no longer be able to be used. The message will be displayed to the user.
	Deprecated string `db:"deprecated" json:"deprecated"`
	UseMaxTtl  bool   `db:"use_max_ttl" json:"use_max_ttl"`
}

// Joins in the username + avatar url of the created by user.
type TemplateVersion struct {
	ID                    uuid.UUID     `db:"id" json:"id"`
	TemplateID            uuid.NullUUID `db:"template_id" json:"template_id"`
	OrganizationID        uuid.UUID     `db:"organization_id" json:"organization_id"`
	CreatedAt             time.Time     `db:"created_at" json:"created_at"`
	UpdatedAt             time.Time     `db:"updated_at" json:"updated_at"`
	Name                  string        `db:"name" json:"name"`
	Readme                string        `db:"readme" json:"readme"`
	JobID                 uuid.UUID     `db:"job_id" json:"job_id"`
	CreatedBy             uuid.UUID     `db:"created_by" json:"created_by"`
	ExternalAuthProviders []string      `db:"external_auth_providers" json:"external_auth_providers"`
	Message               string        `db:"message" json:"message"`
	Archived              bool          `db:"archived" json:"archived"`
	CreatedByAvatarURL    string        `db:"created_by_avatar_url" json:"created_by_avatar_url"`
	CreatedByUsername     string        `db:"created_by_username" json:"created_by_username"`
}

type TemplateVersionParameter struct {
	TemplateVersionID uuid.UUID `db:"template_version_id" json:"template_version_id"`
	// Parameter name
	Name string `db:"name" json:"name"`
	// Parameter description
	Description string `db:"description" json:"description"`
	// Parameter type
	Type string `db:"type" json:"type"`
	// Is parameter mutable?
	Mutable bool `db:"mutable" json:"mutable"`
	// Default value
	DefaultValue string `db:"default_value" json:"default_value"`
	// Icon
	Icon string `db:"icon" json:"icon"`
	// Additional options
	Options json.RawMessage `db:"options" json:"options"`
	// Validation: regex pattern
	ValidationRegex string `db:"validation_regex" json:"validation_regex"`
	// Validation: minimum length of value
	ValidationMin sql.NullInt32 `db:"validation_min" json:"validation_min"`
	// Validation: maximum length of value
	ValidationMax sql.NullInt32 `db:"validation_max" json:"validation_max"`
	// Validation: error displayed when the regex does not match.
	ValidationError string `db:"validation_error" json:"validation_error"`
	// Validation: consecutive values preserve the monotonic order
	ValidationMonotonic string `db:"validation_monotonic" json:"validation_monotonic"`
	// Is parameter required?
	Required bool `db:"required" json:"required"`
	// Display name of the rich parameter
	DisplayName string `db:"display_name" json:"display_name"`
	// Specifies the order in which to display parameters in user interfaces.
	DisplayOrder int32 `db:"display_order" json:"display_order"`
	// The value of an ephemeral parameter will not be preserved between consecutive workspace builds.
	Ephemeral bool `db:"ephemeral" json:"ephemeral"`
}

type TemplateVersionTable struct {
	ID             uuid.UUID     `db:"id" json:"id"`
	TemplateID     uuid.NullUUID `db:"template_id" json:"template_id"`
	OrganizationID uuid.UUID     `db:"organization_id" json:"organization_id"`
	CreatedAt      time.Time     `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time     `db:"updated_at" json:"updated_at"`
	Name           string        `db:"name" json:"name"`
	Readme         string        `db:"readme" json:"readme"`
	JobID          uuid.UUID     `db:"job_id" json:"job_id"`
	CreatedBy      uuid.UUID     `db:"created_by" json:"created_by"`
	// IDs of External auth providers for a specific template version
	ExternalAuthProviders []string `db:"external_auth_providers" json:"external_auth_providers"`
	// Message describing the changes in this version of the template, similar to a Git commit message. Like a commit message, this should be a short, high-level description of the changes in this version of the template. This message is immutable and should not be updated after the fact.
	Message  string `db:"message" json:"message"`
	Archived bool   `db:"archived" json:"archived"`
}

type TemplateVersionVariable struct {
	TemplateVersionID uuid.UUID `db:"template_version_id" json:"template_version_id"`
	// Variable name
	Name string `db:"name" json:"name"`
	// Variable description
	Description string `db:"description" json:"description"`
	// Variable type
	Type string `db:"type" json:"type"`
	// Variable value
	Value string `db:"value" json:"value"`
	// Variable default value
	DefaultValue string `db:"default_value" json:"default_value"`
	// Required variables needs a default value or a value provided by template admin
	Required bool `db:"required" json:"required"`
	// Sensitive variables have their values redacted in logs or site UI
	Sensitive bool `db:"sensitive" json:"sensitive"`
}

type User struct {
	ID             uuid.UUID      `db:"id" json:"id"`
	Email          string         `db:"email" json:"email"`
	Username       string         `db:"username" json:"username"`
	HashedPassword []byte         `db:"hashed_password" json:"hashed_password"`
	CreatedAt      time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time      `db:"updated_at" json:"updated_at"`
	Status         UserStatus     `db:"status" json:"status"`
	RBACRoles      pq.StringArray `db:"rbac_roles" json:"rbac_roles"`
	LoginType      LoginType      `db:"login_type" json:"login_type"`
	AvatarURL      string         `db:"avatar_url" json:"avatar_url"`
	Deleted        bool           `db:"deleted" json:"deleted"`
	LastSeenAt     time.Time      `db:"last_seen_at" json:"last_seen_at"`
	// Daily (!) cron schedule (with optional CRON_TZ) signifying the start of the user's quiet hours. If empty, the default quiet hours on the instance is used instead.
	QuietHoursSchedule string `db:"quiet_hours_schedule" json:"quiet_hours_schedule"`
	// "" can be interpreted as "the user does not care", falling back to the default theme
	ThemePreference string `db:"theme_preference" json:"theme_preference"`
	// Name of the Coder user
	Name string `db:"name" json:"name"`
}

type UserLink struct {
	UserID            uuid.UUID `db:"user_id" json:"user_id"`
	LoginType         LoginType `db:"login_type" json:"login_type"`
	LinkedID          string    `db:"linked_id" json:"linked_id"`
	OAuthAccessToken  string    `db:"oauth_access_token" json:"oauth_access_token"`
	OAuthRefreshToken string    `db:"oauth_refresh_token" json:"oauth_refresh_token"`
	OAuthExpiry       time.Time `db:"oauth_expiry" json:"oauth_expiry"`
	// The ID of the key used to encrypt the OAuth access token. If this is NULL, the access token is not encrypted
	OAuthAccessTokenKeyID sql.NullString `db:"oauth_access_token_key_id" json:"oauth_access_token_key_id"`
	// The ID of the key used to encrypt the OAuth refresh token. If this is NULL, the refresh token is not encrypted
	OAuthRefreshTokenKeyID sql.NullString `db:"oauth_refresh_token_key_id" json:"oauth_refresh_token_key_id"`
	// Debug information includes information like id_token and userinfo claims.
	DebugContext json.RawMessage `db:"debug_context" json:"debug_context"`
}

// Visible fields of users are allowed to be joined with other tables for including context of other resources.
type VisibleUser struct {
	ID        uuid.UUID `db:"id" json:"id"`
	Username  string    `db:"username" json:"username"`
	AvatarURL string    `db:"avatar_url" json:"avatar_url"`
}

type Workspace struct {
	ID                uuid.UUID        `db:"id" json:"id"`
	CreatedAt         time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt         time.Time        `db:"updated_at" json:"updated_at"`
	OwnerID           uuid.UUID        `db:"owner_id" json:"owner_id"`
	OrganizationID    uuid.UUID        `db:"organization_id" json:"organization_id"`
	TemplateID        uuid.UUID        `db:"template_id" json:"template_id"`
	Deleted           bool             `db:"deleted" json:"deleted"`
	Name              string           `db:"name" json:"name"`
	AutostartSchedule sql.NullString   `db:"autostart_schedule" json:"autostart_schedule"`
	Ttl               sql.NullInt64    `db:"ttl" json:"ttl"`
	LastUsedAt        time.Time        `db:"last_used_at" json:"last_used_at"`
	DormantAt         sql.NullTime     `db:"dormant_at" json:"dormant_at"`
	DeletingAt        sql.NullTime     `db:"deleting_at" json:"deleting_at"`
	AutomaticUpdates  AutomaticUpdates `db:"automatic_updates" json:"automatic_updates"`
	// Favorite is true if the workspace owner has favorited the workspace.
	Favorite bool `db:"favorite" json:"favorite"`
}

type WorkspaceAgent struct {
	ID                   uuid.UUID             `db:"id" json:"id"`
	CreatedAt            time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt            time.Time             `db:"updated_at" json:"updated_at"`
	Name                 string                `db:"name" json:"name"`
	FirstConnectedAt     sql.NullTime          `db:"first_connected_at" json:"first_connected_at"`
	LastConnectedAt      sql.NullTime          `db:"last_connected_at" json:"last_connected_at"`
	DisconnectedAt       sql.NullTime          `db:"disconnected_at" json:"disconnected_at"`
	ResourceID           uuid.UUID             `db:"resource_id" json:"resource_id"`
	AuthToken            uuid.UUID             `db:"auth_token" json:"auth_token"`
	AuthInstanceID       sql.NullString        `db:"auth_instance_id" json:"auth_instance_id"`
	Architecture         string                `db:"architecture" json:"architecture"`
	EnvironmentVariables pqtype.NullRawMessage `db:"environment_variables" json:"environment_variables"`
	OperatingSystem      string                `db:"operating_system" json:"operating_system"`
	InstanceMetadata     pqtype.NullRawMessage `db:"instance_metadata" json:"instance_metadata"`
	ResourceMetadata     pqtype.NullRawMessage `db:"resource_metadata" json:"resource_metadata"`
	Directory            string                `db:"directory" json:"directory"`
	// Version tracks the version of the currently running workspace agent. Workspace agents register their version upon start.
	Version                string        `db:"version" json:"version"`
	LastConnectedReplicaID uuid.NullUUID `db:"last_connected_replica_id" json:"last_connected_replica_id"`
	// Connection timeout in seconds, 0 means disabled.
	ConnectionTimeoutSeconds int32 `db:"connection_timeout_seconds" json:"connection_timeout_seconds"`
	// URL for troubleshooting the agent.
	TroubleshootingURL string `db:"troubleshooting_url" json:"troubleshooting_url"`
	// Path to file inside workspace containing the message of the day (MOTD) to show to the user when logging in via SSH.
	MOTDFile string `db:"motd_file" json:"motd_file"`
	// The current lifecycle state reported by the workspace agent.
	LifecycleState WorkspaceAgentLifecycleState `db:"lifecycle_state" json:"lifecycle_state"`
	// The resolved path of a user-specified directory. e.g. ~/coder -> /home/coder/coder
	ExpandedDirectory string `db:"expanded_directory" json:"expanded_directory"`
	// Total length of startup logs
	LogsLength int32 `db:"logs_length" json:"logs_length"`
	// Whether the startup logs overflowed in length
	LogsOverflowed bool `db:"logs_overflowed" json:"logs_overflowed"`
	// The time the agent entered the starting lifecycle state
	StartedAt sql.NullTime `db:"started_at" json:"started_at"`
	// The time the agent entered the ready or start_error lifecycle state
	ReadyAt     sql.NullTime              `db:"ready_at" json:"ready_at"`
	Subsystems  []WorkspaceAgentSubsystem `db:"subsystems" json:"subsystems"`
	DisplayApps []DisplayApp              `db:"display_apps" json:"display_apps"`
	APIVersion  string                    `db:"api_version" json:"api_version"`
}

type WorkspaceAgentLog struct {
	AgentID     uuid.UUID `db:"agent_id" json:"agent_id"`
	CreatedAt   time.Time `db:"created_at" json:"created_at"`
	Output      string    `db:"output" json:"output"`
	ID          int64     `db:"id" json:"id"`
	Level       LogLevel  `db:"level" json:"level"`
	LogSourceID uuid.UUID `db:"log_source_id" json:"log_source_id"`
}

type WorkspaceAgentLogSource struct {
	WorkspaceAgentID uuid.UUID `db:"workspace_agent_id" json:"workspace_agent_id"`
	ID               uuid.UUID `db:"id" json:"id"`
	CreatedAt        time.Time `db:"created_at" json:"created_at"`
	DisplayName      string    `db:"display_name" json:"display_name"`
	Icon             string    `db:"icon" json:"icon"`
}

type WorkspaceAgentMetadatum struct {
	WorkspaceAgentID uuid.UUID `db:"workspace_agent_id" json:"workspace_agent_id"`
	DisplayName      string    `db:"display_name" json:"display_name"`
	Key              string    `db:"key" json:"key"`
	Script           string    `db:"script" json:"script"`
	Value            string    `db:"value" json:"value"`
	Error            string    `db:"error" json:"error"`
	Timeout          int64     `db:"timeout" json:"timeout"`
	Interval         int64     `db:"interval" json:"interval"`
	CollectedAt      time.Time `db:"collected_at" json:"collected_at"`
}

type WorkspaceAgentScript struct {
	WorkspaceAgentID uuid.UUID `db:"workspace_agent_id" json:"workspace_agent_id"`
	LogSourceID      uuid.UUID `db:"log_source_id" json:"log_source_id"`
	LogPath          string    `db:"log_path" json:"log_path"`
	CreatedAt        time.Time `db:"created_at" json:"created_at"`
	Script           string    `db:"script" json:"script"`
	Cron             string    `db:"cron" json:"cron"`
	StartBlocksLogin bool      `db:"start_blocks_login" json:"start_blocks_login"`
	RunOnStart       bool      `db:"run_on_start" json:"run_on_start"`
	RunOnStop        bool      `db:"run_on_stop" json:"run_on_stop"`
	TimeoutSeconds   int32     `db:"timeout_seconds" json:"timeout_seconds"`
}

type WorkspaceAgentStat struct {
	ID                          uuid.UUID       `db:"id" json:"id"`
	CreatedAt                   time.Time       `db:"created_at" json:"created_at"`
	UserID                      uuid.UUID       `db:"user_id" json:"user_id"`
	AgentID                     uuid.UUID       `db:"agent_id" json:"agent_id"`
	WorkspaceID                 uuid.UUID       `db:"workspace_id" json:"workspace_id"`
	TemplateID                  uuid.UUID       `db:"template_id" json:"template_id"`
	ConnectionsByProto          json.RawMessage `db:"connections_by_proto" json:"connections_by_proto"`
	ConnectionCount             int64           `db:"connection_count" json:"connection_count"`
	RxPackets                   int64           `db:"rx_packets" json:"rx_packets"`
	RxBytes                     int64           `db:"rx_bytes" json:"rx_bytes"`
	TxPackets                   int64           `db:"tx_packets" json:"tx_packets"`
	TxBytes                     int64           `db:"tx_bytes" json:"tx_bytes"`
	ConnectionMedianLatencyMS   float64         `db:"connection_median_latency_ms" json:"connection_median_latency_ms"`
	SessionCountVSCode          int64           `db:"session_count_vscode" json:"session_count_vscode"`
	SessionCountJetBrains       int64           `db:"session_count_jetbrains" json:"session_count_jetbrains"`
	SessionCountReconnectingPTY int64           `db:"session_count_reconnecting_pty" json:"session_count_reconnecting_pty"`
	SessionCountSSH             int64           `db:"session_count_ssh" json:"session_count_ssh"`
}

type WorkspaceApp struct {
	ID                   uuid.UUID          `db:"id" json:"id"`
	CreatedAt            time.Time          `db:"created_at" json:"created_at"`
	AgentID              uuid.UUID          `db:"agent_id" json:"agent_id"`
	DisplayName          string             `db:"display_name" json:"display_name"`
	Icon                 string             `db:"icon" json:"icon"`
	Command              sql.NullString     `db:"command" json:"command"`
	Url                  sql.NullString     `db:"url" json:"url"`
	HealthcheckUrl       string             `db:"healthcheck_url" json:"healthcheck_url"`
	HealthcheckInterval  int32              `db:"healthcheck_interval" json:"healthcheck_interval"`
	HealthcheckThreshold int32              `db:"healthcheck_threshold" json:"healthcheck_threshold"`
	Health               WorkspaceAppHealth `db:"health" json:"health"`
	Subdomain            bool               `db:"subdomain" json:"subdomain"`
	SharingLevel         AppSharingLevel    `db:"sharing_level" json:"sharing_level"`
	Slug                 string             `db:"slug" json:"slug"`
	External             bool               `db:"external" json:"external"`
}

// A record of workspace app usage statistics
type WorkspaceAppStat struct {
	// The ID of the record
	ID int64 `db:"id" json:"id"`
	// The user who used the workspace app
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	// The workspace that the workspace app was used in
	WorkspaceID uuid.UUID `db:"workspace_id" json:"workspace_id"`
	// The workspace agent that was used
	AgentID uuid.UUID `db:"agent_id" json:"agent_id"`
	// The method used to access the workspace app
	AccessMethod string `db:"access_method" json:"access_method"`
	// The slug or port used to to identify the app
	SlugOrPort string `db:"slug_or_port" json:"slug_or_port"`
	// The unique identifier for the session
	SessionID uuid.UUID `db:"session_id" json:"session_id"`
	// The time the session started
	SessionStartedAt time.Time `db:"session_started_at" json:"session_started_at"`
	// The time the session ended
	SessionEndedAt time.Time `db:"session_ended_at" json:"session_ended_at"`
	// The number of requests made during the session, a number larger than 1 indicates that multiple sessions were rolled up into one
	Requests int32 `db:"requests" json:"requests"`
}

// Joins in the username + avatar url of the initiated by user.
type WorkspaceBuild struct {
	ID                   uuid.UUID           `db:"id" json:"id"`
	CreatedAt            time.Time           `db:"created_at" json:"created_at"`
	UpdatedAt            time.Time           `db:"updated_at" json:"updated_at"`
	WorkspaceID          uuid.UUID           `db:"workspace_id" json:"workspace_id"`
	TemplateVersionID    uuid.UUID           `db:"template_version_id" json:"template_version_id"`
	BuildNumber          int32               `db:"build_number" json:"build_number"`
	Transition           WorkspaceTransition `db:"transition" json:"transition"`
	InitiatorID          uuid.UUID           `db:"initiator_id" json:"initiator_id"`
	ProvisionerState     []byte              `db:"provisioner_state" json:"provisioner_state"`
	JobID                uuid.UUID           `db:"job_id" json:"job_id"`
	Deadline             time.Time           `db:"deadline" json:"deadline"`
	Reason               BuildReason         `db:"reason" json:"reason"`
	DailyCost            int32               `db:"daily_cost" json:"daily_cost"`
	MaxDeadline          time.Time           `db:"max_deadline" json:"max_deadline"`
	InitiatorByAvatarUrl string              `db:"initiator_by_avatar_url" json:"initiator_by_avatar_url"`
	InitiatorByUsername  string              `db:"initiator_by_username" json:"initiator_by_username"`
}

type WorkspaceBuildParameter struct {
	WorkspaceBuildID uuid.UUID `db:"workspace_build_id" json:"workspace_build_id"`
	// Parameter name
	Name string `db:"name" json:"name"`
	// Parameter value
	Value string `db:"value" json:"value"`
}

type WorkspaceBuildTable struct {
	ID                uuid.UUID           `db:"id" json:"id"`
	CreatedAt         time.Time           `db:"created_at" json:"created_at"`
	UpdatedAt         time.Time           `db:"updated_at" json:"updated_at"`
	WorkspaceID       uuid.UUID           `db:"workspace_id" json:"workspace_id"`
	TemplateVersionID uuid.UUID           `db:"template_version_id" json:"template_version_id"`
	BuildNumber       int32               `db:"build_number" json:"build_number"`
	Transition        WorkspaceTransition `db:"transition" json:"transition"`
	InitiatorID       uuid.UUID           `db:"initiator_id" json:"initiator_id"`
	ProvisionerState  []byte              `db:"provisioner_state" json:"provisioner_state"`
	JobID             uuid.UUID           `db:"job_id" json:"job_id"`
	Deadline          time.Time           `db:"deadline" json:"deadline"`
	Reason            BuildReason         `db:"reason" json:"reason"`
	DailyCost         int32               `db:"daily_cost" json:"daily_cost"`
	MaxDeadline       time.Time           `db:"max_deadline" json:"max_deadline"`
}

type WorkspaceProxy struct {
	ID          uuid.UUID `db:"id" json:"id"`
	Name        string    `db:"name" json:"name"`
	DisplayName string    `db:"display_name" json:"display_name"`
	// Expects an emoji character. (/emojis/1f1fa-1f1f8.png)
	Icon string `db:"icon" json:"icon"`
	// Full url including scheme of the proxy api url: https://us.example.com
	Url string `db:"url" json:"url"`
	// Hostname with the wildcard for subdomain based app hosting: *.us.example.com
	WildcardHostname string    `db:"wildcard_hostname" json:"wildcard_hostname"`
	CreatedAt        time.Time `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time `db:"updated_at" json:"updated_at"`
	// Boolean indicator of a deleted workspace proxy. Proxies are soft-deleted.
	Deleted bool `db:"deleted" json:"deleted"`
	// Hashed secret is used to authenticate the workspace proxy using a session token.
	TokenHashedSecret []byte `db:"token_hashed_secret" json:"token_hashed_secret"`
	RegionID          int32  `db:"region_id" json:"region_id"`
	DerpEnabled       bool   `db:"derp_enabled" json:"derp_enabled"`
	// Disables app/terminal proxying for this proxy and only acts as a DERP relay.
	DerpOnly bool   `db:"derp_only" json:"derp_only"`
	Version  string `db:"version" json:"version"`
}

type WorkspaceResource struct {
	ID           uuid.UUID           `db:"id" json:"id"`
	CreatedAt    time.Time           `db:"created_at" json:"created_at"`
	JobID        uuid.UUID           `db:"job_id" json:"job_id"`
	Transition   WorkspaceTransition `db:"transition" json:"transition"`
	Type         string              `db:"type" json:"type"`
	Name         string              `db:"name" json:"name"`
	Hide         bool                `db:"hide" json:"hide"`
	Icon         string              `db:"icon" json:"icon"`
	InstanceType sql.NullString      `db:"instance_type" json:"instance_type"`
	DailyCost    int32               `db:"daily_cost" json:"daily_cost"`
}

type WorkspaceResourceMetadatum struct {
	WorkspaceResourceID uuid.UUID      `db:"workspace_resource_id" json:"workspace_resource_id"`
	Key                 string         `db:"key" json:"key"`
	Value               sql.NullString `db:"value" json:"value"`
	Sensitive           bool           `db:"sensitive" json:"sensitive"`
	ID                  int64          `db:"id" json:"id"`
}
