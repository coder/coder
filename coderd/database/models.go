// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0

package database

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/tabbed/pqtype"
)

type APIKeyScope string

const (
	APIKeyScopeAll                APIKeyScope = "all"
	APIKeyScopeApplicationConnect APIKeyScope = "application_connect"
)

func (e *APIKeyScope) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = APIKeyScope(s)
	case string:
		*e = APIKeyScope(s)
	default:
		return fmt.Errorf("unsupported scan type for APIKeyScope: %T", src)
	}
	return nil
}

type NullAPIKeyScope struct {
	APIKeyScope APIKeyScope
	Valid       bool // Valid is true if APIKeyScope is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAPIKeyScope) Scan(value interface{}) error {
	if value == nil {
		ns.APIKeyScope, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.APIKeyScope.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAPIKeyScope) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.APIKeyScope), nil
}

func (e APIKeyScope) Valid() bool {
	switch e {
	case APIKeyScopeAll,
		APIKeyScopeApplicationConnect:
		return true
	}
	return false
}

func AllAPIKeyScopeValues() []APIKeyScope {
	return []APIKeyScope{
		APIKeyScopeAll,
		APIKeyScopeApplicationConnect,
	}
}

type AppSharingLevel string

const (
	AppSharingLevelOwner         AppSharingLevel = "owner"
	AppSharingLevelAuthenticated AppSharingLevel = "authenticated"
	AppSharingLevelPublic        AppSharingLevel = "public"
)

func (e *AppSharingLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AppSharingLevel(s)
	case string:
		*e = AppSharingLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for AppSharingLevel: %T", src)
	}
	return nil
}

type NullAppSharingLevel struct {
	AppSharingLevel AppSharingLevel
	Valid           bool // Valid is true if AppSharingLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAppSharingLevel) Scan(value interface{}) error {
	if value == nil {
		ns.AppSharingLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AppSharingLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAppSharingLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AppSharingLevel), nil
}

func (e AppSharingLevel) Valid() bool {
	switch e {
	case AppSharingLevelOwner,
		AppSharingLevelAuthenticated,
		AppSharingLevelPublic:
		return true
	}
	return false
}

func AllAppSharingLevelValues() []AppSharingLevel {
	return []AppSharingLevel{
		AppSharingLevelOwner,
		AppSharingLevelAuthenticated,
		AppSharingLevelPublic,
	}
}

type AuditAction string

const (
	AuditActionCreate   AuditAction = "create"
	AuditActionWrite    AuditAction = "write"
	AuditActionDelete   AuditAction = "delete"
	AuditActionStart    AuditAction = "start"
	AuditActionStop     AuditAction = "stop"
	AuditActionLogin    AuditAction = "login"
	AuditActionLogout   AuditAction = "logout"
	AuditActionRegister AuditAction = "register"
)

func (e *AuditAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuditAction(s)
	case string:
		*e = AuditAction(s)
	default:
		return fmt.Errorf("unsupported scan type for AuditAction: %T", src)
	}
	return nil
}

type NullAuditAction struct {
	AuditAction AuditAction
	Valid       bool // Valid is true if AuditAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuditAction) Scan(value interface{}) error {
	if value == nil {
		ns.AuditAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuditAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuditAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuditAction), nil
}

func (e AuditAction) Valid() bool {
	switch e {
	case AuditActionCreate,
		AuditActionWrite,
		AuditActionDelete,
		AuditActionStart,
		AuditActionStop,
		AuditActionLogin,
		AuditActionLogout,
		AuditActionRegister:
		return true
	}
	return false
}

func AllAuditActionValues() []AuditAction {
	return []AuditAction{
		AuditActionCreate,
		AuditActionWrite,
		AuditActionDelete,
		AuditActionStart,
		AuditActionStop,
		AuditActionLogin,
		AuditActionLogout,
		AuditActionRegister,
	}
}

type BuildReason string

const (
	BuildReasonInitiator  BuildReason = "initiator"
	BuildReasonAutostart  BuildReason = "autostart"
	BuildReasonAutostop   BuildReason = "autostop"
	BuildReasonAutolock   BuildReason = "autolock"
	BuildReasonFailedstop BuildReason = "failedstop"
	BuildReasonAutodelete BuildReason = "autodelete"
)

func (e *BuildReason) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BuildReason(s)
	case string:
		*e = BuildReason(s)
	default:
		return fmt.Errorf("unsupported scan type for BuildReason: %T", src)
	}
	return nil
}

type NullBuildReason struct {
	BuildReason BuildReason
	Valid       bool // Valid is true if BuildReason is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBuildReason) Scan(value interface{}) error {
	if value == nil {
		ns.BuildReason, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BuildReason.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBuildReason) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BuildReason), nil
}

func (e BuildReason) Valid() bool {
	switch e {
	case BuildReasonInitiator,
		BuildReasonAutostart,
		BuildReasonAutostop,
		BuildReasonAutolock,
		BuildReasonFailedstop,
		BuildReasonAutodelete:
		return true
	}
	return false
}

func AllBuildReasonValues() []BuildReason {
	return []BuildReason{
		BuildReasonInitiator,
		BuildReasonAutostart,
		BuildReasonAutostop,
		BuildReasonAutolock,
		BuildReasonFailedstop,
		BuildReasonAutodelete,
	}
}

type LogLevel string

const (
	LogLevelTrace LogLevel = "trace"
	LogLevelDebug LogLevel = "debug"
	LogLevelInfo  LogLevel = "info"
	LogLevelWarn  LogLevel = "warn"
	LogLevelError LogLevel = "error"
)

func (e *LogLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LogLevel(s)
	case string:
		*e = LogLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for LogLevel: %T", src)
	}
	return nil
}

type NullLogLevel struct {
	LogLevel LogLevel
	Valid    bool // Valid is true if LogLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLogLevel) Scan(value interface{}) error {
	if value == nil {
		ns.LogLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LogLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLogLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LogLevel), nil
}

func (e LogLevel) Valid() bool {
	switch e {
	case LogLevelTrace,
		LogLevelDebug,
		LogLevelInfo,
		LogLevelWarn,
		LogLevelError:
		return true
	}
	return false
}

func AllLogLevelValues() []LogLevel {
	return []LogLevel{
		LogLevelTrace,
		LogLevelDebug,
		LogLevelInfo,
		LogLevelWarn,
		LogLevelError,
	}
}

type LogSource string

const (
	LogSourceProvisionerDaemon LogSource = "provisioner_daemon"
	LogSourceProvisioner       LogSource = "provisioner"
)

func (e *LogSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LogSource(s)
	case string:
		*e = LogSource(s)
	default:
		return fmt.Errorf("unsupported scan type for LogSource: %T", src)
	}
	return nil
}

type NullLogSource struct {
	LogSource LogSource
	Valid     bool // Valid is true if LogSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLogSource) Scan(value interface{}) error {
	if value == nil {
		ns.LogSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LogSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLogSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LogSource), nil
}

func (e LogSource) Valid() bool {
	switch e {
	case LogSourceProvisionerDaemon,
		LogSourceProvisioner:
		return true
	}
	return false
}

func AllLogSourceValues() []LogSource {
	return []LogSource{
		LogSourceProvisionerDaemon,
		LogSourceProvisioner,
	}
}

// Specifies the method of authentication. "none" is a special case in which no authentication method is allowed.
type LoginType string

const (
	LoginTypePassword LoginType = "password"
	LoginTypeGithub   LoginType = "github"
	LoginTypeOIDC     LoginType = "oidc"
	LoginTypeToken    LoginType = "token"
	LoginTypeNone     LoginType = "none"
)

func (e *LoginType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LoginType(s)
	case string:
		*e = LoginType(s)
	default:
		return fmt.Errorf("unsupported scan type for LoginType: %T", src)
	}
	return nil
}

type NullLoginType struct {
	LoginType LoginType
	Valid     bool // Valid is true if LoginType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLoginType) Scan(value interface{}) error {
	if value == nil {
		ns.LoginType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LoginType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLoginType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LoginType), nil
}

func (e LoginType) Valid() bool {
	switch e {
	case LoginTypePassword,
		LoginTypeGithub,
		LoginTypeOIDC,
		LoginTypeToken,
		LoginTypeNone:
		return true
	}
	return false
}

func AllLoginTypeValues() []LoginType {
	return []LoginType{
		LoginTypePassword,
		LoginTypeGithub,
		LoginTypeOIDC,
		LoginTypeToken,
		LoginTypeNone,
	}
}

type ParameterDestinationScheme string

const (
	ParameterDestinationSchemeNone                ParameterDestinationScheme = "none"
	ParameterDestinationSchemeEnvironmentVariable ParameterDestinationScheme = "environment_variable"
	ParameterDestinationSchemeProvisionerVariable ParameterDestinationScheme = "provisioner_variable"
)

func (e *ParameterDestinationScheme) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParameterDestinationScheme(s)
	case string:
		*e = ParameterDestinationScheme(s)
	default:
		return fmt.Errorf("unsupported scan type for ParameterDestinationScheme: %T", src)
	}
	return nil
}

type NullParameterDestinationScheme struct {
	ParameterDestinationScheme ParameterDestinationScheme
	Valid                      bool // Valid is true if ParameterDestinationScheme is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParameterDestinationScheme) Scan(value interface{}) error {
	if value == nil {
		ns.ParameterDestinationScheme, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParameterDestinationScheme.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParameterDestinationScheme) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParameterDestinationScheme), nil
}

func (e ParameterDestinationScheme) Valid() bool {
	switch e {
	case ParameterDestinationSchemeNone,
		ParameterDestinationSchemeEnvironmentVariable,
		ParameterDestinationSchemeProvisionerVariable:
		return true
	}
	return false
}

func AllParameterDestinationSchemeValues() []ParameterDestinationScheme {
	return []ParameterDestinationScheme{
		ParameterDestinationSchemeNone,
		ParameterDestinationSchemeEnvironmentVariable,
		ParameterDestinationSchemeProvisionerVariable,
	}
}

type ParameterScope string

const (
	ParameterScopeTemplate  ParameterScope = "template"
	ParameterScopeImportJob ParameterScope = "import_job"
	ParameterScopeWorkspace ParameterScope = "workspace"
)

func (e *ParameterScope) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParameterScope(s)
	case string:
		*e = ParameterScope(s)
	default:
		return fmt.Errorf("unsupported scan type for ParameterScope: %T", src)
	}
	return nil
}

type NullParameterScope struct {
	ParameterScope ParameterScope
	Valid          bool // Valid is true if ParameterScope is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParameterScope) Scan(value interface{}) error {
	if value == nil {
		ns.ParameterScope, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParameterScope.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParameterScope) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParameterScope), nil
}

func (e ParameterScope) Valid() bool {
	switch e {
	case ParameterScopeTemplate,
		ParameterScopeImportJob,
		ParameterScopeWorkspace:
		return true
	}
	return false
}

func AllParameterScopeValues() []ParameterScope {
	return []ParameterScope{
		ParameterScopeTemplate,
		ParameterScopeImportJob,
		ParameterScopeWorkspace,
	}
}

type ParameterSourceScheme string

const (
	ParameterSourceSchemeNone ParameterSourceScheme = "none"
	ParameterSourceSchemeData ParameterSourceScheme = "data"
)

func (e *ParameterSourceScheme) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParameterSourceScheme(s)
	case string:
		*e = ParameterSourceScheme(s)
	default:
		return fmt.Errorf("unsupported scan type for ParameterSourceScheme: %T", src)
	}
	return nil
}

type NullParameterSourceScheme struct {
	ParameterSourceScheme ParameterSourceScheme
	Valid                 bool // Valid is true if ParameterSourceScheme is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParameterSourceScheme) Scan(value interface{}) error {
	if value == nil {
		ns.ParameterSourceScheme, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParameterSourceScheme.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParameterSourceScheme) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParameterSourceScheme), nil
}

func (e ParameterSourceScheme) Valid() bool {
	switch e {
	case ParameterSourceSchemeNone,
		ParameterSourceSchemeData:
		return true
	}
	return false
}

func AllParameterSourceSchemeValues() []ParameterSourceScheme {
	return []ParameterSourceScheme{
		ParameterSourceSchemeNone,
		ParameterSourceSchemeData,
	}
}

type ParameterTypeSystem string

const (
	ParameterTypeSystemNone ParameterTypeSystem = "none"
	ParameterTypeSystemHCL  ParameterTypeSystem = "hcl"
)

func (e *ParameterTypeSystem) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParameterTypeSystem(s)
	case string:
		*e = ParameterTypeSystem(s)
	default:
		return fmt.Errorf("unsupported scan type for ParameterTypeSystem: %T", src)
	}
	return nil
}

type NullParameterTypeSystem struct {
	ParameterTypeSystem ParameterTypeSystem
	Valid               bool // Valid is true if ParameterTypeSystem is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParameterTypeSystem) Scan(value interface{}) error {
	if value == nil {
		ns.ParameterTypeSystem, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParameterTypeSystem.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParameterTypeSystem) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParameterTypeSystem), nil
}

func (e ParameterTypeSystem) Valid() bool {
	switch e {
	case ParameterTypeSystemNone,
		ParameterTypeSystemHCL:
		return true
	}
	return false
}

func AllParameterTypeSystemValues() []ParameterTypeSystem {
	return []ParameterTypeSystem{
		ParameterTypeSystemNone,
		ParameterTypeSystemHCL,
	}
}

type ProvisionerJobType string

const (
	ProvisionerJobTypeTemplateVersionImport ProvisionerJobType = "template_version_import"
	ProvisionerJobTypeWorkspaceBuild        ProvisionerJobType = "workspace_build"
	ProvisionerJobTypeTemplateVersionDryRun ProvisionerJobType = "template_version_dry_run"
)

func (e *ProvisionerJobType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProvisionerJobType(s)
	case string:
		*e = ProvisionerJobType(s)
	default:
		return fmt.Errorf("unsupported scan type for ProvisionerJobType: %T", src)
	}
	return nil
}

type NullProvisionerJobType struct {
	ProvisionerJobType ProvisionerJobType
	Valid              bool // Valid is true if ProvisionerJobType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProvisionerJobType) Scan(value interface{}) error {
	if value == nil {
		ns.ProvisionerJobType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProvisionerJobType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProvisionerJobType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProvisionerJobType), nil
}

func (e ProvisionerJobType) Valid() bool {
	switch e {
	case ProvisionerJobTypeTemplateVersionImport,
		ProvisionerJobTypeWorkspaceBuild,
		ProvisionerJobTypeTemplateVersionDryRun:
		return true
	}
	return false
}

func AllProvisionerJobTypeValues() []ProvisionerJobType {
	return []ProvisionerJobType{
		ProvisionerJobTypeTemplateVersionImport,
		ProvisionerJobTypeWorkspaceBuild,
		ProvisionerJobTypeTemplateVersionDryRun,
	}
}

type ProvisionerStorageMethod string

const (
	ProvisionerStorageMethodFile ProvisionerStorageMethod = "file"
)

func (e *ProvisionerStorageMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProvisionerStorageMethod(s)
	case string:
		*e = ProvisionerStorageMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for ProvisionerStorageMethod: %T", src)
	}
	return nil
}

type NullProvisionerStorageMethod struct {
	ProvisionerStorageMethod ProvisionerStorageMethod
	Valid                    bool // Valid is true if ProvisionerStorageMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProvisionerStorageMethod) Scan(value interface{}) error {
	if value == nil {
		ns.ProvisionerStorageMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProvisionerStorageMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProvisionerStorageMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProvisionerStorageMethod), nil
}

func (e ProvisionerStorageMethod) Valid() bool {
	switch e {
	case ProvisionerStorageMethodFile:
		return true
	}
	return false
}

func AllProvisionerStorageMethodValues() []ProvisionerStorageMethod {
	return []ProvisionerStorageMethod{
		ProvisionerStorageMethodFile,
	}
}

type ProvisionerType string

const (
	ProvisionerTypeEcho      ProvisionerType = "echo"
	ProvisionerTypeTerraform ProvisionerType = "terraform"
)

func (e *ProvisionerType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProvisionerType(s)
	case string:
		*e = ProvisionerType(s)
	default:
		return fmt.Errorf("unsupported scan type for ProvisionerType: %T", src)
	}
	return nil
}

type NullProvisionerType struct {
	ProvisionerType ProvisionerType
	Valid           bool // Valid is true if ProvisionerType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProvisionerType) Scan(value interface{}) error {
	if value == nil {
		ns.ProvisionerType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProvisionerType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProvisionerType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProvisionerType), nil
}

func (e ProvisionerType) Valid() bool {
	switch e {
	case ProvisionerTypeEcho,
		ProvisionerTypeTerraform:
		return true
	}
	return false
}

func AllProvisionerTypeValues() []ProvisionerType {
	return []ProvisionerType{
		ProvisionerTypeEcho,
		ProvisionerTypeTerraform,
	}
}

type ResourceType string

const (
	ResourceTypeOrganization    ResourceType = "organization"
	ResourceTypeTemplate        ResourceType = "template"
	ResourceTypeTemplateVersion ResourceType = "template_version"
	ResourceTypeUser            ResourceType = "user"
	ResourceTypeWorkspace       ResourceType = "workspace"
	ResourceTypeGitSshKey       ResourceType = "git_ssh_key"
	ResourceTypeApiKey          ResourceType = "api_key"
	ResourceTypeGroup           ResourceType = "group"
	ResourceTypeWorkspaceBuild  ResourceType = "workspace_build"
	ResourceTypeLicense         ResourceType = "license"
	ResourceTypeWorkspaceProxy  ResourceType = "workspace_proxy"
	ResourceTypeConvertLogin    ResourceType = "convert_login"
)

func (e *ResourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ResourceType(s)
	case string:
		*e = ResourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for ResourceType: %T", src)
	}
	return nil
}

type NullResourceType struct {
	ResourceType ResourceType
	Valid        bool // Valid is true if ResourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullResourceType) Scan(value interface{}) error {
	if value == nil {
		ns.ResourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ResourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullResourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ResourceType), nil
}

func (e ResourceType) Valid() bool {
	switch e {
	case ResourceTypeOrganization,
		ResourceTypeTemplate,
		ResourceTypeTemplateVersion,
		ResourceTypeUser,
		ResourceTypeWorkspace,
		ResourceTypeGitSshKey,
		ResourceTypeApiKey,
		ResourceTypeGroup,
		ResourceTypeWorkspaceBuild,
		ResourceTypeLicense,
		ResourceTypeWorkspaceProxy,
		ResourceTypeConvertLogin:
		return true
	}
	return false
}

func AllResourceTypeValues() []ResourceType {
	return []ResourceType{
		ResourceTypeOrganization,
		ResourceTypeTemplate,
		ResourceTypeTemplateVersion,
		ResourceTypeUser,
		ResourceTypeWorkspace,
		ResourceTypeGitSshKey,
		ResourceTypeApiKey,
		ResourceTypeGroup,
		ResourceTypeWorkspaceBuild,
		ResourceTypeLicense,
		ResourceTypeWorkspaceProxy,
		ResourceTypeConvertLogin,
	}
}

type StartupScriptBehavior string

const (
	StartupScriptBehaviorBlocking    StartupScriptBehavior = "blocking"
	StartupScriptBehaviorNonBlocking StartupScriptBehavior = "non-blocking"
)

func (e *StartupScriptBehavior) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StartupScriptBehavior(s)
	case string:
		*e = StartupScriptBehavior(s)
	default:
		return fmt.Errorf("unsupported scan type for StartupScriptBehavior: %T", src)
	}
	return nil
}

type NullStartupScriptBehavior struct {
	StartupScriptBehavior StartupScriptBehavior
	Valid                 bool // Valid is true if StartupScriptBehavior is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStartupScriptBehavior) Scan(value interface{}) error {
	if value == nil {
		ns.StartupScriptBehavior, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StartupScriptBehavior.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStartupScriptBehavior) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StartupScriptBehavior), nil
}

func (e StartupScriptBehavior) Valid() bool {
	switch e {
	case StartupScriptBehaviorBlocking,
		StartupScriptBehaviorNonBlocking:
		return true
	}
	return false
}

func AllStartupScriptBehaviorValues() []StartupScriptBehavior {
	return []StartupScriptBehavior{
		StartupScriptBehaviorBlocking,
		StartupScriptBehaviorNonBlocking,
	}
}

type UserStatus string

const (
	UserStatusActive    UserStatus = "active"
	UserStatusSuspended UserStatus = "suspended"
)

func (e *UserStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserStatus(s)
	case string:
		*e = UserStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UserStatus: %T", src)
	}
	return nil
}

type NullUserStatus struct {
	UserStatus UserStatus
	Valid      bool // Valid is true if UserStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UserStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserStatus), nil
}

func (e UserStatus) Valid() bool {
	switch e {
	case UserStatusActive,
		UserStatusSuspended:
		return true
	}
	return false
}

func AllUserStatusValues() []UserStatus {
	return []UserStatus{
		UserStatusActive,
		UserStatusSuspended,
	}
}

type WorkspaceAgentLifecycleState string

const (
	WorkspaceAgentLifecycleStateCreated         WorkspaceAgentLifecycleState = "created"
	WorkspaceAgentLifecycleStateStarting        WorkspaceAgentLifecycleState = "starting"
	WorkspaceAgentLifecycleStateStartTimeout    WorkspaceAgentLifecycleState = "start_timeout"
	WorkspaceAgentLifecycleStateStartError      WorkspaceAgentLifecycleState = "start_error"
	WorkspaceAgentLifecycleStateReady           WorkspaceAgentLifecycleState = "ready"
	WorkspaceAgentLifecycleStateShuttingDown    WorkspaceAgentLifecycleState = "shutting_down"
	WorkspaceAgentLifecycleStateShutdownTimeout WorkspaceAgentLifecycleState = "shutdown_timeout"
	WorkspaceAgentLifecycleStateShutdownError   WorkspaceAgentLifecycleState = "shutdown_error"
	WorkspaceAgentLifecycleStateOff             WorkspaceAgentLifecycleState = "off"
)

func (e *WorkspaceAgentLifecycleState) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkspaceAgentLifecycleState(s)
	case string:
		*e = WorkspaceAgentLifecycleState(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkspaceAgentLifecycleState: %T", src)
	}
	return nil
}

type NullWorkspaceAgentLifecycleState struct {
	WorkspaceAgentLifecycleState WorkspaceAgentLifecycleState
	Valid                        bool // Valid is true if WorkspaceAgentLifecycleState is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkspaceAgentLifecycleState) Scan(value interface{}) error {
	if value == nil {
		ns.WorkspaceAgentLifecycleState, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkspaceAgentLifecycleState.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkspaceAgentLifecycleState) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkspaceAgentLifecycleState), nil
}

func (e WorkspaceAgentLifecycleState) Valid() bool {
	switch e {
	case WorkspaceAgentLifecycleStateCreated,
		WorkspaceAgentLifecycleStateStarting,
		WorkspaceAgentLifecycleStateStartTimeout,
		WorkspaceAgentLifecycleStateStartError,
		WorkspaceAgentLifecycleStateReady,
		WorkspaceAgentLifecycleStateShuttingDown,
		WorkspaceAgentLifecycleStateShutdownTimeout,
		WorkspaceAgentLifecycleStateShutdownError,
		WorkspaceAgentLifecycleStateOff:
		return true
	}
	return false
}

func AllWorkspaceAgentLifecycleStateValues() []WorkspaceAgentLifecycleState {
	return []WorkspaceAgentLifecycleState{
		WorkspaceAgentLifecycleStateCreated,
		WorkspaceAgentLifecycleStateStarting,
		WorkspaceAgentLifecycleStateStartTimeout,
		WorkspaceAgentLifecycleStateStartError,
		WorkspaceAgentLifecycleStateReady,
		WorkspaceAgentLifecycleStateShuttingDown,
		WorkspaceAgentLifecycleStateShutdownTimeout,
		WorkspaceAgentLifecycleStateShutdownError,
		WorkspaceAgentLifecycleStateOff,
	}
}

type WorkspaceAgentSubsystem string

const (
	WorkspaceAgentSubsystemEnvbuilder WorkspaceAgentSubsystem = "envbuilder"
	WorkspaceAgentSubsystemEnvbox     WorkspaceAgentSubsystem = "envbox"
	WorkspaceAgentSubsystemNone       WorkspaceAgentSubsystem = "none"
)

func (e *WorkspaceAgentSubsystem) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkspaceAgentSubsystem(s)
	case string:
		*e = WorkspaceAgentSubsystem(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkspaceAgentSubsystem: %T", src)
	}
	return nil
}

type NullWorkspaceAgentSubsystem struct {
	WorkspaceAgentSubsystem WorkspaceAgentSubsystem
	Valid                   bool // Valid is true if WorkspaceAgentSubsystem is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkspaceAgentSubsystem) Scan(value interface{}) error {
	if value == nil {
		ns.WorkspaceAgentSubsystem, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkspaceAgentSubsystem.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkspaceAgentSubsystem) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkspaceAgentSubsystem), nil
}

func (e WorkspaceAgentSubsystem) Valid() bool {
	switch e {
	case WorkspaceAgentSubsystemEnvbuilder,
		WorkspaceAgentSubsystemEnvbox,
		WorkspaceAgentSubsystemNone:
		return true
	}
	return false
}

func AllWorkspaceAgentSubsystemValues() []WorkspaceAgentSubsystem {
	return []WorkspaceAgentSubsystem{
		WorkspaceAgentSubsystemEnvbuilder,
		WorkspaceAgentSubsystemEnvbox,
		WorkspaceAgentSubsystemNone,
	}
}

type WorkspaceAppHealth string

const (
	WorkspaceAppHealthDisabled     WorkspaceAppHealth = "disabled"
	WorkspaceAppHealthInitializing WorkspaceAppHealth = "initializing"
	WorkspaceAppHealthHealthy      WorkspaceAppHealth = "healthy"
	WorkspaceAppHealthUnhealthy    WorkspaceAppHealth = "unhealthy"
)

func (e *WorkspaceAppHealth) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkspaceAppHealth(s)
	case string:
		*e = WorkspaceAppHealth(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkspaceAppHealth: %T", src)
	}
	return nil
}

type NullWorkspaceAppHealth struct {
	WorkspaceAppHealth WorkspaceAppHealth
	Valid              bool // Valid is true if WorkspaceAppHealth is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkspaceAppHealth) Scan(value interface{}) error {
	if value == nil {
		ns.WorkspaceAppHealth, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkspaceAppHealth.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkspaceAppHealth) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkspaceAppHealth), nil
}

func (e WorkspaceAppHealth) Valid() bool {
	switch e {
	case WorkspaceAppHealthDisabled,
		WorkspaceAppHealthInitializing,
		WorkspaceAppHealthHealthy,
		WorkspaceAppHealthUnhealthy:
		return true
	}
	return false
}

func AllWorkspaceAppHealthValues() []WorkspaceAppHealth {
	return []WorkspaceAppHealth{
		WorkspaceAppHealthDisabled,
		WorkspaceAppHealthInitializing,
		WorkspaceAppHealthHealthy,
		WorkspaceAppHealthUnhealthy,
	}
}

type WorkspaceTransition string

const (
	WorkspaceTransitionStart  WorkspaceTransition = "start"
	WorkspaceTransitionStop   WorkspaceTransition = "stop"
	WorkspaceTransitionDelete WorkspaceTransition = "delete"
)

func (e *WorkspaceTransition) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WorkspaceTransition(s)
	case string:
		*e = WorkspaceTransition(s)
	default:
		return fmt.Errorf("unsupported scan type for WorkspaceTransition: %T", src)
	}
	return nil
}

type NullWorkspaceTransition struct {
	WorkspaceTransition WorkspaceTransition
	Valid               bool // Valid is true if WorkspaceTransition is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWorkspaceTransition) Scan(value interface{}) error {
	if value == nil {
		ns.WorkspaceTransition, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WorkspaceTransition.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWorkspaceTransition) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WorkspaceTransition), nil
}

func (e WorkspaceTransition) Valid() bool {
	switch e {
	case WorkspaceTransitionStart,
		WorkspaceTransitionStop,
		WorkspaceTransitionDelete:
		return true
	}
	return false
}

func AllWorkspaceTransitionValues() []WorkspaceTransition {
	return []WorkspaceTransition{
		WorkspaceTransitionStart,
		WorkspaceTransitionStop,
		WorkspaceTransitionDelete,
	}
}

type APIKey struct {
	ID string `db:"id" json:"id"`
	// hashed_secret contains a SHA256 hash of the key secret. This is considered a secret and MUST NOT be returned from the API as it is used for API key encryption in app proxying code.
	HashedSecret    []byte      `db:"hashed_secret" json:"hashed_secret"`
	UserID          uuid.UUID   `db:"user_id" json:"user_id"`
	LastUsed        time.Time   `db:"last_used" json:"last_used"`
	ExpiresAt       time.Time   `db:"expires_at" json:"expires_at"`
	CreatedAt       time.Time   `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time   `db:"updated_at" json:"updated_at"`
	LoginType       LoginType   `db:"login_type" json:"login_type"`
	LifetimeSeconds int64       `db:"lifetime_seconds" json:"lifetime_seconds"`
	IPAddress       pqtype.Inet `db:"ip_address" json:"ip_address"`
	Scope           APIKeyScope `db:"scope" json:"scope"`
	TokenName       string      `db:"token_name" json:"token_name"`
}

type AuditLog struct {
	ID               uuid.UUID       `db:"id" json:"id"`
	Time             time.Time       `db:"time" json:"time"`
	UserID           uuid.UUID       `db:"user_id" json:"user_id"`
	OrganizationID   uuid.UUID       `db:"organization_id" json:"organization_id"`
	Ip               pqtype.Inet     `db:"ip" json:"ip"`
	UserAgent        sql.NullString  `db:"user_agent" json:"user_agent"`
	ResourceType     ResourceType    `db:"resource_type" json:"resource_type"`
	ResourceID       uuid.UUID       `db:"resource_id" json:"resource_id"`
	ResourceTarget   string          `db:"resource_target" json:"resource_target"`
	Action           AuditAction     `db:"action" json:"action"`
	Diff             json.RawMessage `db:"diff" json:"diff"`
	StatusCode       int32           `db:"status_code" json:"status_code"`
	AdditionalFields json.RawMessage `db:"additional_fields" json:"additional_fields"`
	RequestID        uuid.UUID       `db:"request_id" json:"request_id"`
	ResourceIcon     string          `db:"resource_icon" json:"resource_icon"`
}

type File struct {
	Hash      string    `db:"hash" json:"hash"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	CreatedBy uuid.UUID `db:"created_by" json:"created_by"`
	Mimetype  string    `db:"mimetype" json:"mimetype"`
	Data      []byte    `db:"data" json:"data"`
	ID        uuid.UUID `db:"id" json:"id"`
}

type GitAuthLink struct {
	ProviderID        string    `db:"provider_id" json:"provider_id"`
	UserID            uuid.UUID `db:"user_id" json:"user_id"`
	CreatedAt         time.Time `db:"created_at" json:"created_at"`
	UpdatedAt         time.Time `db:"updated_at" json:"updated_at"`
	OAuthAccessToken  string    `db:"oauth_access_token" json:"oauth_access_token"`
	OAuthRefreshToken string    `db:"oauth_refresh_token" json:"oauth_refresh_token"`
	OAuthExpiry       time.Time `db:"oauth_expiry" json:"oauth_expiry"`
}

type GitSSHKey struct {
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	CreatedAt  time.Time `db:"created_at" json:"created_at"`
	UpdatedAt  time.Time `db:"updated_at" json:"updated_at"`
	PrivateKey string    `db:"private_key" json:"private_key"`
	PublicKey  string    `db:"public_key" json:"public_key"`
}

type Group struct {
	ID             uuid.UUID `db:"id" json:"id"`
	Name           string    `db:"name" json:"name"`
	OrganizationID uuid.UUID `db:"organization_id" json:"organization_id"`
	AvatarURL      string    `db:"avatar_url" json:"avatar_url"`
	QuotaAllowance int32     `db:"quota_allowance" json:"quota_allowance"`
}

type GroupMember struct {
	UserID  uuid.UUID `db:"user_id" json:"user_id"`
	GroupID uuid.UUID `db:"group_id" json:"group_id"`
}

type License struct {
	ID         int32     `db:"id" json:"id"`
	UploadedAt time.Time `db:"uploaded_at" json:"uploaded_at"`
	JWT        string    `db:"jwt" json:"jwt"`
	// exp tracks the claim of the same name in the JWT, and we include it here so that we can easily query for licenses that have not yet expired.
	Exp  time.Time `db:"exp" json:"exp"`
	UUID uuid.UUID `db:"uuid" json:"uuid"`
}

type Organization struct {
	ID          uuid.UUID `db:"id" json:"id"`
	Name        string    `db:"name" json:"name"`
	Description string    `db:"description" json:"description"`
	CreatedAt   time.Time `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time `db:"updated_at" json:"updated_at"`
}

type OrganizationMember struct {
	UserID         uuid.UUID `db:"user_id" json:"user_id"`
	OrganizationID uuid.UUID `db:"organization_id" json:"organization_id"`
	CreatedAt      time.Time `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time `db:"updated_at" json:"updated_at"`
	Roles          []string  `db:"roles" json:"roles"`
}

type ParameterSchema struct {
	ID                       uuid.UUID                  `db:"id" json:"id"`
	CreatedAt                time.Time                  `db:"created_at" json:"created_at"`
	JobID                    uuid.UUID                  `db:"job_id" json:"job_id"`
	Name                     string                     `db:"name" json:"name"`
	Description              string                     `db:"description" json:"description"`
	DefaultSourceScheme      ParameterSourceScheme      `db:"default_source_scheme" json:"default_source_scheme"`
	DefaultSourceValue       string                     `db:"default_source_value" json:"default_source_value"`
	AllowOverrideSource      bool                       `db:"allow_override_source" json:"allow_override_source"`
	DefaultDestinationScheme ParameterDestinationScheme `db:"default_destination_scheme" json:"default_destination_scheme"`
	AllowOverrideDestination bool                       `db:"allow_override_destination" json:"allow_override_destination"`
	DefaultRefresh           string                     `db:"default_refresh" json:"default_refresh"`
	RedisplayValue           bool                       `db:"redisplay_value" json:"redisplay_value"`
	ValidationError          string                     `db:"validation_error" json:"validation_error"`
	ValidationCondition      string                     `db:"validation_condition" json:"validation_condition"`
	ValidationTypeSystem     ParameterTypeSystem        `db:"validation_type_system" json:"validation_type_system"`
	ValidationValueType      string                     `db:"validation_value_type" json:"validation_value_type"`
	Index                    int32                      `db:"index" json:"index"`
}

type ParameterValue struct {
	ID                uuid.UUID                  `db:"id" json:"id"`
	CreatedAt         time.Time                  `db:"created_at" json:"created_at"`
	UpdatedAt         time.Time                  `db:"updated_at" json:"updated_at"`
	Scope             ParameterScope             `db:"scope" json:"scope"`
	ScopeID           uuid.UUID                  `db:"scope_id" json:"scope_id"`
	Name              string                     `db:"name" json:"name"`
	SourceScheme      ParameterSourceScheme      `db:"source_scheme" json:"source_scheme"`
	SourceValue       string                     `db:"source_value" json:"source_value"`
	DestinationScheme ParameterDestinationScheme `db:"destination_scheme" json:"destination_scheme"`
}

type ProvisionerDaemon struct {
	ID           uuid.UUID         `db:"id" json:"id"`
	CreatedAt    time.Time         `db:"created_at" json:"created_at"`
	UpdatedAt    sql.NullTime      `db:"updated_at" json:"updated_at"`
	Name         string            `db:"name" json:"name"`
	Provisioners []ProvisionerType `db:"provisioners" json:"provisioners"`
	ReplicaID    uuid.NullUUID     `db:"replica_id" json:"replica_id"`
	Tags         StringMap         `db:"tags" json:"tags"`
}

type ProvisionerJob struct {
	ID             uuid.UUID                `db:"id" json:"id"`
	CreatedAt      time.Time                `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time                `db:"updated_at" json:"updated_at"`
	StartedAt      sql.NullTime             `db:"started_at" json:"started_at"`
	CanceledAt     sql.NullTime             `db:"canceled_at" json:"canceled_at"`
	CompletedAt    sql.NullTime             `db:"completed_at" json:"completed_at"`
	Error          sql.NullString           `db:"error" json:"error"`
	OrganizationID uuid.UUID                `db:"organization_id" json:"organization_id"`
	InitiatorID    uuid.UUID                `db:"initiator_id" json:"initiator_id"`
	Provisioner    ProvisionerType          `db:"provisioner" json:"provisioner"`
	StorageMethod  ProvisionerStorageMethod `db:"storage_method" json:"storage_method"`
	Type           ProvisionerJobType       `db:"type" json:"type"`
	Input          json.RawMessage          `db:"input" json:"input"`
	WorkerID       uuid.NullUUID            `db:"worker_id" json:"worker_id"`
	FileID         uuid.UUID                `db:"file_id" json:"file_id"`
	Tags           StringMap                `db:"tags" json:"tags"`
	ErrorCode      sql.NullString           `db:"error_code" json:"error_code"`
	TraceMetadata  pqtype.NullRawMessage    `db:"trace_metadata" json:"trace_metadata"`
}

type ProvisionerJobLog struct {
	JobID     uuid.UUID `db:"job_id" json:"job_id"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	Source    LogSource `db:"source" json:"source"`
	Level     LogLevel  `db:"level" json:"level"`
	Stage     string    `db:"stage" json:"stage"`
	Output    string    `db:"output" json:"output"`
	ID        int64     `db:"id" json:"id"`
}

type Replica struct {
	ID              uuid.UUID    `db:"id" json:"id"`
	CreatedAt       time.Time    `db:"created_at" json:"created_at"`
	StartedAt       time.Time    `db:"started_at" json:"started_at"`
	StoppedAt       sql.NullTime `db:"stopped_at" json:"stopped_at"`
	UpdatedAt       time.Time    `db:"updated_at" json:"updated_at"`
	Hostname        string       `db:"hostname" json:"hostname"`
	RegionID        int32        `db:"region_id" json:"region_id"`
	RelayAddress    string       `db:"relay_address" json:"relay_address"`
	DatabaseLatency int32        `db:"database_latency" json:"database_latency"`
	Version         string       `db:"version" json:"version"`
	Error           string       `db:"error" json:"error"`
}

type SiteConfig struct {
	Key   string `db:"key" json:"key"`
	Value string `db:"value" json:"value"`
}

type TailnetAgent struct {
	ID            uuid.UUID       `db:"id" json:"id"`
	CoordinatorID uuid.UUID       `db:"coordinator_id" json:"coordinator_id"`
	UpdatedAt     time.Time       `db:"updated_at" json:"updated_at"`
	Node          json.RawMessage `db:"node" json:"node"`
}

type TailnetClient struct {
	ID            uuid.UUID       `db:"id" json:"id"`
	CoordinatorID uuid.UUID       `db:"coordinator_id" json:"coordinator_id"`
	AgentID       uuid.UUID       `db:"agent_id" json:"agent_id"`
	UpdatedAt     time.Time       `db:"updated_at" json:"updated_at"`
	Node          json.RawMessage `db:"node" json:"node"`
}

// We keep this separate from replicas in case we need to break the coordinator out into its own service
type TailnetCoordinator struct {
	ID          uuid.UUID `db:"id" json:"id"`
	HeartbeatAt time.Time `db:"heartbeat_at" json:"heartbeat_at"`
}

type Template struct {
	ID              uuid.UUID       `db:"id" json:"id"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	OrganizationID  uuid.UUID       `db:"organization_id" json:"organization_id"`
	Deleted         bool            `db:"deleted" json:"deleted"`
	Name            string          `db:"name" json:"name"`
	Provisioner     ProvisionerType `db:"provisioner" json:"provisioner"`
	ActiveVersionID uuid.UUID       `db:"active_version_id" json:"active_version_id"`
	Description     string          `db:"description" json:"description"`
	// The default duration for autostop for workspaces created from this template.
	DefaultTTL int64       `db:"default_ttl" json:"default_ttl"`
	CreatedBy  uuid.UUID   `db:"created_by" json:"created_by"`
	Icon       string      `db:"icon" json:"icon"`
	UserACL    TemplateACL `db:"user_acl" json:"user_acl"`
	GroupACL   TemplateACL `db:"group_acl" json:"group_acl"`
	// Display name is a custom, human-friendly template name that user can set.
	DisplayName string `db:"display_name" json:"display_name"`
	// Allow users to cancel in-progress workspace jobs.
	AllowUserCancelWorkspaceJobs bool  `db:"allow_user_cancel_workspace_jobs" json:"allow_user_cancel_workspace_jobs"`
	MaxTTL                       int64 `db:"max_ttl" json:"max_ttl"`
	// Allow users to specify an autostart schedule for workspaces (enterprise).
	AllowUserAutostart bool `db:"allow_user_autostart" json:"allow_user_autostart"`
	// Allow users to specify custom autostop values for workspaces (enterprise).
	AllowUserAutostop bool  `db:"allow_user_autostop" json:"allow_user_autostop"`
	FailureTTL        int64 `db:"failure_ttl" json:"failure_ttl"`
	InactivityTTL     int64 `db:"inactivity_ttl" json:"inactivity_ttl"`
	LockedTTL         int64 `db:"locked_ttl" json:"locked_ttl"`
}

type TemplateVersion struct {
	ID             uuid.UUID     `db:"id" json:"id"`
	TemplateID     uuid.NullUUID `db:"template_id" json:"template_id"`
	OrganizationID uuid.UUID     `db:"organization_id" json:"organization_id"`
	CreatedAt      time.Time     `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time     `db:"updated_at" json:"updated_at"`
	Name           string        `db:"name" json:"name"`
	Readme         string        `db:"readme" json:"readme"`
	JobID          uuid.UUID     `db:"job_id" json:"job_id"`
	CreatedBy      uuid.UUID     `db:"created_by" json:"created_by"`
	// IDs of Git auth providers for a specific template version
	GitAuthProviders []string `db:"git_auth_providers" json:"git_auth_providers"`
}

type TemplateVersionParameter struct {
	TemplateVersionID uuid.UUID `db:"template_version_id" json:"template_version_id"`
	// Parameter name
	Name string `db:"name" json:"name"`
	// Parameter description
	Description string `db:"description" json:"description"`
	// Parameter type
	Type string `db:"type" json:"type"`
	// Is parameter mutable?
	Mutable bool `db:"mutable" json:"mutable"`
	// Default value
	DefaultValue string `db:"default_value" json:"default_value"`
	// Icon
	Icon string `db:"icon" json:"icon"`
	// Additional options
	Options json.RawMessage `db:"options" json:"options"`
	// Validation: regex pattern
	ValidationRegex string `db:"validation_regex" json:"validation_regex"`
	// Validation: minimum length of value
	ValidationMin sql.NullInt32 `db:"validation_min" json:"validation_min"`
	// Validation: maximum length of value
	ValidationMax sql.NullInt32 `db:"validation_max" json:"validation_max"`
	// Validation: error displayed when the regex does not match.
	ValidationError string `db:"validation_error" json:"validation_error"`
	// Validation: consecutive values preserve the monotonic order
	ValidationMonotonic string `db:"validation_monotonic" json:"validation_monotonic"`
	// Is parameter required?
	Required bool `db:"required" json:"required"`
	// Display name of the rich parameter
	DisplayName string `db:"display_name" json:"display_name"`
	// Specifies the order in which to display parameters in user interfaces.
	DisplayOrder int32 `db:"display_order" json:"display_order"`
}

type TemplateVersionVariable struct {
	TemplateVersionID uuid.UUID `db:"template_version_id" json:"template_version_id"`
	// Variable name
	Name string `db:"name" json:"name"`
	// Variable description
	Description string `db:"description" json:"description"`
	// Variable type
	Type string `db:"type" json:"type"`
	// Variable value
	Value string `db:"value" json:"value"`
	// Variable default value
	DefaultValue string `db:"default_value" json:"default_value"`
	// Required variables needs a default value or a value provided by template admin
	Required bool `db:"required" json:"required"`
	// Sensitive variables have their values redacted in logs or site UI
	Sensitive bool `db:"sensitive" json:"sensitive"`
}

type User struct {
	ID             uuid.UUID      `db:"id" json:"id"`
	Email          string         `db:"email" json:"email"`
	Username       string         `db:"username" json:"username"`
	HashedPassword []byte         `db:"hashed_password" json:"hashed_password"`
	CreatedAt      time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time      `db:"updated_at" json:"updated_at"`
	Status         UserStatus     `db:"status" json:"status"`
	RBACRoles      pq.StringArray `db:"rbac_roles" json:"rbac_roles"`
	LoginType      LoginType      `db:"login_type" json:"login_type"`
	AvatarURL      sql.NullString `db:"avatar_url" json:"avatar_url"`
	Deleted        bool           `db:"deleted" json:"deleted"`
	LastSeenAt     time.Time      `db:"last_seen_at" json:"last_seen_at"`
}

type UserLink struct {
	UserID            uuid.UUID `db:"user_id" json:"user_id"`
	LoginType         LoginType `db:"login_type" json:"login_type"`
	LinkedID          string    `db:"linked_id" json:"linked_id"`
	OAuthAccessToken  string    `db:"oauth_access_token" json:"oauth_access_token"`
	OAuthRefreshToken string    `db:"oauth_refresh_token" json:"oauth_refresh_token"`
	OAuthExpiry       time.Time `db:"oauth_expiry" json:"oauth_expiry"`
}

type Workspace struct {
	ID                uuid.UUID      `db:"id" json:"id"`
	CreatedAt         time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt         time.Time      `db:"updated_at" json:"updated_at"`
	OwnerID           uuid.UUID      `db:"owner_id" json:"owner_id"`
	OrganizationID    uuid.UUID      `db:"organization_id" json:"organization_id"`
	TemplateID        uuid.UUID      `db:"template_id" json:"template_id"`
	Deleted           bool           `db:"deleted" json:"deleted"`
	Name              string         `db:"name" json:"name"`
	AutostartSchedule sql.NullString `db:"autostart_schedule" json:"autostart_schedule"`
	Ttl               sql.NullInt64  `db:"ttl" json:"ttl"`
	LastUsedAt        time.Time      `db:"last_used_at" json:"last_used_at"`
	LockedAt          sql.NullTime   `db:"locked_at" json:"locked_at"`
}

type WorkspaceAgent struct {
	ID                   uuid.UUID             `db:"id" json:"id"`
	CreatedAt            time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt            time.Time             `db:"updated_at" json:"updated_at"`
	Name                 string                `db:"name" json:"name"`
	FirstConnectedAt     sql.NullTime          `db:"first_connected_at" json:"first_connected_at"`
	LastConnectedAt      sql.NullTime          `db:"last_connected_at" json:"last_connected_at"`
	DisconnectedAt       sql.NullTime          `db:"disconnected_at" json:"disconnected_at"`
	ResourceID           uuid.UUID             `db:"resource_id" json:"resource_id"`
	AuthToken            uuid.UUID             `db:"auth_token" json:"auth_token"`
	AuthInstanceID       sql.NullString        `db:"auth_instance_id" json:"auth_instance_id"`
	Architecture         string                `db:"architecture" json:"architecture"`
	EnvironmentVariables pqtype.NullRawMessage `db:"environment_variables" json:"environment_variables"`
	OperatingSystem      string                `db:"operating_system" json:"operating_system"`
	StartupScript        sql.NullString        `db:"startup_script" json:"startup_script"`
	InstanceMetadata     pqtype.NullRawMessage `db:"instance_metadata" json:"instance_metadata"`
	ResourceMetadata     pqtype.NullRawMessage `db:"resource_metadata" json:"resource_metadata"`
	Directory            string                `db:"directory" json:"directory"`
	// Version tracks the version of the currently running workspace agent. Workspace agents register their version upon start.
	Version                string        `db:"version" json:"version"`
	LastConnectedReplicaID uuid.NullUUID `db:"last_connected_replica_id" json:"last_connected_replica_id"`
	// Connection timeout in seconds, 0 means disabled.
	ConnectionTimeoutSeconds int32 `db:"connection_timeout_seconds" json:"connection_timeout_seconds"`
	// URL for troubleshooting the agent.
	TroubleshootingURL string `db:"troubleshooting_url" json:"troubleshooting_url"`
	// Path to file inside workspace containing the message of the day (MOTD) to show to the user when logging in via SSH.
	MOTDFile string `db:"motd_file" json:"motd_file"`
	// The current lifecycle state reported by the workspace agent.
	LifecycleState WorkspaceAgentLifecycleState `db:"lifecycle_state" json:"lifecycle_state"`
	// The number of seconds to wait for the startup script to complete. If the script does not complete within this time, the agent lifecycle will be marked as start_timeout.
	StartupScriptTimeoutSeconds int32 `db:"startup_script_timeout_seconds" json:"startup_script_timeout_seconds"`
	// The resolved path of a user-specified directory. e.g. ~/coder -> /home/coder/coder
	ExpandedDirectory string `db:"expanded_directory" json:"expanded_directory"`
	// Script that is executed before the agent is stopped.
	ShutdownScript sql.NullString `db:"shutdown_script" json:"shutdown_script"`
	// The number of seconds to wait for the shutdown script to complete. If the script does not complete within this time, the agent lifecycle will be marked as shutdown_timeout.
	ShutdownScriptTimeoutSeconds int32 `db:"shutdown_script_timeout_seconds" json:"shutdown_script_timeout_seconds"`
	// Total length of startup logs
	StartupLogsLength int32 `db:"startup_logs_length" json:"startup_logs_length"`
	// Whether the startup logs overflowed in length
	StartupLogsOverflowed bool                    `db:"startup_logs_overflowed" json:"startup_logs_overflowed"`
	Subsystem             WorkspaceAgentSubsystem `db:"subsystem" json:"subsystem"`
	// When startup script behavior is non-blocking, the workspace will be ready and accessible upon agent connection, when it is blocking, workspace will wait for the startup script to complete before becoming ready and accessible.
	StartupScriptBehavior StartupScriptBehavior `db:"startup_script_behavior" json:"startup_script_behavior"`
	// The time the agent entered the starting lifecycle state
	StartedAt sql.NullTime `db:"started_at" json:"started_at"`
	// The time the agent entered the ready or start_error lifecycle state
	ReadyAt sql.NullTime `db:"ready_at" json:"ready_at"`
}

type WorkspaceAgentMetadatum struct {
	WorkspaceAgentID uuid.UUID `db:"workspace_agent_id" json:"workspace_agent_id"`
	DisplayName      string    `db:"display_name" json:"display_name"`
	Key              string    `db:"key" json:"key"`
	Script           string    `db:"script" json:"script"`
	Value            string    `db:"value" json:"value"`
	Error            string    `db:"error" json:"error"`
	Timeout          int64     `db:"timeout" json:"timeout"`
	Interval         int64     `db:"interval" json:"interval"`
	CollectedAt      time.Time `db:"collected_at" json:"collected_at"`
}

type WorkspaceAgentStartupLog struct {
	AgentID   uuid.UUID `db:"agent_id" json:"agent_id"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	Output    string    `db:"output" json:"output"`
	ID        int64     `db:"id" json:"id"`
	Level     LogLevel  `db:"level" json:"level"`
}

type WorkspaceAgentStat struct {
	ID                          uuid.UUID       `db:"id" json:"id"`
	CreatedAt                   time.Time       `db:"created_at" json:"created_at"`
	UserID                      uuid.UUID       `db:"user_id" json:"user_id"`
	AgentID                     uuid.UUID       `db:"agent_id" json:"agent_id"`
	WorkspaceID                 uuid.UUID       `db:"workspace_id" json:"workspace_id"`
	TemplateID                  uuid.UUID       `db:"template_id" json:"template_id"`
	ConnectionsByProto          json.RawMessage `db:"connections_by_proto" json:"connections_by_proto"`
	ConnectionCount             int64           `db:"connection_count" json:"connection_count"`
	RxPackets                   int64           `db:"rx_packets" json:"rx_packets"`
	RxBytes                     int64           `db:"rx_bytes" json:"rx_bytes"`
	TxPackets                   int64           `db:"tx_packets" json:"tx_packets"`
	TxBytes                     int64           `db:"tx_bytes" json:"tx_bytes"`
	ConnectionMedianLatencyMS   float64         `db:"connection_median_latency_ms" json:"connection_median_latency_ms"`
	SessionCountVSCode          int64           `db:"session_count_vscode" json:"session_count_vscode"`
	SessionCountJetBrains       int64           `db:"session_count_jetbrains" json:"session_count_jetbrains"`
	SessionCountReconnectingPTY int64           `db:"session_count_reconnecting_pty" json:"session_count_reconnecting_pty"`
	SessionCountSSH             int64           `db:"session_count_ssh" json:"session_count_ssh"`
}

type WorkspaceApp struct {
	ID                   uuid.UUID          `db:"id" json:"id"`
	CreatedAt            time.Time          `db:"created_at" json:"created_at"`
	AgentID              uuid.UUID          `db:"agent_id" json:"agent_id"`
	DisplayName          string             `db:"display_name" json:"display_name"`
	Icon                 string             `db:"icon" json:"icon"`
	Command              sql.NullString     `db:"command" json:"command"`
	Url                  sql.NullString     `db:"url" json:"url"`
	HealthcheckUrl       string             `db:"healthcheck_url" json:"healthcheck_url"`
	HealthcheckInterval  int32              `db:"healthcheck_interval" json:"healthcheck_interval"`
	HealthcheckThreshold int32              `db:"healthcheck_threshold" json:"healthcheck_threshold"`
	Health               WorkspaceAppHealth `db:"health" json:"health"`
	Subdomain            bool               `db:"subdomain" json:"subdomain"`
	SharingLevel         AppSharingLevel    `db:"sharing_level" json:"sharing_level"`
	Slug                 string             `db:"slug" json:"slug"`
	External             bool               `db:"external" json:"external"`
}

type WorkspaceBuild struct {
	ID                uuid.UUID           `db:"id" json:"id"`
	CreatedAt         time.Time           `db:"created_at" json:"created_at"`
	UpdatedAt         time.Time           `db:"updated_at" json:"updated_at"`
	WorkspaceID       uuid.UUID           `db:"workspace_id" json:"workspace_id"`
	TemplateVersionID uuid.UUID           `db:"template_version_id" json:"template_version_id"`
	BuildNumber       int32               `db:"build_number" json:"build_number"`
	Transition        WorkspaceTransition `db:"transition" json:"transition"`
	InitiatorID       uuid.UUID           `db:"initiator_id" json:"initiator_id"`
	ProvisionerState  []byte              `db:"provisioner_state" json:"provisioner_state"`
	JobID             uuid.UUID           `db:"job_id" json:"job_id"`
	Deadline          time.Time           `db:"deadline" json:"deadline"`
	Reason            BuildReason         `db:"reason" json:"reason"`
	DailyCost         int32               `db:"daily_cost" json:"daily_cost"`
	MaxDeadline       time.Time           `db:"max_deadline" json:"max_deadline"`
}

type WorkspaceBuildParameter struct {
	WorkspaceBuildID uuid.UUID `db:"workspace_build_id" json:"workspace_build_id"`
	// Parameter name
	Name string `db:"name" json:"name"`
	// Parameter value
	Value string `db:"value" json:"value"`
}

type WorkspaceProxy struct {
	ID          uuid.UUID `db:"id" json:"id"`
	Name        string    `db:"name" json:"name"`
	DisplayName string    `db:"display_name" json:"display_name"`
	// Expects an emoji character. (/emojis/1f1fa-1f1f8.png)
	Icon string `db:"icon" json:"icon"`
	// Full url including scheme of the proxy api url: https://us.example.com
	Url string `db:"url" json:"url"`
	// Hostname with the wildcard for subdomain based app hosting: *.us.example.com
	WildcardHostname string    `db:"wildcard_hostname" json:"wildcard_hostname"`
	CreatedAt        time.Time `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time `db:"updated_at" json:"updated_at"`
	// Boolean indicator of a deleted workspace proxy. Proxies are soft-deleted.
	Deleted bool `db:"deleted" json:"deleted"`
	// Hashed secret is used to authenticate the workspace proxy using a session token.
	TokenHashedSecret []byte `db:"token_hashed_secret" json:"token_hashed_secret"`
}

type WorkspaceResource struct {
	ID           uuid.UUID           `db:"id" json:"id"`
	CreatedAt    time.Time           `db:"created_at" json:"created_at"`
	JobID        uuid.UUID           `db:"job_id" json:"job_id"`
	Transition   WorkspaceTransition `db:"transition" json:"transition"`
	Type         string              `db:"type" json:"type"`
	Name         string              `db:"name" json:"name"`
	Hide         bool                `db:"hide" json:"hide"`
	Icon         string              `db:"icon" json:"icon"`
	InstanceType sql.NullString      `db:"instance_type" json:"instance_type"`
	DailyCost    int32               `db:"daily_cost" json:"daily_cost"`
}

type WorkspaceResourceMetadatum struct {
	WorkspaceResourceID uuid.UUID      `db:"workspace_resource_id" json:"workspace_resource_id"`
	Key                 string         `db:"key" json:"key"`
	Value               sql.NullString `db:"value" json:"value"`
	Sensitive           bool           `db:"sensitive" json:"sensitive"`
	ID                  int64          `db:"id" json:"id"`
}
