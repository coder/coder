// Package aiagentsdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package aiagentsdk

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// Defines values for AgentStatus.
const (
	Running AgentStatus = "running"
	Stable  AgentStatus = "stable"
)

// Defines values for ConversationRole.
const (
	ConversationRoleAgent ConversationRole = "agent"
	ConversationRoleUser  ConversationRole = "user"
)

// Defines values for MessageType.
const (
	MessageTypeRaw  MessageType = "raw"
	MessageTypeUser MessageType = "user"
)

// AgentStatus defines model for AgentStatus.
type AgentStatus string

// ConversationRole defines model for ConversationRole.
type ConversationRole string

// ErrorDetail defines model for ErrorDetail.
type ErrorDetail struct {
	// Location Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'
	Location *string `json:"location,omitempty"`

	// Message Error message text
	Message *string `json:"message,omitempty"`

	// Value The value at the given location
	Value *interface{} `json:"value,omitempty"`
}

// ErrorModel defines model for ErrorModel.
type ErrorModel struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// Errors Optional list of individual error details
	Errors *[]ErrorDetail `json:"errors"`

	// Instance A URI reference that identifies the specific occurrence of the problem.
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code
	Status *int64 `json:"status,omitempty"`

	// Title A short, human-readable summary of the problem type. This value should not change between occurrences of the error.
	Title *string `json:"title,omitempty"`

	// Type A URI reference to human-readable documentation for the error.
	Type *string `json:"type,omitempty"`
}

// Message defines model for Message.
type Message struct {
	// Content Message content. The message is formatted as it appears in the agent's terminal session, meaning it consists of lines of text with 80 characters per line.
	Content string `json:"content"`

	// Id Unique identifier for the message. This identifier also represents the order of the message in the conversation history.
	Id   int64            `json:"id"`
	Role ConversationRole `json:"role"`

	// Time Timestamp of the message
	Time time.Time `json:"time"`
}

// MessageRequestBody defines model for MessageRequestBody.
type MessageRequestBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// Content Message content
	Content string      `json:"content"`
	Type    MessageType `json:"type"`
}

// MessageResponseBody defines model for MessageResponseBody.
type MessageResponseBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// Ok Indicates whether the message was sent successfully. For messages of type 'user', success means detecting that the agent began executing the task described. For messages of type 'raw', success means the keystrokes were sent to the terminal.
	Ok bool `json:"ok"`
}

// MessageType defines model for MessageType.
type MessageType string

// MessageUpdateBody defines model for MessageUpdateBody.
type MessageUpdateBody struct {
	// Id Unique identifier for the message. This identifier also represents the order of the message in the conversation history.
	Id int64 `json:"id"`

	// Message Message content. The message is formatted as it appears in the agent's terminal session, meaning it consists of lines of text with 80 characters per line.
	Message string           `json:"message"`
	Role    ConversationRole `json:"role"`

	// Time Timestamp of the message
	Time time.Time `json:"time"`
}

// MessagesResponseBody defines model for MessagesResponseBody.
type MessagesResponseBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string `json:"$schema,omitempty"`

	// Messages List of messages
	Messages []Message `json:"messages"`
}

// StatusChangeBody defines model for StatusChangeBody.
type StatusChangeBody struct {
	Status AgentStatus `json:"status"`
}

// StatusResponseBody defines model for StatusResponseBody.
type StatusResponseBody struct {
	// Schema A URL to the JSON Schema for this object.
	Schema *string     `json:"$schema,omitempty"`
	Status AgentStatus `json:"status"`
}

// PostMessageJSONRequestBody defines body for PostMessage for application/json ContentType.
type PostMessageJSONRequestBody = MessageRequestBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SubscribeEvents request
	SubscribeEvents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMessageWithBody request with any body
	PostMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMessage(ctx context.Context, body PostMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMessages request
	GetMessages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SubscribeEvents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscribeEventsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMessage(ctx context.Context, body PostMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMessages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMessagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSubscribeEventsRequest generates requests for SubscribeEvents
func NewSubscribeEventsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMessageRequest calls the generic PostMessage builder with application/json body
func NewPostMessageRequest(server string, body PostMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewPostMessageRequestWithBody generates requests for PostMessage with any type of body
func NewPostMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/message")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMessagesRequest generates requests for GetMessages
func NewGetMessagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SubscribeEventsWithResponse request
	SubscribeEventsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SubscribeEventsResponse, error)

	// PostMessageWithBodyWithResponse request with any body
	PostMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMessageResponse, error)

	PostMessageWithResponse(ctx context.Context, body PostMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMessageResponse, error)

	// GetMessagesWithResponse request
	GetMessagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMessagesResponse, error)

	// GetStatusWithResponse request
	GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error)
}

type SubscribeEventsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r SubscribeEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscribeEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMessageResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *MessageResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r PostMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMessagesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *MessagesResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	JSON200                       *StatusResponseBody
	ApplicationproblemJSONDefault *ErrorModel
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SubscribeEventsWithResponse request returning *SubscribeEventsResponse
func (c *ClientWithResponses) SubscribeEventsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SubscribeEventsResponse, error) {
	rsp, err := c.SubscribeEvents(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscribeEventsResponse(rsp)
}

// PostMessageWithBodyWithResponse request with arbitrary body returning *PostMessageResponse
func (c *ClientWithResponses) PostMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMessageResponse, error) {
	rsp, err := c.PostMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMessageResponse(rsp)
}

func (c *ClientWithResponses) PostMessageWithResponse(ctx context.Context, body PostMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMessageResponse, error) {
	rsp, err := c.PostMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMessageResponse(rsp)
}

// GetMessagesWithResponse request returning *GetMessagesResponse
func (c *ClientWithResponses) GetMessagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMessagesResponse, error) {
	rsp, err := c.GetMessages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMessagesResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error) {
	rsp, err := c.GetStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// ParseSubscribeEventsResponse parses an HTTP response from a SubscribeEventsWithResponse call
func ParseSubscribeEventsResponse(rsp *http.Response) (*SubscribeEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscribeEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePostMessageResponse parses an HTTP response from a PostMessageWithResponse call
func ParsePostMessageResponse(rsp *http.Response) (*PostMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetMessagesResponse parses an HTTP response from a GetMessagesWithResponse call
func ParseGetMessagesResponse(rsp *http.Response) (*GetMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagesResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}
