package tests

// This file contains utility functions for testing the Helm chart.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/jinzhu/copier"
	"golang.org/x/xerrors"
	"helm.sh/helm/v3/pkg/chart"
	"helm.sh/helm/v3/pkg/chartutil"
	"helm.sh/helm/v3/pkg/engine"
)

// renderManifests renders the chart with the given values and returns a map of
// rendered files and their contents.
func renderManifests(
	c *chart.Chart,
	orig *Values,
	mut func(*Values),
	options *chartutil.ReleaseOptions,
	capabilities *chartutil.Capabilities,
) (map[string]string, error) {
	var opts chartutil.ReleaseOptions
	if options == nil {
		opts = chartutil.ReleaseOptions{
			Name:      "coder",
			Namespace: "coder",
			Revision:  1,
			IsInstall: true,
			IsUpgrade: false,
		}
	} else {
		opts = *options
	}

	if capabilities == nil {
		capabilities = chartutil.DefaultCapabilities.Copy()
	}

	values := orig
	if mut != nil {
		values = &Values{}
		err := copier.CopyWithOption(values, orig, copier.Option{
			DeepCopy: true,
		})
		if err != nil {
			return nil, xerrors.Errorf("failed to deep copy values: %w", err)
		}

		mut(values)
	}

	valsMap, err := valuesToMap(values)
	if err != nil {
		return nil, xerrors.Errorf("failed to convert values to map: %w", err)
	}

	renderVals, err := chartutil.ToRenderValues(c, valsMap, opts, capabilities)
	if err != nil {
		return nil, xerrors.Errorf("failed to create render values: %w", err)
	}
	manifests, err := engine.Render(c, renderVals)
	if err != nil {
		return nil, xerrors.Errorf("failed to render chart: %w", err)
	}
	return manifests, nil
}

// dumpManifests dumps the given manifests to a string.
func dumpManifests(manifests map[string]string) string {
	var sb strings.Builder
	_, _ = fmt.Fprintf(&sb, "# This file is generated by TestUpdateGoldenFiles. DO NOT EDIT.\n")
	var keys []string
	for k := range manifests {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		val := manifests[k]
		_, _ = fmt.Fprintf(&sb, "--- # Source: %s\n%s\n", k, val)
	}
	return sb.String()
}

// readGoldenFile reads the given golden file and returns its contents.
func readGoldenFile(name string) (string, error) {
	gf := filepath.Join("testdata", name+".golden")
	b, err := os.ReadFile(gf)
	if err != nil {
		return "", xerrors.Errorf("failed to read golden file %q: %w", gf, err)
	}
	return string(b), nil
}

// writeGoldenFiles writes the given golden file with the given contents.
func writeGoldenFile(name string, manifests map[string]string) error {
	gf := filepath.Join("testdata", name+".golden")
	return os.WriteFile(gf, []byte(dumpManifests(manifests)), 0644) // nolint:gosec
}

// mapToValues converts a map to a Values struct.
func mapToValues(m map[string]interface{}) (*Values, error) {
	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(m); err != nil {
		return nil, err
	}
	var v Values
	if err := json.NewDecoder(&buf).Decode(&v); err != nil {
		return nil, err
	}
	return &v, nil
}

// valuesToMap converts a Values struct to a map.
func valuesToMap(v *Values) (map[string]interface{}, error) {
	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(v); err != nil {
		return nil, err
	}
	var m map[string]interface{}
	if err := json.NewDecoder(&buf).Decode(&m); err != nil {
		return nil, err
	}
	return m, nil
}
