// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const acquireProvisionerJob = `-- name: AcquireProvisionerJob :one
UPDATE
  provisioner_job
SET
  started_at = $1,
  updated_at = $1,
  worker_id = $2
WHERE
  id = (
    SELECT
      id
    FROM
      provisioner_job AS nested
    WHERE
      nested.started_at IS NULL
      AND nested.cancelled_at IS NULL
      AND nested.completed_at IS NULL
      AND nested.provisioner = ANY($3 :: provisioner_type [ ])
    ORDER BY
      nested.created_at FOR
    UPDATE
      SKIP LOCKED
    LIMIT
      1
  ) RETURNING id, created_at, updated_at, started_at, cancelled_at, completed_at, error, organization_id, initiator_id, provisioner, storage_method, storage_source, type, input, worker_id
`

type AcquireProvisionerJobParams struct {
	StartedAt sql.NullTime      `db:"started_at" json:"started_at"`
	WorkerID  uuid.NullUUID     `db:"worker_id" json:"worker_id"`
	Types     []ProvisionerType `db:"types" json:"types"`
}

// Acquires the lock for a single job that isn't started, completed,
// cancelled, and that matches an array of provisioner types.
//
// SKIP LOCKED is used to jump over locked rows. This prevents
// multiple provisioners from acquiring the same jobs. See:
// https://www.postgresql.org/docs/9.5/sql-select.html#SQL-FOR-UPDATE-SHARE
func (q *sqlQuerier) AcquireProvisionerJob(ctx context.Context, arg AcquireProvisionerJobParams) (ProvisionerJob, error) {
	row := q.db.QueryRowContext(ctx, acquireProvisionerJob, arg.StartedAt, arg.WorkerID, pq.Array(arg.Types))
	var i ProvisionerJob
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.CancelledAt,
		&i.CompletedAt,
		&i.Error,
		&i.OrganizationID,
		&i.InitiatorID,
		&i.Provisioner,
		&i.StorageMethod,
		&i.StorageSource,
		&i.Type,
		&i.Input,
		&i.WorkerID,
	)
	return i, err
}

const getAPIKeyByID = `-- name: GetAPIKeyByID :one
SELECT
  id, hashed_secret, user_id, application, name, last_used, expires_at, created_at, updated_at, login_type, oidc_access_token, oidc_refresh_token, oidc_id_token, oidc_expiry, devurl_token
FROM
  api_keys
WHERE
  id = $1
LIMIT
  1
`

func (q *sqlQuerier) GetAPIKeyByID(ctx context.Context, id string) (APIKey, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyByID, id)
	var i APIKey
	err := row.Scan(
		&i.ID,
		&i.HashedSecret,
		&i.UserID,
		&i.Application,
		&i.Name,
		&i.LastUsed,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LoginType,
		&i.OIDCAccessToken,
		&i.OIDCRefreshToken,
		&i.OIDCIDToken,
		&i.OIDCExpiry,
		&i.DevurlToken,
	)
	return i, err
}

const getFileByHash = `-- name: GetFileByHash :one
SELECT
  hash, created_at, created_by, mimetype, data
FROM
  file
WHERE
  hash = $1
LIMIT
  1
`

func (q *sqlQuerier) GetFileByHash(ctx context.Context, hash string) (File, error) {
	row := q.db.QueryRowContext(ctx, getFileByHash, hash)
	var i File
	err := row.Scan(
		&i.Hash,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Mimetype,
		&i.Data,
	)
	return i, err
}

const getOrganizationByID = `-- name: GetOrganizationByID :one
SELECT
  id, name, description, created_at, updated_at, "default", auto_off_threshold, cpu_provisioning_rate, memory_provisioning_rate, workspace_auto_off
FROM
  organizations
WHERE
  id = $1
`

func (q *sqlQuerier) GetOrganizationByID(ctx context.Context, id string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByID, id)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Default,
		&i.AutoOffThreshold,
		&i.CpuProvisioningRate,
		&i.MemoryProvisioningRate,
		&i.WorkspaceAutoOff,
	)
	return i, err
}

const getOrganizationByName = `-- name: GetOrganizationByName :one
SELECT
  id, name, description, created_at, updated_at, "default", auto_off_threshold, cpu_provisioning_rate, memory_provisioning_rate, workspace_auto_off
FROM
  organizations
WHERE
  LOWER(name) = LOWER($1)
LIMIT
  1
`

func (q *sqlQuerier) GetOrganizationByName(ctx context.Context, name string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByName, name)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Default,
		&i.AutoOffThreshold,
		&i.CpuProvisioningRate,
		&i.MemoryProvisioningRate,
		&i.WorkspaceAutoOff,
	)
	return i, err
}

const getOrganizationMemberByUserID = `-- name: GetOrganizationMemberByUserID :one
SELECT
  organization_id, user_id, created_at, updated_at, roles
FROM
  organization_members
WHERE
  organization_id = $1
  AND user_id = $2
LIMIT
  1
`

type GetOrganizationMemberByUserIDParams struct {
	OrganizationID string `db:"organization_id" json:"organization_id"`
	UserID         string `db:"user_id" json:"user_id"`
}

func (q *sqlQuerier) GetOrganizationMemberByUserID(ctx context.Context, arg GetOrganizationMemberByUserIDParams) (OrganizationMember, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationMemberByUserID, arg.OrganizationID, arg.UserID)
	var i OrganizationMember
	err := row.Scan(
		&i.OrganizationID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		pq.Array(&i.Roles),
	)
	return i, err
}

const getOrganizationsByUserID = `-- name: GetOrganizationsByUserID :many
SELECT
  id, name, description, created_at, updated_at, "default", auto_off_threshold, cpu_provisioning_rate, memory_provisioning_rate, workspace_auto_off
FROM
  organizations
WHERE
  id = (
    SELECT
      organization_id
    FROM
      organization_members
    WHERE
      user_id = $1
  )
`

func (q *sqlQuerier) GetOrganizationsByUserID(ctx context.Context, userID string) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, getOrganizationsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Default,
			&i.AutoOffThreshold,
			&i.CpuProvisioningRate,
			&i.MemoryProvisioningRate,
			&i.WorkspaceAutoOff,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParameterSchemasByJobID = `-- name: GetParameterSchemasByJobID :many
SELECT
  id, created_at, job_id, name, description, default_source_scheme, default_source_value, allow_override_source, default_destination_scheme, default_destination_value, allow_override_destination, default_refresh, redisplay_value, validation_error, validation_condition, validation_type_system, validation_value_type
FROM
  parameter_schema
WHERE
  job_id = $1
`

func (q *sqlQuerier) GetParameterSchemasByJobID(ctx context.Context, jobID uuid.UUID) ([]ParameterSchema, error) {
	rows, err := q.db.QueryContext(ctx, getParameterSchemasByJobID, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParameterSchema
	for rows.Next() {
		var i ParameterSchema
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.JobID,
			&i.Name,
			&i.Description,
			&i.DefaultSourceScheme,
			&i.DefaultSourceValue,
			&i.AllowOverrideSource,
			&i.DefaultDestinationScheme,
			&i.DefaultDestinationValue,
			&i.AllowOverrideDestination,
			&i.DefaultRefresh,
			&i.RedisplayValue,
			&i.ValidationError,
			&i.ValidationCondition,
			&i.ValidationTypeSystem,
			&i.ValidationValueType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParameterValuesByScope = `-- name: GetParameterValuesByScope :many
SELECT
  id, name, created_at, updated_at, scope, scope_id, source_scheme, source_value, destination_scheme, destination_value
FROM
  parameter_value
WHERE
  scope = $1
  AND scope_id = $2
`

type GetParameterValuesByScopeParams struct {
	Scope   ParameterScope `db:"scope" json:"scope"`
	ScopeID string         `db:"scope_id" json:"scope_id"`
}

func (q *sqlQuerier) GetParameterValuesByScope(ctx context.Context, arg GetParameterValuesByScopeParams) ([]ParameterValue, error) {
	rows, err := q.db.QueryContext(ctx, getParameterValuesByScope, arg.Scope, arg.ScopeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParameterValue
	for rows.Next() {
		var i ParameterValue
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Scope,
			&i.ScopeID,
			&i.SourceScheme,
			&i.SourceValue,
			&i.DestinationScheme,
			&i.DestinationValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT
  id, created_at, updated_at, organization_id, name, provisioner, active_version_id
FROM
  project
WHERE
  id = $1
LIMIT
  1
`

func (q *sqlQuerier) GetProjectByID(ctx context.Context, id uuid.UUID) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrganizationID,
		&i.Name,
		&i.Provisioner,
		&i.ActiveVersionID,
	)
	return i, err
}

const getProjectByOrganizationAndName = `-- name: GetProjectByOrganizationAndName :one
SELECT
  id, created_at, updated_at, organization_id, name, provisioner, active_version_id
FROM
  project
WHERE
  organization_id = $1
  AND LOWER(name) = LOWER($2)
LIMIT
  1
`

type GetProjectByOrganizationAndNameParams struct {
	OrganizationID string `db:"organization_id" json:"organization_id"`
	Name           string `db:"name" json:"name"`
}

func (q *sqlQuerier) GetProjectByOrganizationAndName(ctx context.Context, arg GetProjectByOrganizationAndNameParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByOrganizationAndName, arg.OrganizationID, arg.Name)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrganizationID,
		&i.Name,
		&i.Provisioner,
		&i.ActiveVersionID,
	)
	return i, err
}

const getProjectVersionByID = `-- name: GetProjectVersionByID :one
SELECT
  id, project_id, created_at, updated_at, name, description, import_job_id
FROM
  project_version
WHERE
  id = $1
`

func (q *sqlQuerier) GetProjectVersionByID(ctx context.Context, id uuid.UUID) (ProjectVersion, error) {
	row := q.db.QueryRowContext(ctx, getProjectVersionByID, id)
	var i ProjectVersion
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.ImportJobID,
	)
	return i, err
}

const getProjectVersionByProjectIDAndName = `-- name: GetProjectVersionByProjectIDAndName :one
SELECT
  id, project_id, created_at, updated_at, name, description, import_job_id
FROM
  project_version
WHERE
  project_id = $1
  AND name = $2
`

type GetProjectVersionByProjectIDAndNameParams struct {
	ProjectID uuid.UUID `db:"project_id" json:"project_id"`
	Name      string    `db:"name" json:"name"`
}

func (q *sqlQuerier) GetProjectVersionByProjectIDAndName(ctx context.Context, arg GetProjectVersionByProjectIDAndNameParams) (ProjectVersion, error) {
	row := q.db.QueryRowContext(ctx, getProjectVersionByProjectIDAndName, arg.ProjectID, arg.Name)
	var i ProjectVersion
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.ImportJobID,
	)
	return i, err
}

const getProjectVersionsByProjectID = `-- name: GetProjectVersionsByProjectID :many
SELECT
  id, project_id, created_at, updated_at, name, description, import_job_id
FROM
  project_version
WHERE
  project_id = $1
`

func (q *sqlQuerier) GetProjectVersionsByProjectID(ctx context.Context, projectID uuid.UUID) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, getProjectVersionsByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.ImportJobID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByOrganizationIDs = `-- name: GetProjectsByOrganizationIDs :many
SELECT
  id, created_at, updated_at, organization_id, name, provisioner, active_version_id
FROM
  project
WHERE
  organization_id = ANY($1 :: text [ ])
`

func (q *sqlQuerier) GetProjectsByOrganizationIDs(ctx context.Context, ids []string) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getProjectsByOrganizationIDs, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrganizationID,
			&i.Name,
			&i.Provisioner,
			&i.ActiveVersionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProvisionerDaemonByID = `-- name: GetProvisionerDaemonByID :one
SELECT
  id, created_at, updated_at, name, provisioners
FROM
  provisioner_daemon
WHERE
  id = $1
`

func (q *sqlQuerier) GetProvisionerDaemonByID(ctx context.Context, id uuid.UUID) (ProvisionerDaemon, error) {
	row := q.db.QueryRowContext(ctx, getProvisionerDaemonByID, id)
	var i ProvisionerDaemon
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		pq.Array(&i.Provisioners),
	)
	return i, err
}

const getProvisionerDaemons = `-- name: GetProvisionerDaemons :many
SELECT
  id, created_at, updated_at, name, provisioners
FROM
  provisioner_daemon
`

func (q *sqlQuerier) GetProvisionerDaemons(ctx context.Context) ([]ProvisionerDaemon, error) {
	rows, err := q.db.QueryContext(ctx, getProvisionerDaemons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProvisionerDaemon
	for rows.Next() {
		var i ProvisionerDaemon
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			pq.Array(&i.Provisioners),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProvisionerJobByID = `-- name: GetProvisionerJobByID :one
SELECT
  id, created_at, updated_at, started_at, cancelled_at, completed_at, error, organization_id, initiator_id, provisioner, storage_method, storage_source, type, input, worker_id
FROM
  provisioner_job
WHERE
  id = $1
`

func (q *sqlQuerier) GetProvisionerJobByID(ctx context.Context, id uuid.UUID) (ProvisionerJob, error) {
	row := q.db.QueryRowContext(ctx, getProvisionerJobByID, id)
	var i ProvisionerJob
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.CancelledAt,
		&i.CompletedAt,
		&i.Error,
		&i.OrganizationID,
		&i.InitiatorID,
		&i.Provisioner,
		&i.StorageMethod,
		&i.StorageSource,
		&i.Type,
		&i.Input,
		&i.WorkerID,
	)
	return i, err
}

const getProvisionerLogsByIDBetween = `-- name: GetProvisionerLogsByIDBetween :many
SELECT
  id, job_id, created_at, source, level, output
FROM
  provisioner_job_log
WHERE
  job_id = $1
  AND (
    created_at >= $2
    OR created_at <= $3
  )
ORDER BY
  created_at
`

type GetProvisionerLogsByIDBetweenParams struct {
	JobID         uuid.UUID `db:"job_id" json:"job_id"`
	CreatedAfter  time.Time `db:"created_after" json:"created_after"`
	CreatedBefore time.Time `db:"created_before" json:"created_before"`
}

func (q *sqlQuerier) GetProvisionerLogsByIDBetween(ctx context.Context, arg GetProvisionerLogsByIDBetweenParams) ([]ProvisionerJobLog, error) {
	rows, err := q.db.QueryContext(ctx, getProvisionerLogsByIDBetween, arg.JobID, arg.CreatedAfter, arg.CreatedBefore)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProvisionerJobLog
	for rows.Next() {
		var i ProvisionerJobLog
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.CreatedAt,
			&i.Source,
			&i.Level,
			&i.Output,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmailOrUsername = `-- name: GetUserByEmailOrUsername :one
SELECT
  id, email, name, revoked, login_type, hashed_password, created_at, updated_at, temporary_password, avatar_hash, ssh_key_regenerated_at, username, dotfiles_git_uri, roles, status, relatime, gpg_key_regenerated_at, _decomissioned, shell
FROM
  users
WHERE
  LOWER(username) = LOWER($1)
  OR email = $2
LIMIT
  1
`

type GetUserByEmailOrUsernameParams struct {
	Username string `db:"username" json:"username"`
	Email    string `db:"email" json:"email"`
}

func (q *sqlQuerier) GetUserByEmailOrUsername(ctx context.Context, arg GetUserByEmailOrUsernameParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailOrUsername, arg.Username, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Revoked,
		&i.LoginType,
		&i.HashedPassword,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TemporaryPassword,
		&i.AvatarHash,
		&i.SshKeyRegeneratedAt,
		&i.Username,
		&i.DotfilesGitUri,
		pq.Array(&i.Roles),
		&i.Status,
		&i.Relatime,
		&i.GpgKeyRegeneratedAt,
		&i.Decomissioned,
		&i.Shell,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
  id, email, name, revoked, login_type, hashed_password, created_at, updated_at, temporary_password, avatar_hash, ssh_key_regenerated_at, username, dotfiles_git_uri, roles, status, relatime, gpg_key_regenerated_at, _decomissioned, shell
FROM
  users
WHERE
  id = $1
LIMIT
  1
`

func (q *sqlQuerier) GetUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Revoked,
		&i.LoginType,
		&i.HashedPassword,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TemporaryPassword,
		&i.AvatarHash,
		&i.SshKeyRegeneratedAt,
		&i.Username,
		&i.DotfilesGitUri,
		pq.Array(&i.Roles),
		&i.Status,
		&i.Relatime,
		&i.GpgKeyRegeneratedAt,
		&i.Decomissioned,
		&i.Shell,
	)
	return i, err
}

const getUserCount = `-- name: GetUserCount :one
SELECT
  COUNT(*)
FROM
  users
`

func (q *sqlQuerier) GetUserCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getWorkspaceAgentsByResourceIDs = `-- name: GetWorkspaceAgentsByResourceIDs :many
SELECT
  id, workspace_resource_id, created_at, updated_at, instance_metadata, resource_metadata
FROM
  workspace_agent
WHERE
  workspace_resource_id = ANY($1 :: uuid [ ])
`

func (q *sqlQuerier) GetWorkspaceAgentsByResourceIDs(ctx context.Context, ids []uuid.UUID) ([]WorkspaceAgent, error) {
	rows, err := q.db.QueryContext(ctx, getWorkspaceAgentsByResourceIDs, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkspaceAgent
	for rows.Next() {
		var i WorkspaceAgent
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceResourceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InstanceMetadata,
			&i.ResourceMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceByID = `-- name: GetWorkspaceByID :one
SELECT
  id, created_at, updated_at, owner_id, project_id, name
FROM
  workspace
WHERE
  id = $1
LIMIT
  1
`

func (q *sqlQuerier) GetWorkspaceByID(ctx context.Context, id uuid.UUID) (Workspace, error) {
	row := q.db.QueryRowContext(ctx, getWorkspaceByID, id)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OwnerID,
		&i.ProjectID,
		&i.Name,
	)
	return i, err
}

const getWorkspaceByUserIDAndName = `-- name: GetWorkspaceByUserIDAndName :one
SELECT
  id, created_at, updated_at, owner_id, project_id, name
FROM
  workspace
WHERE
  owner_id = $1
  AND LOWER(name) = LOWER($2)
`

type GetWorkspaceByUserIDAndNameParams struct {
	OwnerID string `db:"owner_id" json:"owner_id"`
	Name    string `db:"name" json:"name"`
}

func (q *sqlQuerier) GetWorkspaceByUserIDAndName(ctx context.Context, arg GetWorkspaceByUserIDAndNameParams) (Workspace, error) {
	row := q.db.QueryRowContext(ctx, getWorkspaceByUserIDAndName, arg.OwnerID, arg.Name)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OwnerID,
		&i.ProjectID,
		&i.Name,
	)
	return i, err
}

const getWorkspaceHistoryByID = `-- name: GetWorkspaceHistoryByID :one
SELECT
  id, created_at, updated_at, workspace_id, project_version_id, name, before_id, after_id, transition, initiator, provisioner_state, provision_job_id
FROM
  workspace_history
WHERE
  id = $1
LIMIT
  1
`

func (q *sqlQuerier) GetWorkspaceHistoryByID(ctx context.Context, id uuid.UUID) (WorkspaceHistory, error) {
	row := q.db.QueryRowContext(ctx, getWorkspaceHistoryByID, id)
	var i WorkspaceHistory
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WorkspaceID,
		&i.ProjectVersionID,
		&i.Name,
		&i.BeforeID,
		&i.AfterID,
		&i.Transition,
		&i.Initiator,
		&i.ProvisionerState,
		&i.ProvisionJobID,
	)
	return i, err
}

const getWorkspaceHistoryByWorkspaceID = `-- name: GetWorkspaceHistoryByWorkspaceID :many
SELECT
  id, created_at, updated_at, workspace_id, project_version_id, name, before_id, after_id, transition, initiator, provisioner_state, provision_job_id
FROM
  workspace_history
WHERE
  workspace_id = $1
`

func (q *sqlQuerier) GetWorkspaceHistoryByWorkspaceID(ctx context.Context, workspaceID uuid.UUID) ([]WorkspaceHistory, error) {
	rows, err := q.db.QueryContext(ctx, getWorkspaceHistoryByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkspaceHistory
	for rows.Next() {
		var i WorkspaceHistory
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WorkspaceID,
			&i.ProjectVersionID,
			&i.Name,
			&i.BeforeID,
			&i.AfterID,
			&i.Transition,
			&i.Initiator,
			&i.ProvisionerState,
			&i.ProvisionJobID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceHistoryByWorkspaceIDAndName = `-- name: GetWorkspaceHistoryByWorkspaceIDAndName :one
SELECT
  id, created_at, updated_at, workspace_id, project_version_id, name, before_id, after_id, transition, initiator, provisioner_state, provision_job_id
FROM
  workspace_history
WHERE
  workspace_id = $1
  AND name = $2
`

type GetWorkspaceHistoryByWorkspaceIDAndNameParams struct {
	WorkspaceID uuid.UUID `db:"workspace_id" json:"workspace_id"`
	Name        string    `db:"name" json:"name"`
}

func (q *sqlQuerier) GetWorkspaceHistoryByWorkspaceIDAndName(ctx context.Context, arg GetWorkspaceHistoryByWorkspaceIDAndNameParams) (WorkspaceHistory, error) {
	row := q.db.QueryRowContext(ctx, getWorkspaceHistoryByWorkspaceIDAndName, arg.WorkspaceID, arg.Name)
	var i WorkspaceHistory
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WorkspaceID,
		&i.ProjectVersionID,
		&i.Name,
		&i.BeforeID,
		&i.AfterID,
		&i.Transition,
		&i.Initiator,
		&i.ProvisionerState,
		&i.ProvisionJobID,
	)
	return i, err
}

const getWorkspaceHistoryByWorkspaceIDWithoutAfter = `-- name: GetWorkspaceHistoryByWorkspaceIDWithoutAfter :one
SELECT
  id, created_at, updated_at, workspace_id, project_version_id, name, before_id, after_id, transition, initiator, provisioner_state, provision_job_id
FROM
  workspace_history
WHERE
  workspace_id = $1
  AND after_id IS NULL
LIMIT
  1
`

func (q *sqlQuerier) GetWorkspaceHistoryByWorkspaceIDWithoutAfter(ctx context.Context, workspaceID uuid.UUID) (WorkspaceHistory, error) {
	row := q.db.QueryRowContext(ctx, getWorkspaceHistoryByWorkspaceIDWithoutAfter, workspaceID)
	var i WorkspaceHistory
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WorkspaceID,
		&i.ProjectVersionID,
		&i.Name,
		&i.BeforeID,
		&i.AfterID,
		&i.Transition,
		&i.Initiator,
		&i.ProvisionerState,
		&i.ProvisionJobID,
	)
	return i, err
}

const getWorkspaceResourcesByHistoryID = `-- name: GetWorkspaceResourcesByHistoryID :many
SELECT
  id, created_at, workspace_history_id, type, name, workspace_agent_token, workspace_agent_id
FROM
  workspace_resource
WHERE
  workspace_history_id = $1
`

func (q *sqlQuerier) GetWorkspaceResourcesByHistoryID(ctx context.Context, workspaceHistoryID uuid.UUID) ([]WorkspaceResource, error) {
	rows, err := q.db.QueryContext(ctx, getWorkspaceResourcesByHistoryID, workspaceHistoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkspaceResource
	for rows.Next() {
		var i WorkspaceResource
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.WorkspaceHistoryID,
			&i.Type,
			&i.Name,
			&i.WorkspaceAgentToken,
			&i.WorkspaceAgentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspacesByProjectAndUserID = `-- name: GetWorkspacesByProjectAndUserID :many
SELECT
  id, created_at, updated_at, owner_id, project_id, name
FROM
  workspace
WHERE
  owner_id = $1
  AND project_id = $2
`

type GetWorkspacesByProjectAndUserIDParams struct {
	OwnerID   string    `db:"owner_id" json:"owner_id"`
	ProjectID uuid.UUID `db:"project_id" json:"project_id"`
}

func (q *sqlQuerier) GetWorkspacesByProjectAndUserID(ctx context.Context, arg GetWorkspacesByProjectAndUserIDParams) ([]Workspace, error) {
	rows, err := q.db.QueryContext(ctx, getWorkspacesByProjectAndUserID, arg.OwnerID, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workspace
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerID,
			&i.ProjectID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspacesByUserID = `-- name: GetWorkspacesByUserID :many
SELECT
  id, created_at, updated_at, owner_id, project_id, name
FROM
  workspace
WHERE
  owner_id = $1
`

func (q *sqlQuerier) GetWorkspacesByUserID(ctx context.Context, ownerID string) ([]Workspace, error) {
	rows, err := q.db.QueryContext(ctx, getWorkspacesByUserID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workspace
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerID,
			&i.ProjectID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAPIKey = `-- name: InsertAPIKey :one
INSERT INTO
  api_keys (
    id,
    hashed_secret,
    user_id,
    application,
    name,
    last_used,
    expires_at,
    created_at,
    updated_at,
    login_type,
    oidc_access_token,
    oidc_refresh_token,
    oidc_id_token,
    oidc_expiry,
    devurl_token
  )
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15
  ) RETURNING id, hashed_secret, user_id, application, name, last_used, expires_at, created_at, updated_at, login_type, oidc_access_token, oidc_refresh_token, oidc_id_token, oidc_expiry, devurl_token
`

type InsertAPIKeyParams struct {
	ID               string    `db:"id" json:"id"`
	HashedSecret     []byte    `db:"hashed_secret" json:"hashed_secret"`
	UserID           string    `db:"user_id" json:"user_id"`
	Application      bool      `db:"application" json:"application"`
	Name             string    `db:"name" json:"name"`
	LastUsed         time.Time `db:"last_used" json:"last_used"`
	ExpiresAt        time.Time `db:"expires_at" json:"expires_at"`
	CreatedAt        time.Time `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time `db:"updated_at" json:"updated_at"`
	LoginType        LoginType `db:"login_type" json:"login_type"`
	OIDCAccessToken  string    `db:"oidc_access_token" json:"oidc_access_token"`
	OIDCRefreshToken string    `db:"oidc_refresh_token" json:"oidc_refresh_token"`
	OIDCIDToken      string    `db:"oidc_id_token" json:"oidc_id_token"`
	OIDCExpiry       time.Time `db:"oidc_expiry" json:"oidc_expiry"`
	DevurlToken      bool      `db:"devurl_token" json:"devurl_token"`
}

func (q *sqlQuerier) InsertAPIKey(ctx context.Context, arg InsertAPIKeyParams) (APIKey, error) {
	row := q.db.QueryRowContext(ctx, insertAPIKey,
		arg.ID,
		arg.HashedSecret,
		arg.UserID,
		arg.Application,
		arg.Name,
		arg.LastUsed,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.LoginType,
		arg.OIDCAccessToken,
		arg.OIDCRefreshToken,
		arg.OIDCIDToken,
		arg.OIDCExpiry,
		arg.DevurlToken,
	)
	var i APIKey
	err := row.Scan(
		&i.ID,
		&i.HashedSecret,
		&i.UserID,
		&i.Application,
		&i.Name,
		&i.LastUsed,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LoginType,
		&i.OIDCAccessToken,
		&i.OIDCRefreshToken,
		&i.OIDCIDToken,
		&i.OIDCExpiry,
		&i.DevurlToken,
	)
	return i, err
}

const insertFile = `-- name: InsertFile :one
INSERT INTO
  file (hash, created_at, created_by, mimetype, data)
VALUES
  ($1, $2, $3, $4, $5) RETURNING hash, created_at, created_by, mimetype, data
`

type InsertFileParams struct {
	Hash      string    `db:"hash" json:"hash"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	CreatedBy string    `db:"created_by" json:"created_by"`
	Mimetype  string    `db:"mimetype" json:"mimetype"`
	Data      []byte    `db:"data" json:"data"`
}

func (q *sqlQuerier) InsertFile(ctx context.Context, arg InsertFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, insertFile,
		arg.Hash,
		arg.CreatedAt,
		arg.CreatedBy,
		arg.Mimetype,
		arg.Data,
	)
	var i File
	err := row.Scan(
		&i.Hash,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Mimetype,
		&i.Data,
	)
	return i, err
}

const insertOrganization = `-- name: InsertOrganization :one
INSERT INTO
  organizations (id, name, description, created_at, updated_at)
VALUES
  ($1, $2, $3, $4, $5) RETURNING id, name, description, created_at, updated_at, "default", auto_off_threshold, cpu_provisioning_rate, memory_provisioning_rate, workspace_auto_off
`

type InsertOrganizationParams struct {
	ID          string    `db:"id" json:"id"`
	Name        string    `db:"name" json:"name"`
	Description string    `db:"description" json:"description"`
	CreatedAt   time.Time `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time `db:"updated_at" json:"updated_at"`
}

func (q *sqlQuerier) InsertOrganization(ctx context.Context, arg InsertOrganizationParams) (Organization, error) {
	row := q.db.QueryRowContext(ctx, insertOrganization,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Default,
		&i.AutoOffThreshold,
		&i.CpuProvisioningRate,
		&i.MemoryProvisioningRate,
		&i.WorkspaceAutoOff,
	)
	return i, err
}

const insertOrganizationMember = `-- name: InsertOrganizationMember :one
INSERT INTO
  organization_members (
    organization_id,
    user_id,
    created_at,
    updated_at,
    roles
  )
VALUES
  ($1, $2, $3, $4, $5) RETURNING organization_id, user_id, created_at, updated_at, roles
`

type InsertOrganizationMemberParams struct {
	OrganizationID string    `db:"organization_id" json:"organization_id"`
	UserID         string    `db:"user_id" json:"user_id"`
	CreatedAt      time.Time `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time `db:"updated_at" json:"updated_at"`
	Roles          []string  `db:"roles" json:"roles"`
}

func (q *sqlQuerier) InsertOrganizationMember(ctx context.Context, arg InsertOrganizationMemberParams) (OrganizationMember, error) {
	row := q.db.QueryRowContext(ctx, insertOrganizationMember,
		arg.OrganizationID,
		arg.UserID,
		arg.CreatedAt,
		arg.UpdatedAt,
		pq.Array(arg.Roles),
	)
	var i OrganizationMember
	err := row.Scan(
		&i.OrganizationID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		pq.Array(&i.Roles),
	)
	return i, err
}

const insertParameterSchema = `-- name: InsertParameterSchema :one
INSERT INTO
  parameter_schema (
    id,
    created_at,
    job_id,
    name,
    description,
    default_source_scheme,
    default_source_value,
    allow_override_source,
    default_destination_scheme,
    default_destination_value,
    allow_override_destination,
    default_refresh,
    redisplay_value,
    validation_error,
    validation_condition,
    validation_type_system,
    validation_value_type
  )
VALUES
  (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17
  ) RETURNING id, created_at, job_id, name, description, default_source_scheme, default_source_value, allow_override_source, default_destination_scheme, default_destination_value, allow_override_destination, default_refresh, redisplay_value, validation_error, validation_condition, validation_type_system, validation_value_type
`

type InsertParameterSchemaParams struct {
	ID                       uuid.UUID                  `db:"id" json:"id"`
	CreatedAt                time.Time                  `db:"created_at" json:"created_at"`
	JobID                    uuid.UUID                  `db:"job_id" json:"job_id"`
	Name                     string                     `db:"name" json:"name"`
	Description              string                     `db:"description" json:"description"`
	DefaultSourceScheme      ParameterSourceScheme      `db:"default_source_scheme" json:"default_source_scheme"`
	DefaultSourceValue       sql.NullString             `db:"default_source_value" json:"default_source_value"`
	AllowOverrideSource      bool                       `db:"allow_override_source" json:"allow_override_source"`
	DefaultDestinationScheme ParameterDestinationScheme `db:"default_destination_scheme" json:"default_destination_scheme"`
	DefaultDestinationValue  sql.NullString             `db:"default_destination_value" json:"default_destination_value"`
	AllowOverrideDestination bool                       `db:"allow_override_destination" json:"allow_override_destination"`
	DefaultRefresh           string                     `db:"default_refresh" json:"default_refresh"`
	RedisplayValue           bool                       `db:"redisplay_value" json:"redisplay_value"`
	ValidationError          string                     `db:"validation_error" json:"validation_error"`
	ValidationCondition      string                     `db:"validation_condition" json:"validation_condition"`
	ValidationTypeSystem     ParameterTypeSystem        `db:"validation_type_system" json:"validation_type_system"`
	ValidationValueType      string                     `db:"validation_value_type" json:"validation_value_type"`
}

func (q *sqlQuerier) InsertParameterSchema(ctx context.Context, arg InsertParameterSchemaParams) (ParameterSchema, error) {
	row := q.db.QueryRowContext(ctx, insertParameterSchema,
		arg.ID,
		arg.CreatedAt,
		arg.JobID,
		arg.Name,
		arg.Description,
		arg.DefaultSourceScheme,
		arg.DefaultSourceValue,
		arg.AllowOverrideSource,
		arg.DefaultDestinationScheme,
		arg.DefaultDestinationValue,
		arg.AllowOverrideDestination,
		arg.DefaultRefresh,
		arg.RedisplayValue,
		arg.ValidationError,
		arg.ValidationCondition,
		arg.ValidationTypeSystem,
		arg.ValidationValueType,
	)
	var i ParameterSchema
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.JobID,
		&i.Name,
		&i.Description,
		&i.DefaultSourceScheme,
		&i.DefaultSourceValue,
		&i.AllowOverrideSource,
		&i.DefaultDestinationScheme,
		&i.DefaultDestinationValue,
		&i.AllowOverrideDestination,
		&i.DefaultRefresh,
		&i.RedisplayValue,
		&i.ValidationError,
		&i.ValidationCondition,
		&i.ValidationTypeSystem,
		&i.ValidationValueType,
	)
	return i, err
}

const insertParameterValue = `-- name: InsertParameterValue :one
INSERT INTO
  parameter_value (
    id,
    name,
    created_at,
    updated_at,
    scope,
    scope_id,
    source_scheme,
    source_value,
    destination_scheme,
    destination_value
  )
VALUES
  ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING id, name, created_at, updated_at, scope, scope_id, source_scheme, source_value, destination_scheme, destination_value
`

type InsertParameterValueParams struct {
	ID                uuid.UUID                  `db:"id" json:"id"`
	Name              string                     `db:"name" json:"name"`
	CreatedAt         time.Time                  `db:"created_at" json:"created_at"`
	UpdatedAt         time.Time                  `db:"updated_at" json:"updated_at"`
	Scope             ParameterScope             `db:"scope" json:"scope"`
	ScopeID           string                     `db:"scope_id" json:"scope_id"`
	SourceScheme      ParameterSourceScheme      `db:"source_scheme" json:"source_scheme"`
	SourceValue       string                     `db:"source_value" json:"source_value"`
	DestinationScheme ParameterDestinationScheme `db:"destination_scheme" json:"destination_scheme"`
	DestinationValue  string                     `db:"destination_value" json:"destination_value"`
}

func (q *sqlQuerier) InsertParameterValue(ctx context.Context, arg InsertParameterValueParams) (ParameterValue, error) {
	row := q.db.QueryRowContext(ctx, insertParameterValue,
		arg.ID,
		arg.Name,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Scope,
		arg.ScopeID,
		arg.SourceScheme,
		arg.SourceValue,
		arg.DestinationScheme,
		arg.DestinationValue,
	)
	var i ParameterValue
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Scope,
		&i.ScopeID,
		&i.SourceScheme,
		&i.SourceValue,
		&i.DestinationScheme,
		&i.DestinationValue,
	)
	return i, err
}

const insertProject = `-- name: InsertProject :one
INSERT INTO
  project (
    id,
    created_at,
    updated_at,
    organization_id,
    name,
    provisioner,
    active_version_id
  )
VALUES
  ($1, $2, $3, $4, $5, $6, $7) RETURNING id, created_at, updated_at, organization_id, name, provisioner, active_version_id
`

type InsertProjectParams struct {
	ID              uuid.UUID       `db:"id" json:"id"`
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt       time.Time       `db:"updated_at" json:"updated_at"`
	OrganizationID  string          `db:"organization_id" json:"organization_id"`
	Name            string          `db:"name" json:"name"`
	Provisioner     ProvisionerType `db:"provisioner" json:"provisioner"`
	ActiveVersionID uuid.UUID       `db:"active_version_id" json:"active_version_id"`
}

func (q *sqlQuerier) InsertProject(ctx context.Context, arg InsertProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, insertProject,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.OrganizationID,
		arg.Name,
		arg.Provisioner,
		arg.ActiveVersionID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrganizationID,
		&i.Name,
		&i.Provisioner,
		&i.ActiveVersionID,
	)
	return i, err
}

const insertProjectVersion = `-- name: InsertProjectVersion :one
INSERT INTO
  project_version (
    id,
    project_id,
    created_at,
    updated_at,
    name,
    description,
    import_job_id
  )
VALUES
  ($1, $2, $3, $4, $5, $6, $7) RETURNING id, project_id, created_at, updated_at, name, description, import_job_id
`

type InsertProjectVersionParams struct {
	ID          uuid.UUID `db:"id" json:"id"`
	ProjectID   uuid.UUID `db:"project_id" json:"project_id"`
	CreatedAt   time.Time `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time `db:"updated_at" json:"updated_at"`
	Name        string    `db:"name" json:"name"`
	Description string    `db:"description" json:"description"`
	ImportJobID uuid.UUID `db:"import_job_id" json:"import_job_id"`
}

func (q *sqlQuerier) InsertProjectVersion(ctx context.Context, arg InsertProjectVersionParams) (ProjectVersion, error) {
	row := q.db.QueryRowContext(ctx, insertProjectVersion,
		arg.ID,
		arg.ProjectID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Name,
		arg.Description,
		arg.ImportJobID,
	)
	var i ProjectVersion
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.ImportJobID,
	)
	return i, err
}

const insertProvisionerDaemon = `-- name: InsertProvisionerDaemon :one
INSERT INTO
  provisioner_daemon (id, created_at, name, provisioners)
VALUES
  ($1, $2, $3, $4) RETURNING id, created_at, updated_at, name, provisioners
`

type InsertProvisionerDaemonParams struct {
	ID           uuid.UUID         `db:"id" json:"id"`
	CreatedAt    time.Time         `db:"created_at" json:"created_at"`
	Name         string            `db:"name" json:"name"`
	Provisioners []ProvisionerType `db:"provisioners" json:"provisioners"`
}

func (q *sqlQuerier) InsertProvisionerDaemon(ctx context.Context, arg InsertProvisionerDaemonParams) (ProvisionerDaemon, error) {
	row := q.db.QueryRowContext(ctx, insertProvisionerDaemon,
		arg.ID,
		arg.CreatedAt,
		arg.Name,
		pq.Array(arg.Provisioners),
	)
	var i ProvisionerDaemon
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		pq.Array(&i.Provisioners),
	)
	return i, err
}

const insertProvisionerJob = `-- name: InsertProvisionerJob :one
INSERT INTO
  provisioner_job (
    id,
    created_at,
    updated_at,
    organization_id,
    initiator_id,
    provisioner,
    storage_method,
    storage_source,
    type,
    input
  )
VALUES
  ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING id, created_at, updated_at, started_at, cancelled_at, completed_at, error, organization_id, initiator_id, provisioner, storage_method, storage_source, type, input, worker_id
`

type InsertProvisionerJobParams struct {
	ID             uuid.UUID                `db:"id" json:"id"`
	CreatedAt      time.Time                `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time                `db:"updated_at" json:"updated_at"`
	OrganizationID string                   `db:"organization_id" json:"organization_id"`
	InitiatorID    string                   `db:"initiator_id" json:"initiator_id"`
	Provisioner    ProvisionerType          `db:"provisioner" json:"provisioner"`
	StorageMethod  ProvisionerStorageMethod `db:"storage_method" json:"storage_method"`
	StorageSource  string                   `db:"storage_source" json:"storage_source"`
	Type           ProvisionerJobType       `db:"type" json:"type"`
	Input          json.RawMessage          `db:"input" json:"input"`
}

func (q *sqlQuerier) InsertProvisionerJob(ctx context.Context, arg InsertProvisionerJobParams) (ProvisionerJob, error) {
	row := q.db.QueryRowContext(ctx, insertProvisionerJob,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.OrganizationID,
		arg.InitiatorID,
		arg.Provisioner,
		arg.StorageMethod,
		arg.StorageSource,
		arg.Type,
		arg.Input,
	)
	var i ProvisionerJob
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.CancelledAt,
		&i.CompletedAt,
		&i.Error,
		&i.OrganizationID,
		&i.InitiatorID,
		&i.Provisioner,
		&i.StorageMethod,
		&i.StorageSource,
		&i.Type,
		&i.Input,
		&i.WorkerID,
	)
	return i, err
}

const insertProvisionerJobLogs = `-- name: InsertProvisionerJobLogs :many
INSERT INTO
  provisioner_job_log
SELECT
  unnest($1 :: uuid [ ]) AS id,
  $2 :: uuid AS job_id,
  unnest($3 :: timestamptz [ ]) AS created_at,
  unnest($4 :: log_source [ ]) as source,
  unnest($5 :: log_level [ ]) as level,
  unnest($6 :: varchar(1024) [ ]) as output RETURNING id, job_id, created_at, source, level, output
`

type InsertProvisionerJobLogsParams struct {
	ID        []uuid.UUID `db:"id" json:"id"`
	JobID     uuid.UUID   `db:"job_id" json:"job_id"`
	CreatedAt []time.Time `db:"created_at" json:"created_at"`
	Source    []LogSource `db:"source" json:"source"`
	Level     []LogLevel  `db:"level" json:"level"`
	Output    []string    `db:"output" json:"output"`
}

func (q *sqlQuerier) InsertProvisionerJobLogs(ctx context.Context, arg InsertProvisionerJobLogsParams) ([]ProvisionerJobLog, error) {
	rows, err := q.db.QueryContext(ctx, insertProvisionerJobLogs,
		pq.Array(arg.ID),
		arg.JobID,
		pq.Array(arg.CreatedAt),
		pq.Array(arg.Source),
		pq.Array(arg.Level),
		pq.Array(arg.Output),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProvisionerJobLog
	for rows.Next() {
		var i ProvisionerJobLog
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.CreatedAt,
			&i.Source,
			&i.Level,
			&i.Output,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertUser = `-- name: InsertUser :one
INSERT INTO
  users (
    id,
    email,
    name,
    login_type,
    revoked,
    hashed_password,
    created_at,
    updated_at,
    username
  )
VALUES
  ($1, $2, $3, $4, false, $5, $6, $7, $8) RETURNING id, email, name, revoked, login_type, hashed_password, created_at, updated_at, temporary_password, avatar_hash, ssh_key_regenerated_at, username, dotfiles_git_uri, roles, status, relatime, gpg_key_regenerated_at, _decomissioned, shell
`

type InsertUserParams struct {
	ID             string    `db:"id" json:"id"`
	Email          string    `db:"email" json:"email"`
	Name           string    `db:"name" json:"name"`
	LoginType      LoginType `db:"login_type" json:"login_type"`
	HashedPassword []byte    `db:"hashed_password" json:"hashed_password"`
	CreatedAt      time.Time `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time `db:"updated_at" json:"updated_at"`
	Username       string    `db:"username" json:"username"`
}

func (q *sqlQuerier) InsertUser(ctx context.Context, arg InsertUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, insertUser,
		arg.ID,
		arg.Email,
		arg.Name,
		arg.LoginType,
		arg.HashedPassword,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Username,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Revoked,
		&i.LoginType,
		&i.HashedPassword,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TemporaryPassword,
		&i.AvatarHash,
		&i.SshKeyRegeneratedAt,
		&i.Username,
		&i.DotfilesGitUri,
		pq.Array(&i.Roles),
		&i.Status,
		&i.Relatime,
		&i.GpgKeyRegeneratedAt,
		&i.Decomissioned,
		&i.Shell,
	)
	return i, err
}

const insertWorkspace = `-- name: InsertWorkspace :one
INSERT INTO
  workspace (
    id,
    created_at,
    updated_at,
    owner_id,
    project_id,
    name
  )
VALUES
  ($1, $2, $3, $4, $5, $6) RETURNING id, created_at, updated_at, owner_id, project_id, name
`

type InsertWorkspaceParams struct {
	ID        uuid.UUID `db:"id" json:"id"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
	OwnerID   string    `db:"owner_id" json:"owner_id"`
	ProjectID uuid.UUID `db:"project_id" json:"project_id"`
	Name      string    `db:"name" json:"name"`
}

func (q *sqlQuerier) InsertWorkspace(ctx context.Context, arg InsertWorkspaceParams) (Workspace, error) {
	row := q.db.QueryRowContext(ctx, insertWorkspace,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.OwnerID,
		arg.ProjectID,
		arg.Name,
	)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OwnerID,
		&i.ProjectID,
		&i.Name,
	)
	return i, err
}

const insertWorkspaceAgent = `-- name: InsertWorkspaceAgent :one
INSERT INTO
  workspace_agent (
    id,
    workspace_resource_id,
    created_at,
    updated_at,
    instance_metadata,
    resource_metadata
  )
VALUES
  ($1, $2, $3, $4, $5, $6) RETURNING id, workspace_resource_id, created_at, updated_at, instance_metadata, resource_metadata
`

type InsertWorkspaceAgentParams struct {
	ID                  uuid.UUID       `db:"id" json:"id"`
	WorkspaceResourceID uuid.UUID       `db:"workspace_resource_id" json:"workspace_resource_id"`
	CreatedAt           time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt           time.Time       `db:"updated_at" json:"updated_at"`
	InstanceMetadata    json.RawMessage `db:"instance_metadata" json:"instance_metadata"`
	ResourceMetadata    json.RawMessage `db:"resource_metadata" json:"resource_metadata"`
}

func (q *sqlQuerier) InsertWorkspaceAgent(ctx context.Context, arg InsertWorkspaceAgentParams) (WorkspaceAgent, error) {
	row := q.db.QueryRowContext(ctx, insertWorkspaceAgent,
		arg.ID,
		arg.WorkspaceResourceID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.InstanceMetadata,
		arg.ResourceMetadata,
	)
	var i WorkspaceAgent
	err := row.Scan(
		&i.ID,
		&i.WorkspaceResourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.InstanceMetadata,
		&i.ResourceMetadata,
	)
	return i, err
}

const insertWorkspaceHistory = `-- name: InsertWorkspaceHistory :one
INSERT INTO
  workspace_history (
    id,
    created_at,
    updated_at,
    workspace_id,
    project_version_id,
    before_id,
    name,
    transition,
    initiator,
    provision_job_id,
    provisioner_state
  )
VALUES
  ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id, created_at, updated_at, workspace_id, project_version_id, name, before_id, after_id, transition, initiator, provisioner_state, provision_job_id
`

type InsertWorkspaceHistoryParams struct {
	ID               uuid.UUID           `db:"id" json:"id"`
	CreatedAt        time.Time           `db:"created_at" json:"created_at"`
	UpdatedAt        time.Time           `db:"updated_at" json:"updated_at"`
	WorkspaceID      uuid.UUID           `db:"workspace_id" json:"workspace_id"`
	ProjectVersionID uuid.UUID           `db:"project_version_id" json:"project_version_id"`
	BeforeID         uuid.NullUUID       `db:"before_id" json:"before_id"`
	Name             string              `db:"name" json:"name"`
	Transition       WorkspaceTransition `db:"transition" json:"transition"`
	Initiator        string              `db:"initiator" json:"initiator"`
	ProvisionJobID   uuid.UUID           `db:"provision_job_id" json:"provision_job_id"`
	ProvisionerState []byte              `db:"provisioner_state" json:"provisioner_state"`
}

func (q *sqlQuerier) InsertWorkspaceHistory(ctx context.Context, arg InsertWorkspaceHistoryParams) (WorkspaceHistory, error) {
	row := q.db.QueryRowContext(ctx, insertWorkspaceHistory,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.WorkspaceID,
		arg.ProjectVersionID,
		arg.BeforeID,
		arg.Name,
		arg.Transition,
		arg.Initiator,
		arg.ProvisionJobID,
		arg.ProvisionerState,
	)
	var i WorkspaceHistory
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.WorkspaceID,
		&i.ProjectVersionID,
		&i.Name,
		&i.BeforeID,
		&i.AfterID,
		&i.Transition,
		&i.Initiator,
		&i.ProvisionerState,
		&i.ProvisionJobID,
	)
	return i, err
}

const insertWorkspaceResource = `-- name: InsertWorkspaceResource :one
INSERT INTO
  workspace_resource (
    id,
    created_at,
    workspace_history_id,
    type,
    name,
    workspace_agent_token
  )
VALUES
  ($1, $2, $3, $4, $5, $6) RETURNING id, created_at, workspace_history_id, type, name, workspace_agent_token, workspace_agent_id
`

type InsertWorkspaceResourceParams struct {
	ID                  uuid.UUID `db:"id" json:"id"`
	CreatedAt           time.Time `db:"created_at" json:"created_at"`
	WorkspaceHistoryID  uuid.UUID `db:"workspace_history_id" json:"workspace_history_id"`
	Type                string    `db:"type" json:"type"`
	Name                string    `db:"name" json:"name"`
	WorkspaceAgentToken string    `db:"workspace_agent_token" json:"workspace_agent_token"`
}

func (q *sqlQuerier) InsertWorkspaceResource(ctx context.Context, arg InsertWorkspaceResourceParams) (WorkspaceResource, error) {
	row := q.db.QueryRowContext(ctx, insertWorkspaceResource,
		arg.ID,
		arg.CreatedAt,
		arg.WorkspaceHistoryID,
		arg.Type,
		arg.Name,
		arg.WorkspaceAgentToken,
	)
	var i WorkspaceResource
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.WorkspaceHistoryID,
		&i.Type,
		&i.Name,
		&i.WorkspaceAgentToken,
		&i.WorkspaceAgentID,
	)
	return i, err
}

const updateAPIKeyByID = `-- name: UpdateAPIKeyByID :exec
UPDATE
  api_keys
SET
  last_used = $2,
  expires_at = $3,
  oidc_access_token = $4,
  oidc_refresh_token = $5,
  oidc_expiry = $6
WHERE
  id = $1
`

type UpdateAPIKeyByIDParams struct {
	ID               string    `db:"id" json:"id"`
	LastUsed         time.Time `db:"last_used" json:"last_used"`
	ExpiresAt        time.Time `db:"expires_at" json:"expires_at"`
	OIDCAccessToken  string    `db:"oidc_access_token" json:"oidc_access_token"`
	OIDCRefreshToken string    `db:"oidc_refresh_token" json:"oidc_refresh_token"`
	OIDCExpiry       time.Time `db:"oidc_expiry" json:"oidc_expiry"`
}

func (q *sqlQuerier) UpdateAPIKeyByID(ctx context.Context, arg UpdateAPIKeyByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateAPIKeyByID,
		arg.ID,
		arg.LastUsed,
		arg.ExpiresAt,
		arg.OIDCAccessToken,
		arg.OIDCRefreshToken,
		arg.OIDCExpiry,
	)
	return err
}

const updateProvisionerDaemonByID = `-- name: UpdateProvisionerDaemonByID :exec
UPDATE
  provisioner_daemon
SET
  updated_at = $2,
  provisioners = $3
WHERE
  id = $1
`

type UpdateProvisionerDaemonByIDParams struct {
	ID           uuid.UUID         `db:"id" json:"id"`
	UpdatedAt    sql.NullTime      `db:"updated_at" json:"updated_at"`
	Provisioners []ProvisionerType `db:"provisioners" json:"provisioners"`
}

func (q *sqlQuerier) UpdateProvisionerDaemonByID(ctx context.Context, arg UpdateProvisionerDaemonByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateProvisionerDaemonByID, arg.ID, arg.UpdatedAt, pq.Array(arg.Provisioners))
	return err
}

const updateProvisionerJobByID = `-- name: UpdateProvisionerJobByID :exec
UPDATE
  provisioner_job
SET
  updated_at = $2
WHERE
  id = $1
`

type UpdateProvisionerJobByIDParams struct {
	ID        uuid.UUID `db:"id" json:"id"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

func (q *sqlQuerier) UpdateProvisionerJobByID(ctx context.Context, arg UpdateProvisionerJobByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateProvisionerJobByID, arg.ID, arg.UpdatedAt)
	return err
}

const updateProvisionerJobWithCompleteByID = `-- name: UpdateProvisionerJobWithCompleteByID :exec
UPDATE
  provisioner_job
SET
  updated_at = $2,
  completed_at = $3,
  cancelled_at = $4,
  error = $5
WHERE
  id = $1
`

type UpdateProvisionerJobWithCompleteByIDParams struct {
	ID          uuid.UUID      `db:"id" json:"id"`
	UpdatedAt   time.Time      `db:"updated_at" json:"updated_at"`
	CompletedAt sql.NullTime   `db:"completed_at" json:"completed_at"`
	CancelledAt sql.NullTime   `db:"cancelled_at" json:"cancelled_at"`
	Error       sql.NullString `db:"error" json:"error"`
}

func (q *sqlQuerier) UpdateProvisionerJobWithCompleteByID(ctx context.Context, arg UpdateProvisionerJobWithCompleteByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateProvisionerJobWithCompleteByID,
		arg.ID,
		arg.UpdatedAt,
		arg.CompletedAt,
		arg.CancelledAt,
		arg.Error,
	)
	return err
}

const updateWorkspaceHistoryByID = `-- name: UpdateWorkspaceHistoryByID :exec
UPDATE
  workspace_history
SET
  updated_at = $2,
  after_id = $3,
  provisioner_state = $4
WHERE
  id = $1
`

type UpdateWorkspaceHistoryByIDParams struct {
	ID               uuid.UUID     `db:"id" json:"id"`
	UpdatedAt        time.Time     `db:"updated_at" json:"updated_at"`
	AfterID          uuid.NullUUID `db:"after_id" json:"after_id"`
	ProvisionerState []byte        `db:"provisioner_state" json:"provisioner_state"`
}

func (q *sqlQuerier) UpdateWorkspaceHistoryByID(ctx context.Context, arg UpdateWorkspaceHistoryByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateWorkspaceHistoryByID,
		arg.ID,
		arg.UpdatedAt,
		arg.AfterID,
		arg.ProvisionerState,
	)
	return err
}
