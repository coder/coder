name: 'Docs Shared Action'
description: 'A composite action providing shared functionality for docs-related workflows'
author: 'Coder'

inputs:
  github-token:
    description: 'GitHub token for API operations'
    required: true
  docs-dir:
    description: 'Path to the docs directory'
    required: false
    default: 'docs'
  include-md-files:
    description: 'Whether to include all markdown files (not just in docs dir)'
    required: false
    default: 'false'
  check-links:
    description: 'Whether to check links in markdown files'
    required: false
    default: 'false'
  lint-markdown:
    description: 'Whether to lint markdown files'
    required: false
    default: 'false'
  check-format:
    description: 'Whether to check (but not format) markdown table formatting'
    required: false
    default: 'false'
  lint-vale:
    description: 'Whether to run Vale style checks on documentation'
    required: false
    default: 'true'
  check-cross-references:
    description: 'Whether to check for broken cross-references when files or headings change'
    required: false
    default: 'true'
  generate-preview:
    description: 'Whether to generate preview links'
    required: false
    default: 'false'
  post-comment:
    description: 'Whether to post a PR comment with results'
    required: false
    default: 'false'
  pr-number:
    description: 'PR number for commenting (required if post-comment is true)'
    required: false
    default: ''
  fail-on-error:
    description: 'Whether to fail the workflow on errors'
    required: false
    default: 'true'

outputs:
  has_changes:
    description: 'Boolean indicating if documentation files have changed'
    value: ${{ steps.process-files.outputs.has_changes }}
  changed_files:
    description: 'JSON array of changed documentation files'
    value: ${{ steps.changed-files.outputs.all_changed_files_json }}
  formatted_changed_files:
    description: 'Markdown-formatted list of changed files with links'
    value: ${{ steps.docs-analysis.outputs.formatted_files || '' }}
  preview_url:
    description: 'Documentation preview URL'
    value: ${{ steps.generate-preview.outputs.url || '' }}
  manifest_changed:
    description: 'Boolean indicating if manifest.json changed'
    value: ${{ steps.manifest-check.outputs.changed || 'false' }}
  has_new_docs:
    description: 'Boolean indicating if new docs were added in manifest.json'
    value: ${{ steps.docs-analysis.outputs.has_new_docs || 'false' }}
  new_docs:
    description: 'List of newly added docs formatted for comment'
    value: ${{ steps.docs-analysis.outputs.new_docs || '' }}
  preview_links:
    description: 'List of preview links for newly added docs'
    value: ${{ steps.docs-analysis.outputs.preview_links || '' }}
  lint_results:
    description: 'Results from linting'
    value: ${{ steps.lint-docs.outputs.result || '' }}
  format_results:
    description: 'Results from format checking'
    value: ${{ steps.format-docs.outputs.result || '' }}
  link_check_results:
    description: 'Results from link checking'
    value: ${{ steps.process-lychee.outputs.result || '' }}
  vale_results:
    description: 'Results from Vale style checks'
    value: ${{ steps.lint-vale.outputs.result || '' }}
  cross_ref_results:
    description: 'Results from cross-reference checking'
    value: ${{ steps.cross-references.outputs.cross_ref_results || '' }}
  # Aggregated validation results
  validation_results:
    description: 'Aggregated validation results as JSON'
    value: ${{ steps.aggregate-results.outputs.results || '[]' }}
  validation_count:
    description: 'Total number of validation checks run'
    value: ${{ steps.aggregate-results.outputs.validation_count || '0' }}
  passing_count:
    description: 'Number of passing validation checks'
    value: ${{ steps.aggregate-results.outputs.passing_count || '0' }}
  success_percentage:
    description: 'Percentage of passing validation checks'
    value: ${{ steps.aggregate-results.outputs.success_percentage || '0' }}
  overall_success:
    description: 'Boolean indicating if all validation checks passed'
    value: ${{ steps.aggregate-results.outputs.success || 'true' }}
  results_badge:
    description: 'A formatted badge string summarizing the validation results'
    value: ${{ steps.aggregate-results.outputs.badge || '✅ No validation run' }}

runs:
  using: 'composite'
  steps:
    # === PHASE 1: SETUP AND ENVIRONMENT VALIDATION ===
    # These are essential security and validation steps that must run first
    
    - name: Set security environment
      id: security-check
      shell: bash
      run: |
        # Secure the environment by clearing potentially harmful variables
        unset HISTFILE
        umask 077
        
        # Validate that docs directory exists
        if [ ! -d "${{ inputs.docs-dir }}" ]; then
          echo "::error::Docs directory '${{ inputs.docs-dir }}' does not exist"
          exit 1
        fi
        
        echo "validated=true" >> $GITHUB_OUTPUT

    # === PHASE 2: FILE ANALYSIS ===
    # These steps collect and process file information for later parallel phases
    
    - name: Get changed files
      id: changed-files
      if: steps.security-check.outputs.validated == 'true'
      uses: tj-actions/changed-files@27ae6b33eaed7bf87272fdeb9f1c54f9facc9d99 # v45.0.7
      with:
        files: |
          ${{ inputs.docs-dir }}/**
          ${{ inputs.include-md-files == 'true' && '**.md' || '' }}
        separator: ','
        json: true
        
    - name: Process file lists
      id: process-files
      if: steps.security-check.outputs.validated == 'true'
      shell: bash
      run: |
        # Set up environment
        CHANGED_FILES='${{ steps.changed-files.outputs.all_changed_files_json || '[]' }}'
        DELETED_FILES='${{ steps.changed-files.outputs.deleted_files_json || '[]' }}'
        
        # Process files into different formats once
        echo "md_files_comma<<EOF" >> $GITHUB_OUTPUT
        echo "${{ steps.changed-files.outputs.all_changed_files || '' }}" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "md_files_line<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGED_FILES" | jq -r '.[] | select(endswith(".md"))' >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "docs_files_line<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGED_FILES" | jq -r '.[] | select(endswith(".md")) | select(startswith("${{ inputs.docs-dir }}/"))' >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "deleted_md_files_line<<EOF" >> $GITHUB_OUTPUT
        echo "$DELETED_FILES" | jq -r '.[] | select(endswith(".md"))' >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Determine if docs have changed
        DOC_COUNT=$(echo "$CHANGED_FILES" | jq '. | length')
        if [ "$DOC_COUNT" -gt 0 ]; then
          echo "has_changes=true" >> $GITHUB_OUTPUT
        else
          echo "has_changes=false" >> $GITHUB_OUTPUT
        fi

    - name: Check if manifest changed
      id: manifest-check
      if: steps.process-files.outputs.has_changes == 'true'
      shell: bash
      run: |
        if [[ "${{ steps.changed-files.outputs.all_changed_files }}" == *"${{ inputs.docs-dir }}/manifest.json"* ]]; then
          echo "changed=true" >> $GITHUB_OUTPUT
        else
          echo "changed=false" >> $GITHUB_OUTPUT
        fi

    # === PHASE 3: CONCURRENT VALIDATION CHECKS ===
    # These steps can run in parallel as they only depend on file analysis
    # and are independent of each other

    - name: Lint Markdown
      if: inputs.lint-markdown == 'true' && steps.process-files.outputs.has_changes == 'true'
      id: lint-docs
      shell: bash
      run: |
        # Use the pre-processed file list
        if [ -z "${{ steps.process-files.outputs.md_files_comma }}" ]; then
          echo "No markdown files to lint"
          exit 0
        fi
        
        lint_output=$(pnpm exec markdownlint-cli2 ${{ steps.process-files.outputs.md_files_comma }} 2>&1) || true
        echo "result<<EOF" >> $GITHUB_OUTPUT
        echo "$lint_output" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        if [ -n "$lint_output" ] && [ "${{ inputs.fail-on-error }}" == "true" ]; then
          echo "::error::Markdown linting found issues:"
          echo "$lint_output"
          exit 1
        fi

    - name: Check Markdown Table Formatting
      if: inputs.check-format == 'true' && steps.process-files.outputs.has_changes == 'true'
      id: format-docs
      shell: bash
      run: |
        # Use the pre-processed file list
        if [ -z "${{ steps.process-files.outputs.md_files_line }}" ]; then
          echo "No markdown files to check formatting"
          exit 0
        fi
        
        # markdown-table-formatter requires a space separated list of files
        format_output=$(echo "${{ steps.process-files.outputs.md_files_line }}" | pnpm exec markdown-table-formatter --check 2>&1) || true
        echo "result<<EOF" >> $GITHUB_OUTPUT
        echo "$format_output" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        if [ -n "$format_output" ] && [ "${{ inputs.fail-on-error }}" == "true" ]; then
          echo "::error::Markdown table formatting issues found. Run 'make fmt/markdown' locally to fix them."
          echo "$format_output"
          exit 1
        fi

    - name: Check Markdown links
      if: inputs.check-links == 'true' && steps.process-files.outputs.has_changes == 'true'
      id: lychee
      uses: lycheeverse/lychee-action@v1
      with:
        args: >-
          --verbose
          --no-progress
          --exclude-mail
          --exclude-loopback
          --exclude-private
          --ignore-file=.github/docs/.lycheeignore
          '${{ steps.process-files.outputs.md_files_line }}'
        format: json
        output: ./lychee-result.json
        fail: false # We'll handle failure in the next step
        
    - name: Process lychee results
      if: inputs.check-links == 'true' && steps.process-files.outputs.has_changes == 'true'
      id: process-lychee
      shell: bash
      run: |
        if [ -f "./lychee-result.json" ]; then
          # Count broken links - lychee format is different from linkspector
          BROKEN_LINKS=$(jq '.data.failed | length' "./lychee-result.json")
          
          if [ "$BROKEN_LINKS" -gt 0 ]; then
            # Format results for output
            LINK_RESULTS="# Broken Links ($BROKEN_LINKS found)\n\n"
            LINK_RESULTS+="| File | Link | Status |\n"
            LINK_RESULTS+="|------|------|--------|\n"
            
            # Process lychee's output format
            LINK_TABLE=$(jq -r '.data.failed[] | "| \(.input_file // "Unknown") | \(.url) | \(.status_code // "Error") |"' "./lychee-result.json")
            LINK_RESULTS+="$LINK_TABLE"
            
            echo "result<<EOF" >> $GITHUB_OUTPUT
            echo -e "$LINK_RESULTS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            if [ "${{ inputs.fail-on-error }}" == "true" ]; then
              echo "::error::Broken links found:"
              echo -e "$LINK_RESULTS"
              exit 1
            fi
          else
            echo "No broken links found"
          fi
        else
          echo "No lychee results file found"
        fi
        
    - name: Run Vale style checks
      if: inputs.lint-vale == 'true' && steps.process-files.outputs.has_changes == 'true'
      id: lint-vale
      shell: bash
      run: |
        # Run Vale on changed markdown files using our pre-processed list
        # First check if we have any markdown files to process
        if [ -z "${{ steps.process-files.outputs.md_files_line }}" ]; then
          echo "No markdown files to check with Vale"
          exit 0
        fi
        
        # Run Vale on changed files and capture output
        # Use xargs with -r to skip execution if no files are provided
        vale_output=$(echo "${{ steps.process-files.outputs.md_files_line }}" | xargs -r vale --config=.github/docs/vale/.vale.ini --output=line 2>&1) || true
        
        echo "result<<EOF" >> $GITHUB_OUTPUT
        echo "$vale_output" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        if [ -n "$vale_output" ] && [ "${{ inputs.fail-on-error }}" == "true" ]; then
          echo "::error::Vale style check found issues:"
          echo "$vale_output"
          exit 1
        fi
        
    - name: Check for broken cross-references
      if: inputs.check-cross-references == 'true' && steps.process-files.outputs.has_changes == 'true'
      id: cross-references
      shell: bash
      run: |
        # Get the base branch (usually main)
        BASE_SHA=$(git merge-base HEAD origin/main)
        
        echo "Checking for broken cross-references..."
        
        # Initialize results
        BROKEN_REFS=""
        
        # Process deleted files
        if [ -n "${{ steps.process-files.outputs.deleted_md_files_line }}" ]; then
          echo "Processing deleted files"
          
          # Loop through deleted markdown files
          while IFS= read -r file; do
            [ -z "$file" ] && continue
            
            echo "File $file was deleted, checking for references..."
            
            # Convert file path to potential link formats (removing .md extension)
            OLD_PATH=$(echo "$file" | sed 's/\.md$//')
            
            # Search in docs directory
            DOC_REFS=$(grep -r --include="*.md" -l -E "\[$OLD_PATH\]|\($OLD_PATH\)" ${{ inputs.docs-dir }} || echo "")
            
            # Search in codebase (excluding specific directories)
            CODE_REFS=$(grep -r --include="*.{go,ts,js,py,java,cs,php}" -l "$OLD_PATH" . --exclude-dir={node_modules,.git,build,dist} || echo "")
            
            if [ -n "$DOC_REFS" ] || [ -n "$CODE_REFS" ]; then
              BROKEN_REFS="${BROKEN_REFS}## References to deleted file: $file\n\n"
              
              if [ -n "$DOC_REFS" ]; then
                BROKEN_REFS="${BROKEN_REFS}### In documentation:\n"
                BROKEN_REFS="${BROKEN_REFS}$(echo "$DOC_REFS" | sed 's/^/- /')\n\n"
              fi
              
              if [ -n "$CODE_REFS" ]; then
                BROKEN_REFS="${BROKEN_REFS}### In codebase:\n"
                BROKEN_REFS="${BROKEN_REFS}$(echo "$CODE_REFS" | sed 's/^/- /')\n\n"
              fi
            fi
          done <<< "${{ steps.process-files.outputs.deleted_md_files_line }}"
        fi
        
        # Process modified files for heading changes
        while IFS= read -r file; do
          [ -z "$file" ] && continue
          
          if [ -f "$file" ]; then
            echo "Checking for changed headings in $file..."
            
            # Extract headings before the change
            OLD_HEADINGS=$(git show "$BASE_SHA:$file" 2>/dev/null | grep -E "^#{1,6} " | sed 's/^#\{1,6\} \(.*\)$/\1/' || echo "")
            
            # Extract current headings
            NEW_HEADINGS=$(cat "$file" | grep -E "^#{1,6} " | sed 's/^#\{1,6\} \(.*\)$/\1/')
            
            # Find removed headings
            REMOVED_HEADINGS=$(comm -23 <(echo "$OLD_HEADINGS" | sort) <(echo "$NEW_HEADINGS" | sort))
            
            if [ -n "$REMOVED_HEADINGS" ]; then
              while IFS= read -r heading; do
                [ -z "$heading" ] && continue
                
                # Convert heading to anchor format (lowercase, spaces to hyphens)
                ANCHOR=$(echo "$heading" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:] -' | tr ' ' '-')
                
                # Search for references to this anchor in documentation
                HEAD_REFS=$(grep -r --include="*.md" -l "#$ANCHOR" ${{ inputs.docs-dir }} || echo "")
                
                if [ -n "$HEAD_REFS" ]; then
                  BROKEN_REFS="${BROKEN_REFS}## References to removed heading: '$heading' in $file\n\n"
                  BROKEN_REFS="${BROKEN_REFS}$(echo "$HEAD_REFS" | sed 's/^/- /')\n\n"
                fi
              done <<< "$REMOVED_HEADINGS"
            fi
          fi
        done <<< "${{ steps.process-files.outputs.docs_files_line }}"
        
        # Check for renamed files by comparing paths
        while IFS= read -r file; do
          [ -z "$file" ] && continue
          
          # Use git to check if this is a renamed file
          PREV_PATH=$(git diff --name-status "$BASE_SHA" | grep "^R" | grep "$file$" | cut -f2)
          
          if [ -n "$PREV_PATH" ] && [ "$PREV_PATH" != "$file" ]; then
            echo "File renamed from $PREV_PATH to $file, checking for references..."
            
            # Convert old file path to potential link formats
            OLD_PATH=$(echo "$PREV_PATH" | sed 's/\.md$//')
            
            # Search in docs directory
            DOC_REFS=$(grep -r --include="*.md" -l -E "\[$OLD_PATH\]|\($OLD_PATH\)" ${{ inputs.docs-dir }} || echo "")
            
            # Search in codebase (excluding specific directories)
            CODE_REFS=$(grep -r --include="*.{go,ts,js,py,java,cs,php}" -l "$OLD_PATH" . --exclude-dir={node_modules,.git,build,dist} || echo "")
            
            if [ -n "$DOC_REFS" ] || [ -n "$CODE_REFS" ]; then
              BROKEN_REFS="${BROKEN_REFS}## References to renamed file: $PREV_PATH → $file\n\n"
              
              if [ -n "$DOC_REFS" ]; then
                BROKEN_REFS="${BROKEN_REFS}### In documentation:\n"
                BROKEN_REFS="${BROKEN_REFS}$(echo "$DOC_REFS" | sed 's/^/- /')\n\n"
              fi
              
              if [ -n "$CODE_REFS" ]; then
                BROKEN_REFS="${BROKEN_REFS}### In codebase:\n"
                BROKEN_REFS="${BROKEN_REFS}$(echo "$CODE_REFS" | sed 's/^/- /')\n\n"
              fi
            fi
          fi
        done <<< "${{ steps.process-files.outputs.md_files_line }}"
        
        if [ -n "$BROKEN_REFS" ]; then
          echo "cross_ref_results<<EOF" >> $GITHUB_OUTPUT
          echo -e "$BROKEN_REFS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          if [ "${{ inputs.fail-on-error }}" == "true" ]; then
            echo "::error::Broken cross-references found. See output for details."
            exit 1
          fi
        else
          echo "No broken cross-references found"
        fi

    # === PHASE 4: PREVIEW GENERATION ===
    # Runs concurrently with validation checks

    - name: Generate Preview URL
      if: inputs.generate-preview == 'true' && steps.process-files.outputs.has_changes == 'true'
      id: generate-preview
      shell: bash
      run: |
        # Get PR branch name for URL
        BRANCH_NAME=$(jq --raw-output .pull_request.head.ref "$GITHUB_EVENT_PATH")
        
        # Input validation - ensure branch name is valid
        if [ -z "$BRANCH_NAME" ]; then
          echo "::warning::Could not determine branch name, using 'main'"
          BRANCH_NAME="main"
        fi
        
        # Create the correct preview URL
        PREVIEW_URL="https://coder.com/docs/@$BRANCH_NAME"
        echo "url=$PREVIEW_URL" >> $GITHUB_OUTPUT

    # === PHASE 4B: ANALYZE DOCS FOR PR COMMENT ===
    # Run concurrently with validation checks as part of preview generation
    
    - name: Analyze docs changes
      id: docs-analysis
      if: (inputs.generate-preview == 'true' || inputs.post-comment == 'true') && steps.process-files.outputs.has_changes == 'true'
      shell: bash
      run: |
        # Set up environment
        CHANGED_FILES='${{ steps.changed-files.outputs.all_changed_files_json }}'
        
        # Get branch name for URLs
        BRANCH_NAME=$(jq --raw-output .pull_request.head.ref "$GITHUB_EVENT_PATH" || echo "main")
        
        # Format changed files for comment with clickable links
        FORMATTED_FILES=""
        echo $CHANGED_FILES | jq -c '.[]' | while read -r file_path; do
          # Remove quotes
          file_path=$(echo $file_path | tr -d '"')
          [ -z "$file_path" ] && continue
          
          # Only process docs files
          if [[ $file_path == ${{ inputs.docs-dir }}/* ]]; then
            # Create direct link to file
            # Remove .md extension and docs/ prefix for the URL path
            url_path=$(echo "$file_path" | sed 's/^${{ inputs.docs-dir }}\///' | sed 's/\.md$//')
            file_url="https://coder.com/docs/@${BRANCH_NAME}/${url_path}"
            
            # Add the formatted line with link
            FORMATTED_FILES="${FORMATTED_FILES}- [$file_path]($file_url)\n"
          fi
        done
        
        echo "formatted_files<<EOF" >> $GITHUB_OUTPUT
        echo -e "$FORMATTED_FILES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Analyze manifest changes if needed
        if [ "${{ steps.manifest-check.outputs.changed }}" == "true" ]; then
          # Get the base SHA for diff
          BASE_SHA=$(git merge-base HEAD origin/main)
          
          # Extract new docs from manifest.json diff with safe patterns
          NEW_DOCS=$(git diff "$BASE_SHA"..HEAD -- "${{ inputs.docs-dir }}/manifest.json" | grep -E '^\+.*"path":' | sed -E 's/.*"path": *"(.*)".*/\1/g')
          
          if [ -n "$NEW_DOCS" ]; then
            echo "has_new_docs=true" >> $GITHUB_OUTPUT
            
            # Format new docs for comment
            FORMATTED_NEW_DOCS=$(echo "$NEW_DOCS" | sort | uniq | grep -v "^$" | sed 's/^/- `/g' | sed 's/$/`/g')
            echo "new_docs<<EOF" >> $GITHUB_OUTPUT
            echo "$FORMATTED_NEW_DOCS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            # Generate preview links for new docs
            PREVIEW_LINKS=""
            while IFS= read -r doc_path; do
              # Skip empty lines
              [ -z "$doc_path" ] && continue
              
              # Clean the path and sanitize
              clean_path=${doc_path#./}
              clean_path=$(echo "$clean_path" | tr -cd 'a-zA-Z0-9_./-')
              
              # Generate preview URL with correct format
              url_path=$(echo "$clean_path" | sed 's/\.md$//')
              preview_url="https://coder.com/docs/@${BRANCH_NAME}/${url_path}"
              
              # Extract doc title or use filename safely
              if [ -f "$doc_path" ]; then
                title=$(grep -m 1 "^# " "$doc_path" | sed 's/^# //')
                title=$(echo "$title" | tr -cd 'a-zA-Z0-9 _.,-')
                [ -z "$title" ] && title=$(basename "$doc_path" .md | tr -cd 'a-zA-Z0-9_.-')
              else
                title=$(basename "$doc_path" .md | tr -cd 'a-zA-Z0-9_.-')
              fi
              
              PREVIEW_LINKS="${PREVIEW_LINKS}- [$title]($preview_url)\n"
            done <<< "$NEW_DOCS"
            
            echo "preview_links<<EOF" >> $GITHUB_OUTPUT
            echo -e "$PREVIEW_LINKS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "has_new_docs=false" >> $GITHUB_OUTPUT
          fi
        fi

    # === PHASE 5: AGGREGATION OF RESULTS ===
    # This step collects all validation results and creates a unified report
    # It runs after (and depends on) all validation steps

    - name: Aggregate validation results
      id: aggregate-results
      if: steps.process-files.outputs.has_changes == 'true'
      shell: bash
      run: |
        # Initialize validation status array
        echo "initializing validation status aggregation"
        
        # Track overall success/failure
        OVERALL_SUCCESS="true"
        VALIDATION_COUNT=0
        PASSING_COUNT=0
        
        # Create a JSON array to store validation results
        VALIDATION_RESULTS="["
        
        # Helper to add an item to the results array
        add_result() {
          local NAME="$1"
          local STATUS="$2"
          local OUTPUT="$3"
          local GUIDANCE="$4"
          local FIX_COMMAND="$5"
          
          if [ -n "$OUTPUT" ]; then
            STATUS="failure"
            OVERALL_SUCCESS="false"
          else
            STATUS="success"
            PASSING_COUNT=$((PASSING_COUNT + 1))
          fi
          
          VALIDATION_COUNT=$((VALIDATION_COUNT + 1))
          
          # Add comma if not the first item
          if [ "$VALIDATION_COUNT" -gt 1 ]; then
            VALIDATION_RESULTS="${VALIDATION_RESULTS},"
          fi
          
          # Add the validation result
          VALIDATION_RESULTS="${VALIDATION_RESULTS}{\"name\":\"$NAME\",\"status\":\"$STATUS\",\"output\":\"${OUTPUT//\"/\\\"}\",\"guidance\":\"$GUIDANCE\",\"fix_command\":\"$FIX_COMMAND\"}"
        }
        
        # Process markdown linting results
        if [ "${{ inputs.lint-markdown }}" == "true" ]; then
          add_result "markdown-lint" \
            "${{ steps.lint-docs.outputs.result == '' && 'success' || 'failure' }}" \
            "${{ steps.lint-docs.outputs.result }}" \
            "Run these commands locally to fix or see detailed issues" \
            "npm run lint-docs && npm run lint-docs -- --fix"
        fi
        
        # Process table formatting results
        if [ "${{ inputs.check-format }}" == "true" ]; then
          add_result "table-format" \
            "${{ steps.format-docs.outputs.result == '' && 'success' || 'failure' }}" \
            "${{ steps.format-docs.outputs.result }}" \
            "Run this command locally to automatically fix all table formatting issues" \
            "make fmt/markdown"
        fi
        
        # Process Vale style results
        if [ "${{ inputs.lint-vale }}" == "true" ]; then
          add_result "vale-style" \
            "${{ steps.lint-vale.outputs.result == '' && 'success' || 'failure' }}" \
            "${{ steps.lint-vale.outputs.result }}" \
            "These style issues help maintain consistent documentation quality" \
            "vale --config=.github/docs/vale/.vale.ini <file>"
        fi
        
        # Process cross-reference results
        if [ "${{ inputs.check-cross-references }}" == "true" ]; then
          add_result "cross-references" \
            "${{ steps.cross-references.outputs.cross_ref_results == '' && 'success' || 'failure' }}" \
            "${{ steps.cross-references.outputs.cross_ref_results }}" \
            "Update links to reference new locations or remove references to deleted content" \
            ""
        fi
        
        # Process link checking results
        if [ "${{ inputs.check-links }}" == "true" ]; then
          add_result "links" \
            "${{ steps.check-links.outputs.result == '' && 'success' || 'failure' }}" \
            "${{ steps.check-links.outputs.result }}" \
            "Fix or update broken links" \
            ""
        fi
        
        # Close the JSON array
        VALIDATION_RESULTS="${VALIDATION_RESULTS}]"
        
        # Generate summary metrics
        echo "validation_count=$VALIDATION_COUNT" >> $GITHUB_OUTPUT
        echo "passing_count=$PASSING_COUNT" >> $GITHUB_OUTPUT
        echo "success=$OVERALL_SUCCESS" >> $GITHUB_OUTPUT
        
        # Calculate success percentage
        if [ "$VALIDATION_COUNT" -gt 0 ]; then
          SUCCESS_PERCENTAGE=$(( PASSING_COUNT * 100 / VALIDATION_COUNT ))
        else
          SUCCESS_PERCENTAGE=100
        fi
        echo "success_percentage=$SUCCESS_PERCENTAGE" >> $GITHUB_OUTPUT
        
        # Store the validation results as JSON
        echo "results<<EOF" >> $GITHUB_OUTPUT
        echo "$VALIDATION_RESULTS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Create a badge based on results
        if [ "$OVERALL_SUCCESS" == "true" ]; then
          BADGE="✅ All $PASSING_COUNT validation checks passed (100%)"
        else
          BADGE="⚠️ $PASSING_COUNT of $VALIDATION_COUNT validation checks passed ($SUCCESS_PERCENTAGE%)"
        fi
        echo "badge=$BADGE" >> $GITHUB_OUTPUT

# === PHASE 6: PR COMMENT MANAGEMENT ===
    # This runs after all the validation checks are complete

    - name: Find existing comment
      if: inputs.post-comment == 'true' && steps.process-files.outputs.has_changes == 'true' && inputs.pr-number != ''
      id: find-comment
      uses: peter-evans/find-comment@3eae4d37986fb5a8592848f6a574fdf654e61f9e # v3.1.0
      with:
        issue-number: ${{ inputs.pr-number }}
        comment-author: 'github-actions[bot]'
        body-includes: '## 📚 Docs Preview'
        direction: last

    - name: Create or update preview comment
      if: inputs.post-comment == 'true' && steps.process-files.outputs.has_changes == 'true' && inputs.pr-number != ''
      uses: peter-evans/create-or-update-comment@71345be0265236311c031f5c7866368bd1eff043 # v4.0.0
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      with:
        comment-id: ${{ steps.find-comment.outputs.comment-id }}
        issue-number: ${{ inputs.pr-number }}
        body: |
          # 📚 Documentation Check Results

          ## 🔎 Status Overview

          ${{ steps.aggregate-results.outputs.badge }}

          ${{ steps.lint-docs.outputs.result == '' && '✅ **Markdown Linting**: No issues found' || '❌ **Markdown Linting**: Issues found' }}
          ${{ steps.format-docs.outputs.result == '' && '✅ **Table Formatting**: No issues found' || '❌ **Table Formatting**: Issues found' }}
          ${{ steps.lint-vale.outputs.result == '' && '✅ **Vale Style**: No issues found' || '❌ **Vale Style**: Issues found' }}
          ${{ steps.cross-references.outputs.cross_ref_results == '' && '✅ **Cross-References**: No broken references' || '❌ **Cross-References**: Broken references found' }}
          ${{ steps.check-links.outputs.result == '' && '✅ **Links**: All links are valid' || '⚠️ **Links**: Issues found' }}

          ## 🖥️ Preview Your Changes

          ${{ steps.generate-preview.outputs.url != '' && '**🔗 [View Documentation Preview](' || '' }}${{ steps.generate-preview.outputs.url }}${{ steps.generate-preview.outputs.url != '' && ')**' || 'No preview available' }}

          <details>
          <summary><strong>📄 Changed Documentation Files</strong></summary>

          ${{ steps.docs-analysis.outputs.formatted_files || 'No documentation files changed' }}
          </details>

          ${{ steps.docs-analysis.outputs.has_new_docs == 'true' && '<details>' || '' }}
          ${{ steps.docs-analysis.outputs.has_new_docs == 'true' && '<summary><strong>🆕 Newly Added Documentation</strong></summary>' || '' }}
          ${{ steps.docs-analysis.outputs.has_new_docs == 'true' && steps.docs-analysis.outputs.new_docs || '' }}

          ${{ steps.docs-analysis.outputs.has_new_docs == 'true' && '### Preview Links' || '' }}
          ${{ steps.docs-analysis.outputs.has_new_docs == 'true' && steps.docs-analysis.outputs.preview_links || '' }}
          ${{ steps.docs-analysis.outputs.has_new_docs == 'true' && '</details>' || '' }}

          ${{ steps.lint-docs.outputs.result != '' && '<details>' || '' }}
          ${{ steps.lint-docs.outputs.result != '' && '<summary><strong>⚠️ Markdown Linting Issues</strong></summary>' || '' }}
          ${{ steps.lint-docs.outputs.result != '' && '
          ### How to Fix
          
          Run these commands locally to fix or see detailed issues:
          ```bash
          # To view issues
          npm run lint-docs
          
          # Many issues can be fixed automatically with
          npm run lint-docs -- --fix
          ```
          
          ### Issue Details
          ```
          ' || '' }}
          ${{ steps.lint-docs.outputs.result != '' && steps.lint-docs.outputs.result || '' }}
          ${{ steps.lint-docs.outputs.result != '' && '```
          </details>' || '' }}

          ${{ steps.format-docs.outputs.result != '' && '<details>' || '' }}
          ${{ steps.format-docs.outputs.result != '' && '<summary><strong>📏 Markdown Table Formatting Issues</strong></summary>' || '' }}
          ${{ steps.format-docs.outputs.result != '' && '
          ### How to Fix
          
          Run this command locally to automatically fix all table formatting issues:
          ```bash
          make fmt/markdown
          ```
          
          ### Issue Details
          ```
          ' || '' }}
          ${{ steps.format-docs.outputs.result != '' && steps.format-docs.outputs.result || '' }}
          ${{ steps.format-docs.outputs.result != '' && '```
          </details>' || '' }}

          ${{ steps.lint-vale.outputs.result != '' && '<details>' || '' }}
          ${{ steps.lint-vale.outputs.result != '' && '<summary><strong>📝 Vale Style Issues</strong></summary>' || '' }}
          ${{ steps.lint-vale.outputs.result != '' && '
          ### How to Fix
          
          These style issues help maintain consistent documentation quality. Most Vale suggestions improve:
          
          - Readability (sentence length, passive voice)
          - Consistency (terminology, capitalization)
          - Clarity (avoiding jargon, ambiguous wording)
          - Inclusivity (avoiding gendered or ableist language)
          
          ### Issue Details
          ```
          ' || '' }}
          ${{ steps.lint-vale.outputs.result != '' && steps.lint-vale.outputs.result || '' }}
          ${{ steps.lint-vale.outputs.result != '' && '```
          </details>' || '' }}

          ${{ steps.cross-references.outputs.cross_ref_results != '' && '<details>' || '' }}
          ${{ steps.cross-references.outputs.cross_ref_results != '' && '<summary><strong>🔗 Broken Cross-References</strong></summary>' || '' }}
          ${{ steps.cross-references.outputs.cross_ref_results != '' && '
          ### How to Fix
          
          The following changes in your PR may have broken existing references:
          
          - For **deleted files**: Update or remove references to these files
          - For **renamed files**: Update links to use the new file path
          - For **removed headings**: Update or remove references to these headings
          
          ### Detected Issues
          ' || '' }}
          ${{ steps.cross-references.outputs.cross_ref_results != '' && steps.cross-references.outputs.cross_ref_results || '' }}
          ${{ steps.cross-references.outputs.cross_ref_results != '' && '</details>' || '' }}

          ---
          <sub>🤖 This comment is automatically generated and updated when documentation changes. [View Workflow](https://github.com/coder/coder/blob/main/.github/docs/README.md)</sub>
        edit-mode: replace
        reactions: eyes
        reactions-edit-mode: replace