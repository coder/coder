# This workflow checks if a PR requires documentation updates.
# It creates a Coder Task that uses AI to analyze the PR changes,
# search existing docs, and comment with recommendations.
#
# Triggered by: PR opened, PR updated (new commits), or manual dispatch.

name: AI Documentation Check

on:
  pull_request:
    types:
      - opened       # New PR - full analysis
      - synchronize  # PR updated with new commits - brief update
  workflow_dispatch:
    inputs:
      pr_url:
        description: "Pull Request URL to check"
        required: true
        type: string
      template_preset:
        description: "Template preset to use"
        required: false
        default: ""
        type: string

jobs:
  doc-check:
    name: Analyze PR for Documentation Updates Needed
    runs-on: ubuntu-latest
    if: |
      github.event.pull_request.draft == false || github.event_name == 'workflow_dispatch'
    timeout-minutes: 30
    env:
      CODER_URL: ${{ secrets.DOC_CHECK_CODER_URL }}
      CODER_SESSION_TOKEN: ${{ secrets.DOC_CHECK_CODER_SESSION_TOKEN }}
    permissions:
      contents: read
      pull-requests: write
      actions: write

    steps:
      - name: Install Coder CLI
        run: |
          curl -fsSL "${{ secrets.DOC_CHECK_CODER_URL }}/install.sh" | sh
          coder version

      - name: Authenticate Coder CLI
        run: |
          coder login --token "${{ secrets.DOC_CHECK_CODER_SESSION_TOKEN }}" "${{ secrets.DOC_CHECK_CODER_URL }}"

      - name: Determine PR Context
        id: determine-context
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_EVENT_ACTION: ${{ github.event.action }}
          GITHUB_EVENT_PR_HTML_URL: ${{ github.event.pull_request.html_url }}
          GITHUB_EVENT_PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_EVENT_SENDER_ID: ${{ github.event.sender.id }}
          GITHUB_EVENT_SENDER_LOGIN: ${{ github.event.sender.login }}
          INPUTS_PR_URL: ${{ inputs.pr_url }}
          INPUTS_TEMPLATE_PRESET: ${{ inputs.template_preset || '' }}
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Using template preset: ${INPUTS_TEMPLATE_PRESET}"
          echo "template_preset=${INPUTS_TEMPLATE_PRESET}" >> "${GITHUB_OUTPUT}"

          # First, determine PR context based on event type
          if [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
            if ! GITHUB_USER_ID=$(gh api "users/${GITHUB_ACTOR}" --jq '.id'); then
              echo "::error::Failed to get GitHub user ID for actor ${GITHUB_ACTOR}"
              exit 1
            fi
            echo "Using workflow_dispatch actor: ${GITHUB_ACTOR} (ID: ${GITHUB_USER_ID})"
            echo "github_user_id=${GITHUB_USER_ID}" >> "${GITHUB_OUTPUT}"
            echo "github_username=${GITHUB_ACTOR}" >> "${GITHUB_OUTPUT}"

            echo "Using PR URL: ${INPUTS_PR_URL}"
            ISSUE_URL="${INPUTS_PR_URL/\/pull\//\/issues\/}"
            echo "pr_url=${ISSUE_URL}" >> "${GITHUB_OUTPUT}"

            PR_NUMBER=$(echo "${INPUTS_PR_URL}" | grep -oP '(?<=pull/)\d+')
            echo "pr_number=${PR_NUMBER}" >> "${GITHUB_OUTPUT}"

          elif [[ "${GITHUB_EVENT_NAME}" == "pull_request" ]]; then
            GITHUB_USER_ID=${GITHUB_EVENT_SENDER_ID}
            echo "Using PR sender: ${GITHUB_EVENT_SENDER_LOGIN} (ID: ${GITHUB_USER_ID})"
            echo "github_user_id=${GITHUB_USER_ID}" >> "${GITHUB_OUTPUT}"
            echo "github_username=${GITHUB_EVENT_SENDER_LOGIN}" >> "${GITHUB_OUTPUT}"

            echo "Using PR URL: ${GITHUB_EVENT_PR_HTML_URL}"
            ISSUE_URL="${GITHUB_EVENT_PR_HTML_URL/\/pull\//\/issues\/}"
            echo "pr_url=${ISSUE_URL}" >> "${GITHUB_OUTPUT}"

            PR_NUMBER="${GITHUB_EVENT_PR_NUMBER}"
            echo "pr_number=${PR_NUMBER}" >> "${GITHUB_OUTPUT}"

          else
            echo "::error::Unsupported event type: ${GITHUB_EVENT_NAME}"
            exit 1
          fi

          # Check if bot has already analyzed this PR by looking for our marker comment
          # This determines whether to use full analysis or brief update prompt
          echo "Checking for existing doc-check analysis on PR #${PR_NUMBER}..."

          EXISTING_ANALYSIS=$(gh api "repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
            --jq '.[] | select(.body | contains("<!-- doc-check-analysis -->")) | .id' | head -1 || echo "")

          if [[ -n "${EXISTING_ANALYSIS}" ]]; then
            echo "Found existing analysis (comment ID: ${EXISTING_ANALYSIS})"
            echo "Will use UPDATE prompt (brief)"
            echo "is_new_pr=false" >> "${GITHUB_OUTPUT}"
          else
            echo "No existing analysis found"
            echo "Will use NEW PR prompt (full analysis)"
            echo "is_new_pr=true" >> "${GITHUB_OUTPUT}"
          fi

          echo "trigger_type=${GITHUB_EVENT_ACTION:-manual}" >> "${GITHUB_OUTPUT}"

      - name: Extract changed files and build prompt
        id: extract-context
        env:
          PR_URL: ${{ steps.determine-context.outputs.pr_url }}
          PR_NUMBER: ${{ steps.determine-context.outputs.pr_number }}
          TRIGGER_TYPE: ${{ steps.determine-context.outputs.trigger_type }}
          IS_NEW_PR: ${{ steps.determine-context.outputs.is_new_pr }}
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Analyzing PR #${PR_NUMBER} (trigger: ${TRIGGER_TYPE}, is_new: ${IS_NEW_PR})"

          # Common setup instructions (unquoted heredoc so PR_NUMBER expands)
          SETUP_INSTRUCTIONS=$(cat <<SETUPEOF
          SETUP (repo is pre-cloned at ~/coder):
            cd ~/coder
            git fetch origin pull/${PR_NUMBER}/head:pr-${PR_NUMBER}
            git checkout pr-${PR_NUMBER}
          SETUPEOF
          )

          # Full analysis comment format (for new PRs)
          COMMENT_FORMAT=$(cat <<'COMMENTEOF'
          FULL ANALYSIS COMMENT FORMAT (for new PRs):
          <!-- doc-check-analysis -->
          ## Documentation Check

          **Analyzed:** [current date/time]

          ### Updates Needed
          - **[docs/path/file.md](github_link)** - Brief what needs changing

          ### New Docs Needed
          - **docs/suggested/location.md** - What should be documented

          ### No Changes Needed
          [Reason: Documents already updated in PR | Internal changes only | Test-only | No user-facing impact]

          ---
          *Analysis by [Coder Tasks](https://coder.com/docs/ai-coder/tasks) - Updates will appear as new comments*
          COMMENTEOF
          )

          # Build different prompts based on trigger type
          if [[ "${IS_NEW_PR}" == "true" ]]; then
            echo "Building NEW PR prompt (full analysis)"

            TASK_PROMPT=$(cat <<EOF
          ═══════════════════════════════════════════════════════════════════
          NEW PR DOCUMENTATION CHECK - Full Analysis Required
          ═══════════════════════════════════════════════════════════════════

          Review PR #${PR_NUMBER} and determine if documentation needs updating or creating.
          This is a NEW PR - perform a complete analysis from scratch.

          PR URL: ${PR_URL}

          ${SETUP_INSTRUCTIONS}

          WORKFLOW:
            1. Get PR info
               Use GitHub MCP tools to get PR title, body, and diff
               Or use: git diff main...pr-${PR_NUMBER}

            2. Understand ALL Changes
               Read the entire diff and identify what changed
               Ask: Is this user-facing? Does it change behavior? Is it a new feature?

            3. Search for Related Docs
               cat ~/coder/docs/manifest.json | jq '.routes[] | {title, path}' | head -50
               grep -ri "relevant_term" ~/coder/docs/ --include="*.md"

            4. Decide
               NEEDS DOCS if: New feature, API change, CLI change, behavior change, user-visible
               NO DOCS if: Internal refactor, test-only, already documented, non-user-facing, dependency updates
               FIRST check: Did this PR already update docs? If yes and complete, say "No Changes Needed"

            5. Comment on the PR
               - This is a new PR, so CREATE a new comment with the marker
               - Use the format below
               - Keep headings clean (no emojis in headings)
               - Use status indicators sparingly (✓ ⚠ ✗)

          ${COMMENT_FORMAT}

          DOCS STRUCTURE:
            Read ~/coder/docs/manifest.json for the complete documentation structure.
            Common areas include: reference/, admin/, user-guides/, ai-coder/, install/, tutorials/

          EOF
          )

          else
            echo "Building PR UPDATE prompt (incremental analysis)"

            TASK_PROMPT=$(cat <<EOF
          ═══════════════════════════════════════════════════════════════════
          PR UPDATE - Quick Documentation Re-check
          ═══════════════════════════════════════════════════════════════════

          PR #${PR_NUMBER} has been UPDATED with new commits (trigger: ${TRIGGER_TYPE}).

          PR URL: ${PR_URL}

          ${SETUP_INSTRUCTIONS}

          IMPORTANT CONTEXT:
            - This PR was previously analyzed (there may be an earlier doc-check comment)
            - New commits have been pushed since then
            - Your job is to provide a BRIEF update, not repeat the full analysis

          WORKFLOW:
            1. Check recent commits
               git log --oneline -5
               See what was added/changed recently

            2. Quick assessment
               - Do the new changes affect documentation needs?
               - Were docs added/updated in the new commits?
               - Is this a significant change or minor fix?

            3. Post a SHORT update comment
               - DO NOT update or edit previous comments
               - Create a NEW, BRIEF comment (see format below)
               - Keep it conversational and minimal
               - Only do a full re-analysis if changes are substantial

          UPDATE COMMENT FORMAT (keep it SHORT!):
          <!-- doc-check-update -->
          ### Doc Check Update

          **Commits reviewed:** [X new commits]

          [Pick ONE status line based on situation:]

          ✓ **No changes needed** - [brief reason: minor fix / internal change / etc.]

          ✓ **Docs updated** - [what was added/changed in docs]

          ⚠ **Still needs docs** - [brief reminder of what's outstanding]

          ⚠ **Updated but requesting changes** - [acknowledge changes but note what's still missing]

          ✗ **New issues found** - [if new commits introduce new doc requirements]

          ---
          *[Coder Tasks](https://coder.com/docs/ai-coder/tasks)*

          GUIDELINES:
            - Be concise! 2-4 lines is ideal
            - Don't repeat previous analysis
            - Focus only on what CHANGED
            - Use emojis sparingly (only ✓ ⚠ ✗ for status)
            - No emojis in headings
            - If nothing documentation-relevant changed, just say so briefly
            - Only do full analysis if the PR direction changed significantly

          EOF
          )
          fi

          # Output the prompt
          {
            echo "task_prompt<<EOFOUTPUT"
            echo "${TASK_PROMPT}"
            echo "EOFOUTPUT"
          } >> "${GITHUB_OUTPUT}"

      - name: Checkout create-task-action
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 1
          path: ./.github/actions/create-task-action
          persist-credentials: false
          ref: main
          repository: coder/create-task-action

      - name: Create Coder Task for Documentation Check
        id: create_task
        uses: ./.github/actions/create-task-action
        with:
          coder-url: ${{ secrets.DOC_CHECK_CODER_URL }}
          coder-token: ${{ secrets.DOC_CHECK_CODER_SESSION_TOKEN }}
          coder-organization: "default"
          coder-template-name: coder
          coder-template-preset: ${{ steps.determine-context.outputs.template_preset }}
          coder-task-name-prefix: doc-check
          coder-task-prompt: ${{ steps.extract-context.outputs.task_prompt }}
          github-user-id: ${{ steps.determine-context.outputs.github_user_id }}
          github-token: ${{ github.token }}
          github-issue-url: ${{ steps.determine-context.outputs.pr_url }}
          comment-on-issue: true

      - name: Write Task Info to Summary
        env:
          TASK_CREATED: ${{ steps.create_task.outputs.task-created }}
          TASK_NAME: ${{ steps.create_task.outputs.task-name }}
          TASK_URL: ${{ steps.create_task.outputs.task-url }}
          PR_URL: ${{ steps.determine-context.outputs.pr_url }}
        run: |
          {
            echo "## Documentation Check Task"
            echo ""
            echo "**PR:** ${PR_URL}"
            echo "**Task created:** ${TASK_CREATED}"
            echo "**Task name:** ${TASK_NAME}"
            echo "**Task URL:** ${TASK_URL}"
            echo ""
            echo "Streaming task output below..."
          } >> "${GITHUB_STEP_SUMMARY}"

      - name: Stream Task Output
        id: stream_task
        env:
          TASK_NAME: ${{ steps.create_task.outputs.task-name }}
        run: |
          echo "::group::Waiting for task workspace to be ready..."

          # Wait for workspace to be running and agent to be ready
          MAX_WAIT=300  # 5 minutes max wait for workspace
          WAITED=0
          while [[ $WAITED -lt $MAX_WAIT ]]; do
            STATUS=$(coder exp task status "${TASK_NAME}" --output json 2>/dev/null || echo '{}')
            WORKSPACE_STATUS=$(echo "$STATUS" | jq -r '.workspace_status // "unknown"')
            AGENT_LIFECYCLE=$(echo "$STATUS" | jq -r '.workspace_agent_lifecycle // "unknown"')

            echo "Workspace: ${WORKSPACE_STATUS}, Agent: ${AGENT_LIFECYCLE}"

            if [[ "$WORKSPACE_STATUS" == "running" && "$AGENT_LIFECYCLE" == "ready" ]]; then
              echo "Workspace and agent are ready!"
              break
            fi

            if [[ "$WORKSPACE_STATUS" == "failed" || "$WORKSPACE_STATUS" == "canceled" ]]; then
              echo "::error::Workspace failed to start: ${WORKSPACE_STATUS}"
              exit 1
            fi

            sleep 5
            WAITED=$((WAITED + 5))
          done

          if [[ $WAITED -ge $MAX_WAIT ]]; then
            echo "::error::Timeout waiting for workspace to be ready"
            exit 1
          fi
          echo "::endgroup::"

          echo "::group::Streaming AI task output..."
          echo "╔════════════════════════════════════════════════════════════════╗"
          echo "║  Task: ${TASK_NAME}"
          echo "║  Streaming AgentAPI events from http://localhost:3284/events"
          echo "╚════════════════════════════════════════════════════════════════╝"
          echo ""

          # Stream events from AgentAPI via SSH
          # The AgentAPI sends Server-Sent Events (SSE) with:
          #   - event: message_update (new message content)
          #   - event: status_change (status transitions)
          #   - data: JSON payload
          CURRENT_STATUS="running"
          coder ssh "${TASK_NAME}" -- timeout 600 curl -sN http://localhost:3284/events 2>/dev/null | \
            while IFS= read -r line; do
              # Skip empty lines and comments
              [[ -z "$line" || "$line" == :* ]] && continue

              # Track event type
              if [[ "$line" == event:* ]]; then
                EVENT_TYPE="${line#event:}"
                EVENT_TYPE="${EVENT_TYPE// /}"  # trim whitespace
                continue
              fi

              # Parse data payload
              if [[ "$line" == data:* ]]; then
                DATA="${line#data:}"
                DATA="${DATA# }"  # trim leading space

                case "$EVENT_TYPE" in
                  message_update)
                    # Extract and display message content
                    # Try different JSON structures the API might use
                    CONTENT=$(echo "$DATA" | jq -r '
                      .content //
                      .message.content //
                      .message //
                      .text //
                      empty
                    ' 2>/dev/null)

                    if [[ -n "$CONTENT" && "$CONTENT" != "null" ]]; then
                      ROLE=$(echo "$DATA" | jq -r '.role // .message.role // "assistant"' 2>/dev/null)
                      if [[ "$ROLE" == "assistant" ]]; then
                        echo "$CONTENT"
                      elif [[ "$ROLE" == "user" ]]; then
                        echo "[User]: $CONTENT"
                      fi
                    fi
                    ;;

                  status_change)
                    NEW_STATUS=$(echo "$DATA" | jq -r '.status // empty' 2>/dev/null)
                    if [[ -n "$NEW_STATUS" && "$NEW_STATUS" != "$CURRENT_STATUS" ]]; then
                      echo ""
                      echo "── Status: ${NEW_STATUS} ──"
                      CURRENT_STATUS="$NEW_STATUS"

                      if [[ "$NEW_STATUS" == "stable" ]]; then
                        echo ""
                        echo "╔════════════════════════════════════════════════════════════════╗"
                        echo "║  Task completed successfully"
                        echo "╚════════════════════════════════════════════════════════════════╝"
                        break
                      fi
                    fi
                    ;;
                esac

                # Reset event type for next event
                EVENT_TYPE=""
              fi
            done || true  # Don't fail if stream ends unexpectedly

          echo ""
          echo "Stream ended."
          echo "::endgroup::"

      - name: Cleanup Task and Workspace
        if: always()
        env:
          TASK_NAME: ${{ steps.create_task.outputs.task-name }}
        run: |
          echo "::group::Cleaning up task and workspace..."

          if [[ -n "${TASK_NAME}" ]]; then
            echo "Deleting task: ${TASK_NAME}"
            coder exp task delete --yes "${TASK_NAME}" 2>&1 || echo "Task deletion failed or already deleted"
            echo "Cleanup complete"
          else
            echo "No task name found, skipping cleanup"
          fi

          echo "::endgroup::"

      - name: Write Final Summary
        if: always()
        env:
          TASK_NAME: ${{ steps.create_task.outputs.task-name }}
          TASK_URL: ${{ steps.create_task.outputs.task-url }}
          PR_NUMBER: ${{ steps.determine-context.outputs.pr_number }}
        run: |
          {
            echo ""
            echo "---"
            echo "### Task Completed"
            echo ""
            echo "- **Task:** ${TASK_NAME}"
            echo "- **PR:** #${PR_NUMBER}"
            echo "- **Status:** Completed and cleaned up"
            echo ""
            echo "The AI has analyzed the PR and commented with documentation recommendations."
          } >> "${GITHUB_STEP_SUMMARY}"
