name: go-flake-check

on:
  pull_request:
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

jobs:
  changed-go-tests:
    runs-on: ${{ github.repository_owner == 'coder' && 'depot-ubuntu-22.04-8' || 'ubuntu-latest' }}
    outputs:
      any_changed: ${{ steps.changed.outputs.any_changed }}
      files: ${{ steps.changed.outputs.all_changed_files }}
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0
        with:
          fetch-depth: 0

      - id: changed
        name: Detect changed go test files
        uses: tj-actions/changed-files@v44
        with:
          files: |
            **/*_test.go

  go-flake:
    needs: changed-go-tests
    if: needs.changed-go-tests.outputs.any_changed == 'true'
    runs-on: ${{ github.repository_owner == 'coder' && 'depot-ubuntu-22.04-8' || 'ubuntu-latest' }}
    timeout-minutes: 30
    env:
      ATTEMPTS: '10'
      POSTGRES_VERSION: '17'
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0
        with:
          fetch-depth: 1

      - name: Setup Go
        uses: ./.github/actions/setup-go

      - name: Ensure jq
        run: |
          if ! command -v jq >/dev/null; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Start Postgres (reuse CI helper)
        run: |
          make test-postgres-docker

      - name: Build package and test regex from changed files
        id: gometa
        shell: bash
        run: |
          set -euo pipefail
          printf '%s\n' "${{ needs.changed-go-tests.outputs.files }}" | tr ' ' '\n' | sed '/^$/d' > /tmp/go_changed_files.txt
          sort -u /tmp/go_changed_files.txt -o /tmp/go_changed_files.txt

          pkgs=$(awk '{print $0}' /tmp/go_changed_files.txt | xargs -I{} dirname {} | sort -u | while read d; do (cd "$d" && go list -f '{{.ImportPath}}'); done)
          if [ -z "$pkgs" ]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "pkgs=$pkgs" >> "$GITHUB_OUTPUT"

          tests=$(awk '{print $0}' /tmp/go_changed_files.txt | xargs -I{} sh -c "sed -nE 's/^func[[:space:]]+(Test[[:alnum:]_]+)[[:space:]]*\\(.*/\\1/p' {}" | sort -u | paste -sd'|' -)
          if [ -z "$tests" ]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "regex=^(${tests})(/.*)?$" >> "$GITHUB_OUTPUT"

      - name: Run repeated tests to detect flakiness
        if: steps.gometa.outputs.skip != 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p flake/go json
          regex='${{ steps.gometa.outputs.regex }}'
          pkgs='${{ steps.gometa.outputs.pkgs }}'

          # Run ATTEMPTS times, fresh process each time for new shuffle seed and per-attempt JSON events
          for i in $(seq 1 ${ATTEMPTS}); do
            for p in $pkgs; do
              go test -json -run "$regex" -count=1 -shuffle=on "$p" \
                | tee "json/run-$i-$(echo "$p" | tr '/.' '__').json" >/dev/null || true
            done
          done

          # Aggregate pass/fail counts per test or subtest
          jq -s '
            map(select(.Action=="pass" or .Action=="fail") | select(.Test)) as $events
            | reduce $events[] as $e ({}; .[$e.Test] = (
                .[$e.Test] // {pass:0,fail:0}
                | if $e.Action=="pass" then (.pass+=1) else (.fail+=1) end
              )
            )
          ' json/*.json > json/counts.json

          # Build unfiltered lists
          jq 'to_entries | map(select(.value.fail>0 and .value.pass>0) | {name:.key, pass:.value.pass, fail:.value.fail})' json/counts.json > json/flaky.json
          jq 'to_entries | map(select(.value.fail>0 and ((.value.pass//0)==0)) | {name:.key, fail:.value.fail})' json/counts.json > json/failing.json

          # Filter out parent tests if any subtests exist, for both flaky and failing lists
          filtered_flaky=$(
            jq -r '.[] | .name' json/flaky.json | awk '
              {
                if (index($0, "/")) {
                  subtests[++subtest_count] = $0
                  parent = substr($0, 1, index($0, "/")-1)
                  has_subtest[parent] = 1
                } else {
                  parents[++parent_count] = $0
                }
              }
              END {
                for (i=1; i<=subtest_count; i++) print subtests[i]
                for (i=1; i<=parent_count; i++) if (!(parents[i] in has_subtest)) print parents[i]
              }
            '
          )

          filtered_failing=$(
            jq -r '.[].name' json/failing.json | awk '
              {
                if (index($0, "/")) {
                  subtests[++subtest_count] = $0
                  parent = substr($0, 1, index($0, "/")-1)
                  has_subtest[parent] = 1
                } else {
                  parents[++parent_count] = $0
                }
              }
              END {
                for (i=1; i<=subtest_count; i++) print subtests[i]
                for (i=1; i<=parent_count; i++) if (!(parents[i] in has_subtest)) print parents[i]
              }
            '
          )

          # Counts based on filtered lists (avoid double-counting parents)
          flaky_count=$(printf "%s\n" "$filtered_flaky" | sed '/^$/d' | wc -l | tr -d ' ')
          fail_count=$(printf "%s\n" "$filtered_failing" | sed '/^$/d' | wc -l | tr -d ' ')

          # Build "name (failed x/y times)" details from counts.json
          build_details() {
            input_list="$1"
            out=""
            while IFS= read -r test; do
              [ -z "$test" ] && continue
              detail=$(jq -r --arg test "$test" '
                to_entries
                | map(select(.key==$test))
                | if length>0 then
                    .[0].value
                    | "\($test) (failed \(.fail)/\(.pass+.fail) times)"
                  else empty end
              ' json/counts.json)
              if [ -n "$detail" ]; then
                if [ -n "$out" ]; then out="$out, $detail"; else out="$detail"; fi
              fi
            done <<< "$input_list"
            printf "%s" "$out"
          }

          flaky_details=$(build_details "$filtered_flaky")
          failing_details=$(build_details "$filtered_failing")

          # Print single-line header and clean sections (no literal "\n")
          if [ "$flaky_count" -gt 0 ] || [ "$fail_count" -gt 0 ]; then
            printf "Flaky or failing tests detected after %s runs: flaky=%s failing=%s\n" "$ATTEMPTS" "$flaky_count" "$fail_count" >> "$GITHUB_STEP_SUMMARY"
            if [ -n "$flaky_details" ]; then
              printf "Flaky tests: %s\n" "$flaky_details" >> "$GITHUB_STEP_SUMMARY"
            fi
            if [ -n "$failing_details" ]; then
              printf "Consistently failing tests: %s\n" "$failing_details" >> "$GITHUB_STEP_SUMMARY"
            fi
          else
            printf "No flaky or failing tests detected after %s runs.\n" "$ATTEMPTS" >> "$GITHUB_STEP_SUMMARY"
          fi

          # Raw fail event count from go test -json to ensure we fail when any test failed at least once
          raw_fail_count=$(
            jq -s 'map(select(.Action=="fail" and .Test)) | map(.Test) | unique | length' json/run-*.json
          )

          # Emit error and fail the job if instability found
          if [ "$raw_fail_count" -gt 0 ] || [ "$flaky_count" -gt 0 ] || [ "$fail_count" -gt 0 ]; then
            err="Flaky or failing tests detected after ${ATTEMPTS} runs: raw_fail=${raw_fail_count} flaky=${flaky_count} failing=${fail_count}"
            if [ -n "$flaky_details" ]; then err="$err. Flaky tests: $flaky_details"; fi
            if [ -n "$failing_details" ]; then err="$err. Consistently failing tests: $failing_details"; fi
            echo "::error::$err"
            exit 1
          fi

      - name: Upload artifacts
        if: ${{ always() && steps.gometa.outputs.skip != 'true' }}
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: go-flake-json
          path: json/

  no-changed-tests:
    needs: changed-go-tests
    if: needs.changed-go-tests.outputs.any_changed != 'true'
    runs-on: ubuntu-latest
    steps:
      - run: echo "No changed Go tests in this PR" >> "$GITHUB_STEP_SUMMARY"
