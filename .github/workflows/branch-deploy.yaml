name: Deploy Branch

on:
  push:
  workflow_dispatch:
    inputs:
      deploy_only:
        description: "Skip build and only run deploy (debug-only)."
        required: false
        default: false
        type: boolean

permissions:
  contents: read

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  build:
    if: ${{ github.event_name != 'workflow_dispatch' || !inputs.deploy_only }}
    runs-on: ${{ github.repository_owner == 'coder' && 'depot-ubuntu-22.04-8' || 'ubuntu-latest' }}
    permissions:
      packages: write
    env:
      CODER_IMAGE_TAG: "ghcr.io/coder/coder-preview:${{ github.ref_name }}"
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9 # v2.14.1
        with:
          egress-policy: audit

      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Node
        uses: ./.github/actions/setup-node

      - name: Setup Go
        uses: ./.github/actions/setup-go

      - name: Setup sqlc
        uses: ./.github/actions/setup-sqlc

      - name: GHCR Login
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        run: |
          set -euo pipefail
          go mod download
          make gen/mark-fresh
          export DOCKER_IMAGE_NO_PREREQUISITES=true
          version="$(./scripts/version.sh)"
          CODER_IMAGE_BUILD_BASE_TAG="$(CODER_IMAGE_BASE=coder-base ./scripts/image_tag.sh --version "$version")"
          export CODER_IMAGE_BUILD_BASE_TAG
          make -j build/coder_linux_amd64
          ./scripts/build_docker.sh \
            --arch amd64 \
            --target "${CODER_IMAGE_TAG}" \
            --version "$version" \
            --push \
            build/coder_linux_amd64

  deploy:
    needs: build
    if: ${{ always() && (needs.build.result == 'success' || (github.event_name == 'workflow_dispatch' && inputs.deploy_only && needs.build.result == 'skipped')) }}
    runs-on: ubuntu-latest
    env:
      # The existing pr-deployments templates use PR_NUMBER and
      # PR_HOSTNAME. We set them to the branch name so templates
      # work without modification.
      PR_NUMBER: ${{ github.ref_name }}
      PR_HOSTNAME: "${{ github.ref_name }}.${{ secrets.PR_DEPLOYMENTS_DOMAIN }}"
      CODER_IMAGE_TAG: "ghcr.io/coder/coder-preview:${{ github.ref_name }}"
      EXPERIMENTS: "*"
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9 # v2.14.1
        with:
          egress-policy: audit

      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          persist-credentials: false

      - name: Set up kubeconfig
        run: |
          set -euo pipefail
          mkdir -p ~/.kube
          echo "${{ secrets.PR_DEPLOYMENTS_KUBECONFIG_BASE64 }}" | base64 --decode > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Verify cluster authentication
        run: |
          set -euo pipefail
          kubectl auth can-i get namespaces > /dev/null

      - name: Check if deployment exists
        id: check
        run: |
          set -euo pipefail

          set +e
          helm_status_output="$(helm status "${{ github.ref_name }}" --namespace "${{ github.ref_name }}" 2>&1)"
          helm_status_code=$?
          set -e

          if [ "$helm_status_code" -eq 0 ]; then
            echo "new=false" >> "$GITHUB_OUTPUT"
          elif echo "$helm_status_output" | grep -qi "release: not found"; then
            echo "new=true" >> "$GITHUB_OUTPUT"
          else
            echo "$helm_status_output"
            exit "$helm_status_code"
          fi

      # ---- First deploy only ----

      - name: Add DNS record
        if: steps.check.outputs.new == 'true'
        run: |
          set -euo pipefail

          max_attempts=6
          attempt=1
          last_response=""
          last_http_code=""

          while [ "$attempt" -le "$max_attempts" ]; do
            echo "Creating DNS record for ${PR_HOSTNAME} (attempt ${attempt}/${max_attempts})."

            set +e
            raw_response="$(
              curl -sS -X POST "https://api.cloudflare.com/client/v4/zones/${{ secrets.PR_DEPLOYMENTS_ZONE_ID }}/dns_records" \
                -H "Authorization: Bearer ${{ secrets.PR_DEPLOYMENTS_CLOUDFLARE_API_TOKEN }}" \
                -H "Content-Type:application/json" \
                --data '{"type":"CNAME","name":"*.'"${PR_HOSTNAME}"'","content":"'"${PR_HOSTNAME}"'","ttl":1,"proxied":false}' \
                -w '\n%{http_code}'
            )"
            curl_exit_code=$?
            set -e

            curl_failed=false
            if [ "$curl_exit_code" -eq 0 ]; then
              response="${raw_response%$'\n'*}"
              http_code="${raw_response##*$'\n'}"
            else
              response="curl exited with code ${curl_exit_code}."
              http_code="000"
              curl_failed=true
            fi

            last_response="$response"
            last_http_code="$http_code"

            if echo "$response" | jq -e '.success == true' > /dev/null 2>&1; then
              echo "Created DNS record for ${PR_HOSTNAME}."
              exit 0
            fi

            # Cloudflare returns 81057 when the record already exists.
            if echo "$response" | jq -e '.errors[]? | select(.code == 81057)' > /dev/null 2>&1; then
              echo "DNS record already exists for ${PR_HOSTNAME}."
              exit 0
            fi

            transient_error=false
            if [ "$curl_failed" = true ] || [ "$http_code" = "429" ]; then
              transient_error=true
            elif [[ "$http_code" =~ ^[0-9]{3}$ ]] && [ "$http_code" -ge 500 ] && [ "$http_code" -lt 600 ]; then
              transient_error=true
            fi

            if echo "$response" | jq -e '.errors[]? | select(.code == 10000 or .code == 10001)' > /dev/null 2>&1; then
              transient_error=true
            fi

            if [ "$transient_error" = true ] && [ "$attempt" -lt "$max_attempts" ]; then
              sleep_seconds=$((attempt * 5))
              echo "Transient Cloudflare API error (HTTP ${http_code}). Retrying in ${sleep_seconds}s."
              sleep "$sleep_seconds"
              attempt=$((attempt + 1))
              continue
            fi

            break
          done

          echo "Cloudflare API error while creating DNS record after ${attempt} attempt(s):"
          echo "HTTP status: ${last_http_code}"
          echo "$last_response"
          exit 1

      - name: Create namespace
        if: steps.check.outputs.new == 'true'
        run: |
          set -euo pipefail
          kubectl delete namespace "${PR_NUMBER}" || true
          kubectl create namespace "${PR_NUMBER}"

      - name: Create certificate
        if: steps.check.outputs.new == 'true'
        run: |
          set -euo pipefail
          cert_secret_name="pr${PR_NUMBER}-tls"

          if ! kubectl get certificate "${cert_secret_name}" -n pr-deployment-certs > /dev/null 2>&1; then
            envsubst < ./.github/pr-deployments/certificate.yaml | kubectl apply -f -
          fi

          cert_ready=false
          for attempt in $(seq 1 120); do
            if kubectl get secret "${cert_secret_name}" -n pr-deployment-certs > /dev/null 2>&1; then
              cert_ready=true
              break
            fi

            echo "Waiting for certificate secret ${cert_secret_name} (${attempt}/120)..."
            sleep 5
          done

          if [ "$cert_ready" != true ]; then
            echo "Timed out waiting for certificate secret ${cert_secret_name} after 10 minutes."
            kubectl -n pr-deployment-certs describe certificate "${cert_secret_name}" || true
            kubectl -n pr-deployment-certs get certificaterequest,order,challenge -l "cert-manager.io/certificate-name=${cert_secret_name}" || true
            exit 1
          fi

          kubectl get secret "${cert_secret_name}" -n pr-deployment-certs -o json |
            jq 'del(.metadata.namespace,.metadata.creationTimestamp,.metadata.resourceVersion,.metadata.selfLink,.metadata.uid,.metadata.managedFields)' |
            kubectl -n "${PR_NUMBER}" apply -f -

      - name: Set up PostgreSQL
        if: steps.check.outputs.new == 'true'
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm install coder-db bitnami/postgresql \
            --namespace "${PR_NUMBER}" \
            --set image.repository=bitnamilegacy/postgresql \
            --set auth.username=coder \
            --set auth.password=coder \
            --set auth.database=coder \
            --set persistence.size=10Gi
          kubectl create secret generic coder-db-url -n "${PR_NUMBER}" \
            --from-literal=url="postgres://coder:coder@coder-db-postgresql.${PR_NUMBER}.svc.cluster.local:5432/coder?sslmode=disable"

      - name: Create RBAC
        if: steps.check.outputs.new == 'true'
        run: envsubst < ./.github/pr-deployments/rbac.yaml | kubectl apply -f -

      # ---- Every push ----

      - name: Create values.yaml
        env:
          PR_DEPLOYMENTS_GITHUB_OAUTH_CLIENT_ID: ${{ secrets.PR_DEPLOYMENTS_GITHUB_OAUTH_CLIENT_ID }}
          PR_DEPLOYMENTS_GITHUB_OAUTH_CLIENT_SECRET: ${{ secrets.PR_DEPLOYMENTS_GITHUB_OAUTH_CLIENT_SECRET }}
        run: envsubst < ./.github/pr-deployments/values.yaml > ./deploy-values.yaml

      - name: Install/Upgrade Helm chart
        run: |
          set -euo pipefail
          helm dependency update --skip-refresh ./helm/coder
          helm upgrade --install "${PR_NUMBER}" ./helm/coder \
            --namespace "${PR_NUMBER}" \
            --values ./deploy-values.yaml \
            --force

      - name: Install coder-logstream-kube
        if: steps.check.outputs.new == 'true'
        run: |
          helm repo add coder-logstream-kube https://helm.coder.com/logstream-kube
          helm upgrade --install coder-logstream-kube coder-logstream-kube/coder-logstream-kube \
            --namespace "${PR_NUMBER}" \
            --set url="https://${PR_HOSTNAME}"

      - name: Create first user and template
        if: steps.check.outputs.new == 'true'
        run: |
          set -euo pipefail
          URL="https://${PR_HOSTNAME}/bin/coder-linux-amd64"
          COUNT=0
          until curl --output /dev/null --silent --head --fail "$URL"; do
            sleep 5
            COUNT=$((COUNT+1))
            if [ "$COUNT" -ge 60 ]; then echo "Timed out"; exit 1; fi
          done
          curl -fsSL "$URL" -o /tmp/coder && chmod +x /tmp/coder

          password=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-12)
          echo "::add-mask::$password"

          /tmp/coder login \
            --first-user-username "${PR_NUMBER}-admin" \
            --first-user-email "${PR_NUMBER}@coder.com" \
            --first-user-password "$password" \
            --first-user-trial=false \
            --use-token-as-session \
            "https://${PR_HOSTNAME}"

          cd .github/pr-deployments/template
          /tmp/coder templates push -y --variable "namespace=${PR_NUMBER}" kubernetes
          /tmp/coder create --template="kubernetes" kube \
            --parameter cpu=2 --parameter memory=4 --parameter home_disk_size=2 -y
          /tmp/coder stop kube -y
