import { makeStyles } from "@material-ui/core/styles"
import { useMachine } from "@xstate/react"
import React from "react"
import { useLocation, useNavigate, useParams } from "react-router-dom"
import { FitAddon } from "xterm-addon-fit"
import { WebLinksAddon } from "xterm-addon-web-links"
import { XTerm } from "xterm-for-react"
import { MONOSPACE_FONT_FAMILY } from "../../theme/constants"
import { terminalMachine } from "../../xServices/terminal/terminalXService"

// TypeScript doesn't have the randomUUID type on Crypto yet. See:
// https://github.com/denoland/deno/issues/12754#issuecomment-970386235
declare global {
  interface Crypto {
    randomUUID: () => string
  }
}

export const TerminalPage: React.FC = () => {
  const location = useLocation()
  const navigate = useNavigate()
  const styles = useStyles()
  const { workspace } = useParams()
  const xtermRef = React.useRef<XTerm>(null)
  const [fitAddon, weblinksAddon] = React.useMemo(() => {
    return [new FitAddon(), new WebLinksAddon()]
  }, [])
  // The reconnection token is a unique token that identifies
  // a terminal session. It's generated by the client to reduce
  // a round-trip, and must be a UUIDv4.
  const [reconnectionToken] = React.useState<string>(() => {
    const search = new URLSearchParams(location.search)
    let reconnect = search.get("reconnect")
    if (reconnect == null) {
      reconnect = crypto.randomUUID()
    }
    return reconnect
  })
  const [terminalState, sendEvent] = useMachine(terminalMachine, {
    actions: {
      readMessage: (_, event) => {
        xtermRef.current?.terminal.write(new Uint8Array(event.data))
      },
    },
  })
  const isConnected = terminalState.matches("connected")

  // Triggers the initial terminal connection using
  // the reconnection token and workspace name found
  // from the router.
  React.useEffect(() => {
    const search = new URLSearchParams(location.search)
    search.set("reconnect", reconnectionToken)
    navigate(
      {
        search: search.toString(),
      },
      {
        replace: true,
      },
    )
    sendEvent({
      type: "CONNECT",
      reconnection: reconnectionToken,
      workspaceName: workspace!,
    })
  }, [sendEvent, reconnectionToken])

  // Listen for window resize events and trigger a "fit"
  // of the terminal. This ensures it's maximized to the screen.
  React.useEffect(() => {
    const listener = () => {
      // This will trigger a resize event on the terminal.
      fitAddon.fit()
    }
    window.addEventListener("resize", listener)
    return () => {
      window.removeEventListener("resize", listener)
    }
  }, [xtermRef])

  // Apply terminal options based on connection state.
  React.useEffect(() => {
    if (!xtermRef.current || !xtermRef.current.terminal) {
      return
    }

    if (!isConnected) {
      // Disable user input when not connected.
      xtermRef.current.terminal.options = {
        disableStdin: true,
      }
      return
    }
    // The terminal should be cleared on each reconnect
    // because all data is re-rendered from the backend.
    xtermRef.current.terminal.clear()
    // Focusing on connection allows users to reload the
    // page and start typing immediately.
    xtermRef.current.terminal.focus()
    xtermRef.current.terminal.options = {
      disableStdin: false,
    }

    // We have to fit twice here. It's unknown why, but
    // the first fit will overflow slightly in some
    // scenarios. Applying a second fit resolves this.
    fitAddon.fit()
    fitAddon.fit()

    // Update the terminal size post-fit.
    sendEvent({
      type: "WRITE",
      request: {
        height: xtermRef.current.terminal.rows,
        width: xtermRef.current.terminal.cols,
      },
    })
  }, [isConnected])

  return (
    <>
      <div className={`${styles.overlay} ${isConnected ? "connected" : ""}`} />
      <XTerm
        addons={[fitAddon, weblinksAddon]}
        className={styles.terminal}
        ref={xtermRef}
        options={{
          disableStdin: false,
          fontFamily: MONOSPACE_FONT_FAMILY,
          fontSize: 16,
          theme: {
            // This is a slight off-black.
            // It's really easy on the eyes!
            background: "#1F1F1F",
          },
        }}
        onData={(data) => {
          sendEvent({
            type: "WRITE",
            request: {
              data: data,
            },
          })
        }}
        onResize={(event) => {
          sendEvent({
            type: "WRITE",
            request: {
              height: event.rows,
              width: event.cols,
            },
          })
        }}
      />
    </>
  )
}

const useStyles = makeStyles(() => ({
  overlay: {
    position: "absolute",
    pointerEvents: "none",
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    zIndex: 1,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    "&.connected": {
      opacity: 0,
    },
  },
  terminal: {
    width: "100vw",
    height: "100vh",
    // These styles attempt to mimic the VS Code scrollbar.
    "& .xterm": {
      padding: 4,
      width: "100vw",
      height: "100vh",
    },
    "& .xterm-viewport::-webkit-scrollbar": {
      width: "10px",
    },
    "& .xterm-viewport::-webkit-scrollbar-track": {
      backgroundColor: "inherit",
    },
    "& .xterm-viewport::-webkit-scrollbar-thumb": {
      minHeight: 20,
      backgroundColor: "rgba(255, 255, 255, 0.18)",
    },
  },
}))
